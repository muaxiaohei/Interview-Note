# 0 åŸºç¡€çŸ¥è¯†ç‚¹

> å…¶å®åµŒè½¯æ²¡å¿…è¦çœ‹é‚£ä¹ˆå¤šï¼Œä¸‹é¢ä¹Ÿæ˜¯æŒ‘ç€å†™ã€‚

![æ•°æ®ç»“æ„å’Œç®—æ³•](figures/æ•°æ®ç»“æ„å’Œç®—æ³•.jpg)

## 0.1 å¸¸ç”¨æ•°æ®ç»“æ„æ“ä½œçš„å¤æ‚åº¦

![img](figures/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQwNTEyOA==,size_16,color_FFFFFF,t_70.png)

## 0.2 å¤§Oå¤æ‚åº¦æ¯”è¾ƒ

![Image from bigocheatsheet.com](figures/s_2D428973624E7FC84C7D69D11421DE762BEA6B6F3361231FCDCAE0425D14526F_1664885448372_Untitled.drawio+17.png)

## 0.3 å¸¸ç”¨C++å¤„ç†å‡½æ•°

1. åˆ¤æ–­æ˜¯å¦ä¸ºå­—æ¯ï¼š`isalpha()`
2. åˆ¤æ–­æ˜¯å¦ä¸ºæ•°å­—ï¼š`isdigit()`
3. åˆ¤æ–­æ˜¯å¦æ˜¯æ•°å­—æˆ–å­—æ¯ï¼š`isalnum()`
4. åˆ¤æ–­æ˜¯å¦æ˜¯å¤§/å°å†™ï¼š`islower()`ã€`isupper()`
5. å¤§å°å†™äº’è½¬ï¼š`toupper`ã€`tolower()`

## 0.4 å®ç°å­—ç¬¦ä¸²ç›¸å…³çš„åº“å‡½æ•°

Reference: [C Programming/string.h - Wikibooks, open books for an open world](https://en.wikibooks.org/wiki/C_Programming/string.h)

[string.c source code linux/lib/string.c\] - Codebrowser](https://codebrowser.dev/linux/linux/lib/string.c.html#strlen)

### 0.4.1 strcpy

```c
char *strcpy(char *dest, const char *src)
{
	char *tmp = dest;
	while ((*dest++ = *src++) != '\0');
	return tmp;
}
```

### 0.4.2 strncpy

```c
char *strncpy(char *dest, const char *src, size_t n)
{
	char *tmp = dest;
	while (count--) 
    {
		if ((*tmp = *src) != 0)	src++;
		tmp++;
	}
	return dest;
}
```

### 0.4.3 strchr

```c
char *strchr(char *str, int c) 
{
    for(; *str != (char)c; ++str)
        if(*str == '\0')	return NULL;
    return str;
}
```

### 0.4.4 strcat

```c
char *strcat(char *dest, char *src)
{
    char *tmp = dest;
	while (*dest)	dest++;
	while ((*dest++ = *src++) != '\0');
	return tmp;
}
```

### 0.4.5 strncat

```c
char *strncat(char *dest, const char *src, size_t count)
{
	char *tmp = dest;
	if (count) 
    {
		while (*dest)	dest++;
		while ((*dest++ = *src++) != 0) 
        {
			if (--count == 0) 
            {
				*dest = '\0';
				break;
			}
		}
	}
	return tmp;
}
```

### 0.4.6 strncat

```c
int strcmp(const char *cs, const char *ct)
{
	unsigned char c1, c2;
	while (1) 
    {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
			break;
	}
	return 0;
}
```

### 0.4.7 strncmp

```c
/**
 * strncmp - Compare two length-limited strings
 * @cs: One string
 * @ct: Another string
 * @count: The maximum number of bytes to compare
 */
int strncmp(const char *cs, const char *ct, size_t count)
{
	unsigned char c1, c2;
	while (count) 
    {
		c1 = *cs++;
		c2 = *ct++;
		if (c1 != c2)
			return c1 < c2 ? -1 : 1;
		if (!c1)
			break;
		count--;
	}
	return 0;
}
```

### 0.4.8 strchr

```c
/**
 * strchr - Find the first occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 *
 * Note that the %NUL-terminator is considered part of the string, and can
 * be searched for.
 */
char *strchr(const char *s, int c)
{
	for (; *s != (char)c; ++s)
		if (*s == '\0')
			return NULL;
	return (char *)s;
}
```

### 0.4.9 strchr

```c
/**
 * strrchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char *strrchr(const char *s, int c)
{
	const char *last = NULL;
	do 
    {
		if (*s == (char)c)
			last = s;
	} while (*s++);
	return (char *)last;
}
```

### 0.4.10 strlen

```
size_t strlen(const char *str)
{
    const char *s;
    for (s = str; *s; ++s);
    return(s - str);
}
```

### 0.4.11 strnlen

```c
size_t strnlen(const char *s, size_t count)
{
	const char *sc;
	for (sc = s; count-- && *sc != '\0'; ++sc);
	return sc - s;
}
```

### 0.4.12 strstr

```c
/**
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char *strstr(const char *s1, const char *s2)
{
	size_t l1, l2;
	l2 = strlen(s2);
	if (!l2)
		return (char *)s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
		l1--;
		if (!memcmp(s1, s2, l2))
			return (char *)s1;
		s1++;
	}
	return NULL;
}
```

### 0.4.13 strnstr

```c
/**
 * strnstr - Find the first substring in a length-limited string
 * @s1: The string to be searched
 * @s2: The string to search for
 * @len: the maximum number of characters to search
 */
char *strnstr(const char *s1, const char *s2, size_t len)
{
	size_t l2;
	l2 = strlen(s2);
	if (!l2)
		return (char *)s1;
	while (len >= l2) {
		len--;
		if (!memcmp(s1, s2, l2))
			return (char *)s1;
		s1++;
	}
	return NULL;
}
```

### 0.4.14 memcmp

```c
/**
 * memcmp - Compare two areas of memory
 * @cs: One area of memory
 * @ct: Another area of memory
 * @count: The size of the area.
 */
int memcmp(const void *cs, const void *ct, size_t count)
{
	const unsigned char *su1, *su2;
	int res = 0;
#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
	if (count >= sizeof(unsigned long)) 
    {
		const unsigned long *u1 = cs;
		const unsigned long *u2 = ct;
		do 
        {
			if (get_unaligned(u1) != get_unaligned(u2))
				break;
			u1++;
			u2++;
			count -= sizeof(unsigned long);
		} while (count >= sizeof(unsigned long));
		cs = u1;
		ct = u2;
	}
#endif
    for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
		if ((res = *su1 - *su2) != 0)
			break;
	return res;		// ä¸‹é¢è¿™ç§æ–¹æ³•å³å¯
}
```

### 0.4.15 memchr

```c
/**
 * memchr - Find a character in an area of memory.
 * @s: The memory area
 * @c: The byte to search for
 * @n: The size of the area.
 *
 * returns the address of the first occurrence of @c, or %NULL
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t count)
{
	const unsigned char *p = s;
	while (count--)
		if ((unsigned char)c == *p++)
			return (void *)(p - 1);
	return NULL;
}
```

### 0.4.16 memset

```c
/**
 * memset - Fill a region of memory with the given value
 * @s: Pointer to the start of the area.
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void *memset(void *s, int c, size_t count)
{
	char *xs = s;
	while (count--)
		*xs++ = c;
	return s;
}
```

### 0.4.17 memcpy

```c
/**
 * memcpy - Copy one area of memory to another
 * @dest: Where to copy to
 * @src: Where to copy from
 * @count: The size of the area.
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void *memcpy(void *dest, const void *src, size_t count)
{
	char *tmp = dest;
	const char *s = src;
	while (count--)
		*tmp++ = *s++;
	return dest;
}
```

### 0.4.18 memchr

```c
/**
 * memchr - Find a character in an area of memory.
 * @s: The memory area
 * @c: The byte to search for
 * @n: The size of the area.
 *
 * returns the address of the first occurrence of @c, or %NULL
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
        	if ((unsigned char)c == *p++) {
			return (void *)(p - 1);
		}
	}
	return NULL;
}
```

### 0.4.19 itoa

```c
char *itoa(int n, char *s)
{
    int sign, i = 0, j = 0;
	if((sign = n) < 0)	n = -n;	// è½¬æ¢ä¸ºæ­£æ•°
    do
    {
        s[i++] = n % 10 + '0';
    }while((n /= 10) > 0);
    
    s[i] = '\0';
    
    if(s[0] == '\0')
    {
        j = 1;
        ++i;
    }
    for(; j < i / 2; ++j)
    {
        s[j] = s[j] + s[i - 1 - j];
        s[i - 1 - j] = s[j] - s[i - 1 - j];
        s[j] = s[j] - s[i - 1 - j];
    }
    
    return s;
}

// æˆ–
 /* reverse:  reverse string s in place */
void reverse(char s[])
{
    int i, j;
    char c;

    for (i = 0, j = strlen(s)-1; i<j; i++, j--) {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}

 /* itoa:  convert n to characters in s */
 void itoa(int n, char s[])
 {
     int i, sign;
 
     if ((sign = n) < 0)  /* record sign */
         n = -n;          /* make n positive */
     i = 0;
     do {       /* generate digits in reverse order */
         s[i++] = n % 10 + '0';   /* get next digit */
     } while ((n /= 10) > 0);     /* delete it */
     if (sign < 0)
         s[i++] = '-';
     s[i] = '\0';
     reverse(s);
 }
```

### 0.4.20 atoi

```c
int atoi(const char *s)
{
    int i, n, sign = 1;
    while(isspace(*s++));
    
    if (*str == '+')	++str;
	else if(*str == '-')	
    {
        ++str;
        sign = -1;
    }
    
    int res = 0;
    for(; isdigit(*str); ++str)
    {
        int digit = *str - '0';
        res *= 10;
       	res += digit;
    }
    
    return sign * res;
}
```

# 1 åŸºæœ¬è¾“å…¥è¾“å‡ºç»ƒä¹ 

[ç‰›å®¢ç«èµ›_ACM/NOI/CSP/CCPC/ICPCç®—æ³•ç¼–ç¨‹é«˜éš¾åº¦ç»ƒä¹ èµ›_ç‰›å®¢ç«èµ›OJ (nowcoder.com)](https://ac.nowcoder.com/acm/contest/5652#question)

## 1.1 A+B(1)

è®¡ç®—a+b

æ•°æ®èŒƒå›´ï¼š æ•°æ®ç»„æ•°$1â‰¤tâ‰¤100$ï¼Œæ•°æ®å¤§å°æ»¡è¶³ $1â‰¤nâ‰¤1000$
è¾“å…¥æè¿°:

```
è¾“å…¥åŒ…æ‹¬ä¸¤ä¸ªæ­£æ•´æ•°a,b(1 <= a, b <= 1000),è¾“å…¥æ•°æ®åŒ…æ‹¬å¤šç»„ã€‚
```

è¾“å‡ºæè¿°:

```
è¾“å‡ºa+bçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int m, n;
	while(cin >> m >> n)
	{
		cout << m + n << endl;
	}
	return 0;
}
```

## 1.2 A+B(2)

è®¡ç®—a+b

æ•°æ®èŒƒå›´ï¼šæ•°æ®ç»„æ•°æ»¡è¶³$1 <= t <= 100$ï¼Œæ•°æ®å¤§å°æ»¡è¶³ $1 <= a, b <= 1000$

è¾“å…¥æè¿°:

```
è¾“å…¥ç¬¬ä¸€è¡ŒåŒ…æ‹¬ä¸€ä¸ªæ•°æ®ç»„æ•°t(1 <= t <= 100)
æ¥ä¸‹æ¥æ¯è¡ŒåŒ…æ‹¬ä¸¤ä¸ªæ­£æ•´æ•°a,b(1 <= a, b <= 1000)
```

è¾“å‡ºæè¿°:

```
è¾“å‡ºa+bçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int line_num(0);
	int m(0), n(0);
	
	cin >> line_num;
	while(line_num--)
	{
		cin >> m >> n;
		cout << m + n << endl;
	}

	return 0;
}
```

## 1.3 A+B(3)

è®¡ç®—a+b

æ•°æ®èŒƒå›´ï¼šæ•°æ®ç»„æ•°æ»¡è¶³$1â‰¤tâ‰¤100$ï¼Œæ•°æ®å¤§å°æ»¡è¶³$1â‰¤nâ‰¤100$

è¾“å…¥æè¿°:

```
è¾“å…¥åŒ…æ‹¬ä¸¤ä¸ªæ­£æ•´æ•°a,b(1 <= a, b <= 10^9),è¾“å…¥æ•°æ®æœ‰å¤šç»„, å¦‚æœè¾“å…¥ä¸º0 0åˆ™ç»“æŸè¾“å…¥
```

è¾“å‡ºæè¿°:

```
è¾“å‡ºa+bçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>  
usingÂ namespaceÂ std;  
  
intÂ main()  
{  
Â Â Â Â intÂ m(0),Â n(0);  
  
Â Â Â Â while(1)  
Â Â Â Â {  
Â Â Â Â Â Â Â Â cinÂ >>Â mÂ >>Â n;  
Â Â Â Â Â Â Â Â if(mÂ ==Â 0Â andÂ nÂ ==Â 0)Â Â Â Â break;  
Â Â Â Â Â Â Â Â coutÂ <<Â mÂ +Â nÂ <<Â endl;  
Â Â Â Â }  
  
Â Â Â Â returnÂ 0;  
}
```

## 1.4 A+B(4)

è®¡ç®—ä¸€ç³»åˆ—æ•°çš„å’Œ

æ•°æ®èŒƒå›´ï¼šæ•°æ®ç»„æ•°æ»¡è¶³$1â‰¤tâ‰¤100$ï¼Œæ¯ç»„æ•°æ®ä¸­æ•´æ•°ä¸ªæ•°æ»¡è¶³ $1â‰¤nâ‰¤100$Â  ï¼Œæ¯ç»„æ•°æ®ä¸­çš„å€¼æ»¡è¶³ $1â‰¤valâ‰¤100$

è¾“å…¥æè¿°:

```
è¾“å…¥åŒ…æ‹¬ä¸¤ä¸ªæ­£æ•´æ•°a,b(1 <= a, b <= 10^9),è¾“å…¥æ•°æ®æœ‰å¤šç»„, å¦‚æœè¾“å…¥ä¸º0 0åˆ™ç»“æŸè¾“å…¥
```

è¾“å‡ºæè¿°:

```
è¾“å‡ºa+bçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
usingÂ namespaceÂ std;  
  
intÂ main()  
{  
Â Â Â Â intÂ n(0);  
Â Â Â Â intÂ temp(0);  
Â Â Â Â intÂ sum(0);  
  
Â Â Â Â while(1)  
Â Â Â Â {  
Â Â Â Â Â Â Â Â cinÂ >>Â n;  
Â Â Â Â Â Â Â Â if(nÂ ==Â 0)Â Â Â Â break;  
Â Â Â Â Â Â Â Â while(n--)  
Â Â Â Â Â Â Â Â {  
Â Â Â Â Â Â Â Â Â Â Â Â cinÂ >>Â temp;  
Â Â Â Â Â Â Â Â Â Â Â Â sumÂ +=Â temp;  
Â Â Â Â Â Â Â Â }  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â coutÂ <<Â sumÂ <<Â endl;  
Â Â Â Â Â Â Â Â sumÂ =Â 0;  
Â Â Â Â }  
  
Â Â Â Â returnÂ 0;  
}
```

## 1.5 A+B(5)

è®¡ç®—ä¸€ç³»åˆ—æ•°çš„å’Œ

æ•°æ®èŒƒå›´ï¼šæ•°æ®ç»„æ•°æ»¡è¶³$1â‰¤tâ‰¤100$ï¼Œæ¯ç»„æ•°æ®ä¸­æ•´æ•°ä¸ªæ•°æ»¡è¶³ $1â‰¤nâ‰¤100$Â  ï¼Œæ¯ç»„æ•°æ®ä¸­çš„å€¼æ»¡è¶³ $1â‰¤valâ‰¤100$

è¾“å…¥æè¿°:

```
è¾“å…¥çš„ç¬¬ä¸€è¡ŒåŒ…æ‹¬ä¸€ä¸ªæ­£æ•´æ•°t(1 <= t <= 100), è¡¨ç¤ºæ•°æ®ç»„æ•°ã€‚  
æ¥ä¸‹æ¥tè¡Œ, æ¯è¡Œä¸€ç»„æ•°æ®ã€‚  
æ¯è¡Œçš„ç¬¬ä¸€ä¸ªæ•´æ•°ä¸ºæ•´æ•°çš„ä¸ªæ•°n(1 <= n <= 100)ã€‚  
æ¥ä¸‹æ¥nä¸ªæ­£æ•´æ•°, å³éœ€è¦æ±‚å’Œçš„æ¯ä¸ªæ­£æ•´æ•°ã€‚
```

è¾“å‡ºæè¿°:

```
æ¯ç»„æ•°æ®è¾“å‡ºæ±‚å’Œçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int t(0);
	int n(0);
	int temp(0);
	int sum(0);

	cin >> t;
	while(t--)
	{
		cin >> n;
		if(n == 0)	break;
		while(n--)
		{
			cin >> temp;
			sum += temp;
		}
		
		cout << sum << endl;
		sum = 0;
	}

	return 0;
}
```

## 1.6 A+B(6)

è®¡ç®—ä¸€ç³»åˆ—æ•°çš„å’Œ

æ•°æ®èŒƒå›´ï¼š$1â‰¤nâ‰¤1000$ï¼Œæ‰€æœ‰æ•°éƒ½æ»¡è¶³ $1â‰¤valâ‰¤1000$

è¾“å…¥æè¿°:

```
è¾“å…¥æ•°æ®æœ‰å¤šç»„, æ¯è¡Œè¡¨ç¤ºä¸€ç»„è¾“å…¥æ•°æ®ã€‚
æ¯è¡Œçš„ç¬¬ä¸€ä¸ªæ•´æ•°ä¸ºæ•´æ•°çš„ä¸ªæ•°n(1 <= n <= 100)ã€‚
æ¥ä¸‹æ¥nä¸ªæ­£æ•´æ•°, å³éœ€è¦æ±‚å’Œçš„æ¯ä¸ªæ­£æ•´æ•°ã€‚
```

è¾“å‡ºæè¿°:

```
æ¯ç»„æ•°æ®è¾“å‡ºæ±‚å’Œçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int n(0);
	int temp(0);
	int sum(0);

	while(cin >> n)
	{
		if(n == 0)	break;
		while(n--)
		{
			cin >> temp;
			sum += temp;
		}
		
		cout << sum << endl;
		sum = 0;
	}

	return 0;
}
```

## 1.7 A+B(7)

è®¡ç®—ä¸€ç³»åˆ—æ•°çš„å’Œ

è¾“å…¥æè¿°:

```
è¾“å…¥æ•°æ®æœ‰å¤šç»„, æ¯è¡Œè¡¨ç¤ºä¸€ç»„è¾“å…¥æ•°æ®ã€‚

æ¯è¡Œä¸å®šæœ‰nä¸ªæ•´æ•°ï¼Œç©ºæ ¼éš”å¼€ã€‚(1 <= n <= 100)ã€‚
```

è¾“å‡ºæè¿°:

```
æ¯ç»„æ•°æ®è¾“å‡ºæ±‚å’Œçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int temp(0);
	int sum(0);
	
	while(cin >> temp)		// é‡åˆ°ç©ºæ ¼æˆ–æ¢è¡Œç¬¦åœæ­¢
	{	
		sum += temp;
		if(getchar() == '\n')	// è¯»å–æ¢è¡Œç¬¦
		{
			cout << sum << endl;
			sum = 0;
		}
	}
	
	return 0;
}
```

## 1.8 å­—ç¬¦ä¸²æ’åº(1)

å¯¹è¾“å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œæ’åºåè¾“å‡º

è¾“å…¥æè¿°:

```
è¾“å…¥æœ‰ä¸¤è¡Œï¼Œç¬¬ä¸€è¡Œn
ç¬¬äºŒè¡Œæ˜¯nä¸ªå­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€
```

è¾“å‡ºæè¿°:

```
è¾“å‡ºä¸€è¡Œæ’åºåçš„å­—ç¬¦ä¸²ï¼Œç©ºæ ¼éš”å¼€ï¼Œæ— ç»“å°¾ç©ºæ ¼
```

ä»£ç ï¼š

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int main()
{
	vector<string> res;
	string temp;
	int size(0);
	
	cin >> size;
	while(size--)
	{
		cin >> temp;
		res.emplace_back(temp);
	}
	
	sort(res.begin(), res.end());
	for(auto s : res)
		cout << s << " ";
	
	return 0;
}
```

## 1.9 å­—ç¬¦ä¸²æ’åº(2)

å¯¹è¾“å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œæ’åºåè¾“å‡º

è¾“å…¥æè¿°:

```
å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ä¸€è¡Œã€‚
æ¯è¡Œé€šè¿‡ç©ºæ ¼éš”å¼€ï¼Œæœ‰nä¸ªå­—ç¬¦ï¼Œnï¼œ100
```

è¾“å‡ºæè¿°:

```
å¯¹äºæ¯ç»„æµ‹è¯•ç”¨ä¾‹ï¼Œè¾“å‡ºä¸€è¡Œæ’åºè¿‡çš„å­—ç¬¦ä¸²ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²é€šè¿‡ç©ºæ ¼éš”å¼€
```

ä»£ç ï¼š

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int main()
{
	vector<string> res;
	string temp;
	
	while(cin >> temp)
	{
		res.emplace_back(temp);
		if(getchar() == '\n')
		{
			sort(res.begin(), res.end());
			for(auto s : res)
				cout << s << " ";
			cout << endl;
			
			res.clear();
		}
	}
	
	return 0;
}
```

## 1.10 å­—ç¬¦ä¸²æ’åº(3)

å¯¹è¾“å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œæ’åºåè¾“å‡º

è¾“å…¥æè¿°:

```
å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ä¸€è¡Œã€‚
æ¯è¡Œé€šè¿‡ç©ºæ ¼éš”å¼€ï¼Œæœ‰nä¸ªå­—ç¬¦ï¼Œnï¼œ100
```

è¾“å‡ºæè¿°:

```
å¯¹äºæ¯ç»„ç”¨ä¾‹è¾“å‡ºä¸€è¡Œæ’åºåçš„å­—ç¬¦ä¸²ï¼Œç”¨','éš”å¼€ï¼Œæ— ç»“å°¾ç©ºæ ¼
```

ä»£ç ï¼š

```c++
#include<iostream>
#include<algorithm>
#include<vector>
#include<sstream>
using namespace std;

int main()
{
	string s;
	
	while(getline(cin, s))
	{
		vector<string>buf;
		stringstream ss(s);
		string temp;
		while(getline(ss, temp, ','))
		{
			buf.push_back(temp);
		}
		sort(buf.begin(), buf.end());
		for(decltype(buf.size()) i = 0; i < buf.size()-1; i++)
		{
			cout << buf[i] << ",";
		}
		cout << buf.back() << endl;
		
	}
	return 0;
}
```

## 1.11 è‡ªæµ‹æœ¬åœ°é€šè¿‡æäº¤ä¸º0

æ¯å¹´å‰å‡ åœºåœ¨çº¿ç¬”è¯•ç¼–ç¨‹é¢˜çš„æ—¶å€™ï¼Œæ€»æœ‰åŒå­¦è¯¢é—®ä¸ºä»€ä¹ˆæˆ‘æœ¬åœ°æµ‹è¯•é€šè¿‡ï¼Œè‡ªæµ‹ä¹Ÿé€šè¿‡ï¼Œæäº¤ä»£ç ç³»ç»Ÿå´è¿”å›é€šè¿‡ç‡0ã€‚

è¿™ä¸æ˜¯ç³»ç»Ÿçš„é”™ï¼Œå¯èƒ½æ˜¯å› ä¸ºï¼š
1.ä½ å¯¹é¢˜ç›®ç†è§£é”™äº†ï¼Œä½ çš„ä»£ç åªè¿‡äº†æ ·ä¾‹æˆ–ä½ è‡ªå·±çš„æ•°æ®
2.ä½ çš„ä»£ç é€»è¾‘æœ‰é—®é¢˜ï¼Œä½ çš„ä»£ç åªè¿‡äº†æ ·ä¾‹æˆ–ä½ è‡ªå·±çš„æ•°æ®

æ€»ä¹‹å°±æ˜¯ä½ çš„ä»£ç åªæ˜¯è¿‡äº†æ ·ä¾‹å’Œè‡ªæµ‹æ•°æ®ï¼Œåå°çš„æµ‹è¯•æ•°æ®ä½ æ ¹æœ¬ä¸å¯è§ï¼Œè¦å¤šè‡ªå·±æ€è€ƒã€‚

è¿™ä¸ªé¢˜ç›®å¦‚æœä½ æäº¤åé€šè¿‡ç‡ä¸º0ï¼Œåˆè§‰å¾—è‡ªå·±ä»£ç æ˜¯æ­£ç¡®çš„ï¼Œå¯ä»¥ ç‚¹å‡»æŸ¥çœ‹ é€šè¿‡çš„ä»£ç 

è°¨è®°ï¼š
å½“ä½ ç¬”è¯•çš„æ—¶å€™æ€€ç–‘ç³»ç»Ÿæˆ–è€…é¢˜ç›®æ•°æ®æœ‰é—®é¢˜çš„æ—¶å€™è¯·åŠ¡å¿…å…ˆæ€€ç–‘è‡ªå·±çš„ä»£ç !

å½“ä½ ç¬”è¯•çš„æ—¶å€™æ€€ç–‘ç³»ç»Ÿæˆ–è€…é¢˜ç›®æ•°æ®æœ‰é—®é¢˜çš„æ—¶å€™è¯·åŠ¡å¿…å…ˆæ€€ç–‘è‡ªå·±çš„ä»£ç !

æ•°æ®èŒƒå›´ï¼š $0<a,b<2Ã—10^{10}$

è¾“å…¥æè¿°:

```
è¾“å…¥æœ‰å¤šç»„æµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ç»„ç©ºæ ¼éš”å¼€ä¸¤ä¸ªæ•´æ•°
```

è¾“å‡ºæè¿°:

```
å¯¹äºæ¯ç»„æ•°æ®è¾“å‡ºä¸€è¡Œä¸¤ä¸ªæ•´æ•°çš„å’Œ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int temp(0);
	int sum(0);
	
	while(cin >> temp)		// é‡åˆ°ç©ºæ ¼æˆ–æ¢è¡Œç¬¦åœæ­¢
	{	
		sum += temp;
		if(getchar() == '\n')	// è¯»å–æ¢è¡Œç¬¦
		{
			cout << sum << endl;
			sum = 0;
		}
	}
	
	return 0;
}
```

# 2 é“¾è¡¨

## 2.1 åˆ é™¤å•é“¾è¡¨çš„é‡å¤èŠ‚ç‚¹

[é¢è¯•é¢˜ 02.01. ç§»é™¤é‡å¤èŠ‚ç‚¹ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/remove-duplicate-node-lcci/)

### 2.1.1 åŒæŒ‡é’ˆåŠ äºŒé‡å¾ªç¯

æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$ï¼Œå…¶ä¸­ $N$ æ˜¯ç»™å®šé“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®ã€‚

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) {
        ListNode* ob = head;
        while (ob != nullptr) {
            ListNode* oc = ob;
            while (oc->next != nullptr) {
                if (oc->next->val == ob->val) {
                    oc->next = oc->next->next;
                } else {
                    oc = oc->next;
                }
            }
            ob = ob->next;
        }
        return head;
    }
};
```

### 2.1.2 å“ˆå¸Œè¡¨

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­$N$æ˜¯ç»™å®šé“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®ã€‚

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œç»™å®šé“¾è¡¨ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¸ç›¸åŒï¼Œå“ˆå¸Œè¡¨ä¸­éœ€è¦å­˜å‚¨æ‰€æœ‰çš„$N$ä¸ªå€¼ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) 
    {
        if (head == nullptr) return head;
        unordered_set<int> occurred = {head->val};
        ListNode* pos = head;
        // æšä¸¾å‰é©±èŠ‚ç‚¹
        while (pos->next != nullptr) {
            // å½“å‰å¾…åˆ é™¤èŠ‚ç‚¹
            ListNode* cur = pos->next;
            if (occurred.find(cur->val) == occurred.end()) {
                occurred.insert(cur->val);
                pos = pos->next;
            } else {
                pos->next = pos->next->next;
            }
        }
        pos->next = nullptr;
        return head;
    }
};
```

## 2.2 å¦‚ä½•æ‰¾å‡ºé“¾è¡¨çš„å€’æ•°ç¬¬Kä¸ªå…ƒç´ 

[å‰‘æŒ‡ Offer 22. é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

### 2.2.1 å¿«æ…¢æŒ‡é’ˆæ³•

```c++
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode *p = head, *q = head; //åˆå§‹åŒ–
        while(k--) {   //å°† pæŒ‡é’ˆç§»åŠ¨ k æ¬¡
            p = p->next;
        }
        while(p != nullptr) {//åŒæ—¶ç§»åŠ¨ï¼Œç›´åˆ° p == nullptr
            p = p->next;
            q = q->next;
        }
        return q;
    }
};
```

### 2.2.2 æš´åŠ›è§£æ³•

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode *temp = head;
        int size = 0;

        while(temp)
        {
            temp = temp->next;
            ++size;
        }

        temp = head;
        size = size - k;
        while(size)
        {
            temp = temp->next;
            size--;
        }

        return temp;
    }
};
```

## 2.3 å¦‚ä½•æ‰¾å‡ºé“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹

[876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/middle-of-the-linked-list/)

### 2.3.1 æš´åŠ›è§£æ³•

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *temp = head;
        int size = 0;

        temp = head;
        while(temp)
        {
            temp = temp->next;
            ++size;
        }

        temp = head;
        size = size / 2;
        while(size)
        {
            --size;
            temp = temp->next;
        }

        return temp;
    }
};
```

### 2.3.2 å¿«æ…¢æŒ‡é’ˆ

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *fast = head, *slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

## 2.4 åè½¬é“¾è¡¨ï¼ˆ206ï¼‰

[å‰‘æŒ‡ Offer 24. åè½¬é“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)

### 2.4.1 é€’å½’

1. ä½¿ç”¨é€’å½’å‡½æ•°ï¼Œä¸€ç›´é€’å½’åˆ°é“¾è¡¨çš„æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œè¯¥ç»“ç‚¹å°±æ˜¯åè½¬åçš„å¤´ç»“ç‚¹ï¼Œè®°ä½œ $ret$ï¼›
2. æ­¤åï¼Œæ¯æ¬¡å‡½æ•°åœ¨è¿”å›çš„è¿‡ç¨‹ä¸­ï¼Œè®©å½“å‰ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªç»“ç‚¹çš„  $next$ æŒ‡é’ˆæŒ‡å‘å½“å‰èŠ‚ç‚¹ï¼›
3. åŒæ—¶è®©å½“å‰ç»“ç‚¹çš„  $next$ æŒ‡é’ˆæŒ‡å‘ $nullptr$ï¼Œä»è€Œå®ç°ä»é“¾è¡¨å°¾éƒ¨å¼€å§‹çš„å±€éƒ¨åè½¬ï¼›
4. å½“é€’å½’å‡½æ•°å…¨éƒ¨å‡ºæ ˆåï¼Œé“¾è¡¨åè½¬å®Œæˆã€‚

![img](figures/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == nullptr || head->next == nullptr)
            return head;

        ListNode *current = head;
        ListNode *later = head->next;

        head = reverseList(later);
        later->next = current;
        current->next = nullptr;
        return head;
    }
};
```

### 2.4.5 åŒæŒ‡é’ˆ

1. å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆï¼š $pre$ å’Œ $cur$ ï¼›$pre$åœ¨å‰ $cur$åœ¨åã€‚
2. æ¯æ¬¡è®© $pre$çš„ $next$ æŒ‡å‘ $cur$ï¼Œå®ç°ä¸€æ¬¡å±€éƒ¨åè½¬
3. å±€éƒ¨åè½¬å®Œæˆä¹‹åï¼Œ $pre$å’Œ $cur$åŒæ—¶å¾€å‰ç§»åŠ¨ä¸€ä¸ªä½ç½®
4. å¾ªç¯ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´è‡³ $pre$åˆ°è¾¾é“¾è¡¨å°¾éƒ¨

![img](figures/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur = nullptr;
        ListNode *pre = head;
        
        while (pre != nullptr) {
            ListNode* t = pre->next;
            pre->next = cur;
            cur = pre;
            pre = t;
        }
        return cur;
    }
};
```

## 2.5 ç¯å½¢é“¾è¡¨

[141. ç¯å½¢é“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/linked-list-cycle/)

### 2.5.1 å¿«æ…¢æŒ‡é’ˆ

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$æ˜¯é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°ã€‚

å½“é“¾è¡¨ä¸­ä¸å­˜åœ¨ç¯æ—¶ï¼Œå¿«æŒ‡é’ˆå°†å…ˆäºæ…¢æŒ‡é’ˆåˆ°è¾¾é“¾è¡¨å°¾éƒ¨ï¼Œé“¾è¡¨ä¸­æ¯ä¸ªèŠ‚ç‚¹è‡³å¤šè¢«è®¿é—®ä¸¤æ¬¡ã€‚

å½“é“¾è¡¨ä¸­å­˜åœ¨ç¯æ—¶ï¼Œæ¯ä¸€è½®ç§»åŠ¨åï¼Œå¿«æ…¢æŒ‡é’ˆçš„è·ç¦»å°†å‡å°ä¸€ã€‚è€Œåˆå§‹è·ç¦»ä¸ºç¯çš„é•¿åº¦ï¼Œå› æ­¤è‡³å¤šç§»åŠ¨ $N$ è½®ã€‚

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚æˆ‘ä»¬åªä½¿ç”¨äº†ä¸¤ä¸ªæŒ‡é’ˆçš„é¢å¤–ç©ºé—´ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        // å¿«æ…¢æŒ‡é’ˆ
        ListNode * bike = head;
        ListNode * car = head;

        // å¾ªç¯å†… bike æ¯æ¬¡åç§»ä¸€ä¸ªç»“ç‚¹ï¼Œ car æ¯æ¬¡åç§» 2 ä¸ªç»“ç‚¹
        // car å’Œ car->next éœ€è¦ä¸ä¸ºç©ºï¼Œå¦åˆ™ä¼šå‘ç”Ÿéæ³•å†…å­˜è®¿é—®
        // car ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆ bike è‚¯å®šä¹Ÿä¸ä¸ºç©º
        while(car != nullptr && car->next != nullptr) 
        {
            bike = bike->next;
            car = car->next->next;

            if(car == bike) return true;
        }
        return false;
    }
};
```

### 2.5.2 å“ˆå¸Œè¡¨

**å¤æ‚åº¦åˆ†æ**

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°ã€‚æœ€åæƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦éå†æ¯ä¸ªèŠ‚ç‚¹ä¸€æ¬¡ã€‚

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°ã€‚ä¸»è¦ä¸ºå“ˆå¸Œè¡¨çš„å¼€é”€ï¼Œæœ€åæƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦å°†æ¯ä¸ªèŠ‚ç‚¹æ’å…¥åˆ°å“ˆå¸Œè¡¨ä¸­ä¸€æ¬¡ã€‚

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_set<ListNode*> seen;
        while (head != nullptr) {
            if (seen.count(head)) {
                return true;
            }
            seen.insert(head);
            head = head->next;
        }
        return false;
    }
};
```

## 2.6 é“¾è¡¨ç›¸äº¤

[é¢è¯•é¢˜ 02.07. é“¾è¡¨ç›¸äº¤ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

### 2.6.1 åŒæŒ‡é’ˆ

å¤æ‚åº¦åˆ†æï¼š
æ—¶é—´å¤æ‚åº¦ $O(a+b)$ï¼š æœ€å·®æƒ…å†µä¸‹ï¼ˆå³ $âˆ£aâˆ’bâˆ£=1$ï¼Œ $c=0$ ï¼‰ï¼Œæ­¤æ—¶éœ€éå† $a+b$ ä¸ªèŠ‚ç‚¹ã€‚
ç©ºé—´å¤æ‚åº¦ $O(1)$ï¼š èŠ‚ç‚¹æŒ‡é’ˆ A , B ä½¿ç”¨å¸¸æ•°å¤§å°çš„é¢å¤–ç©ºé—´ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *tempA(headA), *tempB(headB);

        while(tempA != tempB)
        {
            if(tempA == nullptr)    tempA = headB;
            else    tempA = tempA->next;

            if(tempB == nullptr)    tempB = headA;
            else    tempB = tempB->next;
        }

        return tempA;
    }
};

// æ›´ç®€æ´ä¸€ç‚¹
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *A = headA, *B = headB;
        while (A != B) {
            A = A != nullptr ? A->next : headB;
            B = B != nullptr ? B->next : headA;
        }
        return A;
    }
};
```

## 2.7 å›æ–‡é“¾è¡¨

[234. å›æ–‡é“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/palindrome-linked-list/)

### 2.7.1 æ ˆ

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        stack<int> s;
        int size(0), i(0);
        ListNode *temp(head);

        while(temp)
        {
            s.push(temp->val);
            temp = temp->next;
            ++size;
        }

        temp = head;
        while(temp)
        {
            if(temp->val != s.top())    return false;
            temp = temp->next;
            s.pop();
            ++i;
            if(i == size / 2)   return true;
        }

        return true;
    }
};
```

### 2.7.2 å¿«æ…¢æŒ‡é’ˆ

ç ´åäº†åŸé“¾è¡¨çš„ç»“æ„ã€‚

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(!head || !head->next)
            return 1;
        ListNode *fast = head, *slow = head;
        ListNode *p, *pre = NULL;
        while(fast && fast->next){
            p = slow;
            slow = slow->next;    //å¿«æ…¢éå†
            fast = fast->next->next;

            p->next = pre;  //ç¿»è½¬
            pre = p;
        }
        if(fast)  //å¥‡æ•°ä¸ªèŠ‚ç‚¹æ—¶è·³è¿‡ä¸­é—´èŠ‚ç‚¹
            slow = slow->next;

        while(p){       //å‰åŠéƒ¨åˆ†å’ŒååŠéƒ¨åˆ†æ¯”è¾ƒ
            if(p->val != slow->val)
                return 0;
            p = p->next;
            slow = slow->next;
        }
        return 1;
    }
};
```

## 2.8 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼ˆ21ï¼‰

[21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/merge-two-sorted-lists/)

### 2.8.1 è¿­ä»£

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode *list = new ListNode(0);
        ListNode *next = list;

        while(list1 && list2)
        {
            if(list1->val <= list2->val)
            {
                next->next = list1;
                list1 = list1->next;
            }
            else
            {
                next->next = list2;
                list2 = list2->next;
            }
            next = next->next;
        }

        // l1 æˆ– l2 å¯èƒ½è¿˜æœ‰å‰©ä½™ç»“ç‚¹æ²¡æœ‰åˆå¹¶ï¼Œ 
        // ç”±äºä»ä¸Šé¢çš„ while å¾ªç¯ä¸­é€€å‡ºï¼Œ é‚£ä¹ˆé“¾è¡¨ l1 å’Œ l2 è‡³å°‘æœ‰ä¸€ä¸ªå·²ç»éå†ç»“æŸ
        if(list1 != nullptr) next->next = list1;
        if(list2 != nullptr) next->next = list2;
        
        return list->next;
    }
};
```

### 2.8.2 é€’å½’

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == NULL) {
            return l2;
        }
        if (l2 == NULL) {
            return l1;
        }
        if (l1->val <= l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
};
```

# 3 æ•°ç»„

## 3.1 æœ€å¤§å­æ•°ç»„å’Œï¼ˆ53ï¼‰

[53. æœ€å¤§å­æ•°ç»„å’Œ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/maximum-subarray/)

### 3.1.1 æš´åŠ›è§£æ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum(INT_MIN);
        int temp(0);

        for(int i = 0; i < nums.size(); ++i)
        {
            for(int j = i; j < nums.size(); ++j)
            {
                temp += nums.at(j);
                sum = sum > temp ? sum : temp;
            }
            temp = 0;
        }

        return sum;
    }
};
```

### 3.1.2 åˆ†æ²»

1. å–æ•°ç»„ä¸­å¿ƒç‚¹ä¸ºä¸­å¿ƒï¼›
2. æœ€å¤§å­åºè¦ä¹ˆå…¨åœ¨ä¸­å¿ƒå·¦è¾¹ï¼Œè¦ä¹ˆåœ¨å³è¾¹ï¼Œè¦ä¹ˆè·¨ä¸­å¿ƒï¼›
3. åˆ†ä¸‰ç§æƒ…å†µè¿›è¡Œè€ƒè™‘ è·¨ä¸­å¿ƒçš„æƒ…å†µï¼Œå†åˆ†æ²»æˆä¸­å¿ƒç‚¹å·¦ä¾§å’Œå³ä¾§çš„æœ€å¤§å­åºå’Œé—®é¢˜ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$O(Nlog(N))$

ç©ºé—´å¤æ‚åº¦ï¼š$O(log(N))$

![image-20230510093433295](figures/image-20230510093433295.png)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        return maxSubArrayHelper(nums, 0, nums.size() - 1);
    }

    int maxSubArrayHelper(vector<int>& nums, int left, int right)
    {
        if(left == right)   return nums[left];

        int center = (left + right) / 2;
        int leftMax = maxSubArrayHelper(nums, left, center);
        int rightMax = maxSubArrayHelper(nums, center + 1, right);

        int leftCrossMax = INT_MIN; // åˆå§‹åŒ–ä¸€ä¸ªå€¼
        int leftCrossSum = 0;
        for (int i = center ; i >= left ; i --) 
        {
            leftCrossSum += nums[i];
            leftCrossMax = max(leftCrossSum, leftCrossMax);
        }

        // è®¡ç®—åŒ…å«å³ä¾§å­åºåˆ—æœ€åä¸€ä¸ªå…ƒç´ çš„å­åºåˆ—æœ€å¤§å€¼
        int rightCrossMax = nums[center + 1];
        int rightCrossSum = 0;
        for (int i = center + 1; i <= right ; i ++) 
        {
            rightCrossSum += nums[i];
            rightCrossMax = max(rightCrossSum, rightCrossMax);
        }
        
        int crossMax = leftCrossMax + rightCrossMax;
        return max(crossMax, max(leftMax, rightMax));
    }
};
```

### 3.1.3 è´ªå¿ƒæ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution
{
public:
    int maxSubArray(vector<int> &nums)
    {
        //ç±»ä¼¼å¯»æ‰¾æœ€å¤§æœ€å°å€¼çš„é¢˜ç›®ï¼Œåˆå§‹å€¼ä¸€å®šè¦å®šä¹‰æˆç†è®ºä¸Šçš„æœ€å°æœ€å¤§å€¼
        int result = INT_MIN;
        int numsSize = int(nums.size());
        int sum = 0;
        for (int i = 0; i < numsSize; i++)
        {
            sum += nums[i];
            result = max(result, sum);
            //å¦‚æœsum < 0ï¼Œé‡æ–°å¼€å§‹æ‰¾å­åºä¸²
            if (sum < 0)
            {
                sum = 0;
            }
        }

        return result;
    }
};
```

### 3.1.4 åŠ¨æ€è§„åˆ’

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution
{
public:
    int maxSubArray(vector<int> &nums)
    {
        //ç±»ä¼¼å¯»æ‰¾æœ€å¤§æœ€å°å€¼çš„é¢˜ç›®ï¼Œåˆå§‹å€¼ä¸€å®šè¦å®šä¹‰æˆç†è®ºä¸Šçš„æœ€å°æœ€å¤§å€¼
        int result = INT_MIN;
        int numsSize = int(nums.size());

        int sum = nums[0];
        result = nums[0];
        for (int i = 1; i < numsSize; i++)
        {
            sum = max(sum + nums[i], nums[i]);
            result = max(result, sum);
        }

        return result;
    }
};
```

## 3.2 åŸåœ°ç§»é™¤å…ƒç´ ï¼ˆ27ï¼‰

[27. ç§»é™¤å…ƒç´  - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/remove-element/)

### 3.2.1 é€šç”¨è§£æ³•ï¼ˆåŒæŒ‡é’ˆï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;

        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] != val)
            {
                nums[slow++] = nums[i];
            }
        }

        return slow;
    }
};
```

### 3.2.2 ä¼˜åŒ–åçš„åŒæŒ‡é’ˆ

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = nums.size();
        while (left < right) {
            if (nums[left] == val) {
                nums[left] = nums[right - 1];
                right--;
            } else {
                left++;
            }
        }
        return left;
    }
};
```

## 3.3 åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ï¼ˆ88ï¼‰

[88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/merge-sorted-array/)

### 3.3.1 STLåº“

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        for(int i = 0; i < n; ++i)  nums1[m + i] = nums2[i];
        sort(nums1.begin(), nums1.begin() + m + n);
    }
};
```

### 3.3.2 ä»åé¢å¼€å§‹ç¡®å®š

æ—¶é—´å¤æ‚åº¦ï¼š$O(M+N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

å¦‚æœä¸¤ä¸ªæ•°ç»„ä»ç»“å°¾å‘å¼€å¤´ï¼ˆæ•°å­—ä»å¤§åˆ°å°ï¼‰è¿›è¡Œæ¯”è¾ƒï¼Œé‚£ä¹ˆæ¯æ¬¡æŠŠæ¯”è¾ƒä¹‹åçš„æ•°å­—æ”¾ç½®åˆ° nums1 ä¸­çš„åé¢ï¼Œç”±äºåé¢çš„æ•°å­—æœ¬èº«å°±æ˜¯æä¾›å‡ºæ¥çš„å¤šä½™çš„ä½ç½®ï¼Œéƒ½æ˜¯ 0ï¼Œå› æ­¤ä¸éœ€è¦å¯¹ nums1 è¿›è¡Œç§»åŠ¨ã€‚

1. å½“ $m > 0$ å¹¶ä¸” $n > 0 $ æ—¶ï¼Œä»åå‘å‰æ¯”è¾ƒ  $num1[mâˆ’1]$ å’Œ  $nums2[nâˆ’1] $ ï¼š
   - å¦‚æœæ˜¯  $nums1[mâˆ’1]$ å¤§ï¼Œåˆ™æŠŠ   $num1[mâˆ’1]$ æ”¾åˆ° $num1$ çš„ç¬¬ $m+nâˆ’1$ ä½ç½®ï¼Œå¹¶è®© $m-=1$ã€‚
   - å¦‚æœæ˜¯ $nums2[nâˆ’1] $ å¤§ï¼Œåˆ™æŠŠ $nums2[nâˆ’1]$ æ”¾åˆ° $num1$ çš„ç¬¬ $m+nâˆ’1$ ä½ç½®ï¼Œå¹¶è®© $n-=1$ã€‚
2. å½“ä¸Šé¢çš„éå†æ¡ä»¶ç»“æŸçš„æ—¶å€™ï¼Œæ­¤æ—¶ m å’Œ n è‡³å°‘æœ‰ä¸€ä¸ªä¸º 0ã€‚
   - å½“ $m == 0$ æ—¶ï¼Œè¯´æ˜ num1 çš„æ•°å­—æ°å¥½ç”¨å®Œäº†ï¼Œæ­¤æ—¶ nums2 å¯èƒ½è¿˜å‰©å…ƒç´ ï¼Œéœ€è¦å¤åˆ¶åˆ° nums1 çš„å¤´éƒ¨ï¼›
   - å½“ $n == 0$ æ—¶ï¼Œè¯´æ˜ num2 çš„æ•°å­—æ°å¥½ç”¨å®Œäº†ï¼Œæ­¤æ—¶ nums1 å¯èƒ½è¿˜å‰©å…ƒç´ ï¼Œç”±äºå‰©ä½™çš„è¿™äº›å…ƒç´ ä¸€å®šæ˜¯ nums1 å’Œ nums2 ä¸­æœ€å°çš„å…ƒç´ ï¼Œæ‰€ä»¥ä¸ç”¨åŠ¨ï¼Œç›´æ¥ç•™åœ¨åŸåœ°å°±è¡Œã€‚

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int k = m + n - 1;
        while (m > 0 && n > 0) {
            if (nums1[m - 1] > nums2[n - 1]) {
                nums1[k] = nums1[m - 1];
                m --;
            } else {
                nums1[k] = nums2[n - 1];
                n --;
            }
            k --;
        }
        for (int i = 0; i < n; ++i) {
            nums1[i] = nums2[i];
        }
    }
};
```

### 3.3.3 ä»å‰é¢å¼€å§‹ç¡®å®šï¼ˆå½’å¹¶æ’åºï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(M+N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(M+N)$

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {   
        vector<int> temp(nums1);       //åˆå§‹åŒ–mä¸ºnums1çš„æ‹·è´
        int i = 0, j = 0, k = 0;

        while(i <= m-1 && j <= n-1)
        {
            if(temp[i] < nums2[j])                nums1[k++] = temp[i++];
            else               nums1[k++] = nums2[j++];
        }
        while(i <= m-1)         
        {
            nums1[n+i] = temp[i];
            i++;
        }
         while(j <= n-1)
        {
            nums1[m+j] = nums2[j];
            j++;
        }

    }
};
```

## 3.4 æŸ¥æ‰¾å…±ç”¨å­—ç¬¦ï¼ˆ1002ï¼‰

[1002. æŸ¥æ‰¾å…±ç”¨å­—ç¬¦ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/find-common-characters/)

### 3.4.1 åˆ©ç”¨æ•°ç»„æ±‚è§£

```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& A) {
        vector<string> out;
        int num[100][26]={0};                  //å»ºç«‹ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œæ ‡è®°æ‰€æœ‰å‡ºç°çš„å­—æ¯æ¬¡æ•°
        for(int i =0;i<A.size() ;i++)
            for(int j=0;j<A[i].size();j++)
                num[i][(A[i][j]-'a')]++;
        
        for(int j=0;j<26;j++)                  //å°†æ‰€æœ‰åˆ—çš„æœ€å°å€¼å­˜åˆ°ç¬¬ä¸€è¡Œ
            for(int i=1;i<A.size();i++)
                num[0][j] = min (num[0][j],num[i][j]);
                    
        string str;                           //æŒ‰ç…§ç¬¬ä¸€è¡Œä¿å­˜çš„æ¬¡æ•°è¾“å‡ºç›¸åº”å­—æ¯
        for(int i=0;i<26;i++){
            while(num[0][i]--)
            {
                str.clear();
                str.push_back((char)('a'+i));
                out.push_back(str);
            }
        }
        return out;
    }
};

```

### 3.4.2 å“ˆå¸Œ

```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& A) {
        vector<string> res;
        vector<unordered_map<char,int>> vum(A.size());
        for(int i = 0;i < A.size();++i)
            for(char c : A[i])
                vum[i][c]++;        // å¯¹åº”keyçš„value++
 
        for(pair<char, int> pair : vum[0])     // å°†æ‰€æœ‰keyçš„valueçš„æœ€å°å€¼é€‰æ‹©å‡ºæ¥æ”¾åœ¨ç¬¬ä¸€ä¸ªå‘é‡ä¸­
        {
            int n = pair.second;
            for(int i = 1;i < vum.size();++i)
                n = min(n,vum[i][pair.first]);
            while(n--) res.push_back(string(1, pair.first));       
        }
        return res;
    }
};
```

## 3.5 å¯»æ‰¾æ•°ç»„çš„ä¸­å¿ƒä¸‹æ ‡ï¼ˆå¯»æ‰¾æ•°ç»„çš„ä¸­å¿ƒä¸‹æ ‡ï¼‰

[724. å¯»æ‰¾æ•°ç»„çš„ä¸­å¿ƒä¸‹æ ‡ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/find-pivot-index/)

### 3.5.1 æš´åŠ›è§£æ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int middle_index(-1);
        int temp_index(0);

        while(temp_index < nums.size())
        {
            int left_sum(0), right_sum(0);
            for(int i = 0; i < temp_index; ++i)
                left_sum += nums.at(i);
            
            for(int i = temp_index + 1; i < nums.size(); ++i)
                right_sum += nums.at(i);

            if(left_sum == right_sum)   
            {
                middle_index = temp_index;
                return middle_index;
            }

            cout << "left_sum: " << left_sum << endl;
            cout << "right_sum: " << right_sum << endl;

            ++temp_index;
        }

        return middle_index;
    }
};
```

### 3.5.2 è½¬æ¢æ€æƒ³çš„ç®€å•æ€è·¯ï¼ˆå‰ç¼€å’Œï¼Œç±»ä¼¼æ»‘åŠ¨çª—å£ï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sumleft = 0, sumTotal = 0;
        for(int n : nums)   
            sumTotal += n;
        for(int i = 0; i < nums.size(); ++i)
        {
            if(sumleft * 2  == sumTotal - nums[i])  
                return i;       //å¦‚æœiæ­¤æ—¶æ»¡è¶³ä¸­å¿ƒç´¢å¼•è¦æ±‚ï¼Œreturn
            sumleft += nums[i];
        }
        return -1;
    }
};

// å¦ä¸€ç§è§£æ³•ï¼ŒåŸç†ä¸Šæ˜¯ä¸€æ ·çš„
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sumLeft = 0, sumRight = accumulate(nums.begin(), nums.end(), 0);
        for (int i = 0; i < nums.size(); i++) {
            sumRight -= nums[i];
            // è‹¥å·¦ä¾§å…ƒç´ å’Œç­‰äºå³ä¾§å…ƒç´ å’Œï¼Œè¿”å›ä¸­å¿ƒä¸‹æ ‡ i
            if (sumLeft == sumRight)
                return i;
            sumLeft += nums[i];
        }
        return -1;
    }
};
```

## 3.6 æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•°

[å‰‘æŒ‡ Offer 56 - I. æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

### <span style="background:#FFFFBB;">3.6.1 ä½è¿ç®—</span>

**å‚è€ƒé¢˜è§£ï¼š**[å‰‘æŒ‡ Offer 56 - I. æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solutions/572857/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom/)

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

1. **éå†æ‰§è¡Œå¼‚æˆ–ï¼š**

   - è®¾æ•´å‹æ•°ç»„ $nums = [a,a,b,b,...,x,y]$ ï¼Œå¯¹ $nums$ ä¸­æ‰€æœ‰æ•°å­—æ‰§è¡Œå¼‚æˆ–ï¼Œå¾—åˆ°çš„ç»“æœä¸º $xâŠ•y$

2. **å¾ªç¯å·¦ç§»è®¡ç®— $m$** ï¼š

   - æ ¹æ®å¼‚æˆ–è¿ç®—å®šä¹‰ï¼Œè‹¥æ•´æ•° $xâŠ•y$ æŸäºŒè¿›åˆ¶ä½ä¸º $1$ ï¼Œåˆ™ $x$ å’Œ $y$ çš„æ­¤äºŒè¿›åˆ¶ä½ä¸€å®šä¸åŒã€‚æ¢è¨€ä¹‹ï¼Œæ‰¾åˆ° $xâŠ•y$ æŸä½ä¸º $1$ çš„äºŒè¿›åˆ¶ä½ï¼Œå³å¯å°†æ•°ç»„ $nums$ æ‹†åˆ†ä¸ºä¸Šè¿°çš„ä¸¤ä¸ªå­æ•°ç»„ã€‚æ ¹æ®ä¸è¿ç®—ç‰¹ç‚¹ï¼Œå¯çŸ¥å¯¹äºä»»æ„æ•´æ•° $a$ æœ‰ï¼š
     - è‹¥ $a \& 0001=1$ï¼Œåˆ™  $a$ çš„ç¬¬ä¸€ä½ä¸º $1$  ï¼›
     - è‹¥ $a \& 0010=1$ï¼Œåˆ™ $a$ çš„ç¬¬äºŒä½ä¸º $1$ ï¼›
     - ä»¥æ­¤ç±»æ¨â€¦â€¦
   - å› æ­¤ï¼Œåˆå§‹åŒ–ä¸€ä¸ªè¾…åŠ©å˜é‡ $m=1$ï¼Œé€šè¿‡ä¸è¿ç®—ä»å³å‘å·¦å¾ªç¯åˆ¤æ–­ï¼Œå¯ è·å–æ•´æ•° $xâŠ•y$é¦–ä½ $1$  ï¼Œè®°å½•äº $m$ ä¸­ï¼Œä»£ç å¦‚ä¸‹ï¼š

   ```c++
   while(n & m == 0) // m å¾ªç¯å·¦ç§»ä¸€ä½ï¼Œç›´åˆ° z & m ï¼= 0
       m <<= 1
   ```

3. **æ‹†åˆ† $nums$ ä¸ºä¸¤ä¸ªå­æ•°ç»„ï¼›**

4. åˆ†åˆ«éå†ä¸¤ä¸ªå­æ•°ç»„æ‰§è¡Œå¼‚æˆ–ï¼š

   - é€šè¿‡éå†åˆ¤æ–­ $nums$ ä¸­å„æ•°å­—å’Œ $m$ åšä¸è¿ç®—çš„ç»“æœï¼Œå¯å°†æ•°ç»„æ‹†åˆ†ä¸ºä¸¤ä¸ªå­æ•°ç»„ï¼Œå¹¶åˆ†åˆ«å¯¹ä¸¤ä¸ªå­æ•°ç»„éå†æ±‚å¼‚æˆ–ï¼Œåˆ™å¯å¾—åˆ°ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ï¼Œä»£ç å¦‚ä¸‹ï¼š

   ```c++
   for(int num : nums) {
       if(num & m) x ^= num;   // è‹¥ num & m != 0 , åˆ’åˆ†è‡³å­æ•°ç»„ 1 ï¼Œæ‰§è¡Œéå†å¼‚æˆ–
       else y ^= num;          // è‹¥ num & m == 0 , åˆ’åˆ†è‡³å­æ•°ç»„ 2 ï¼Œæ‰§è¡Œéå†å¼‚æˆ–
   }
   return vector<int> {x, y};  // éå†å¼‚æˆ–å®Œæ¯•ï¼Œè¿”å›åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— x å’Œ y
   ```

5. **è¿”å›å€¼**ï¼šè¿”å›åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— $x, y$ å³å¯ã€‚



```c++
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int x = 0, y = 0, n = 0, mask(0);
        for(int num : nums)             // 1. éå†å¼‚æˆ–
            n ^= num;         
        mask = n ^ (-n);                // 2. è·å–maskï¼ŒåŒºåˆ†åˆ†åˆ«åŒ…å«xå’Œyçš„å­æ•°ç»„
        for(int num : nums) {           // 3. éå† nums åˆ†ç»„
            if(num & mask) x ^= num;    // 4. å½“ num & mask != 0
            else y ^= num;              // 5. å½“ num & mask == 0
        }
        return vector<int> {x, y};      // 6. è¿”å›å‡ºç°ä¸€æ¬¡çš„æ•°å­—
    }
};

```



## 3.7 æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•° II  

[å‰‘æŒ‡ Offer 56 - II. æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•° II - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

### 3.7.1 å“ˆå¸Œ

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int, int> hash;
        for(int i = 0; i < nums.size(); ++i)    ++hash[nums[i]];

        for(auto temp : hash)   if(temp.second == 1)   return temp.first;
        return 0;   // ç»“æœå¿…ç„¶ä¸ä¼šèµ°åˆ°è¿™ä¸€æ­¥
    }
};
```

### 3.7.2 ä½è¿ç®—

> ğŸ« ğŸ« ğŸ« ğŸ« ğŸ« ğŸ« ğŸ« ï¼Œè¿™åˆ°åº•æ˜¯æ€ä¹ˆç”¨çš„ä½è¿ç®—ï¼Ÿä»€ä¹ˆè„‘å­èƒ½æƒ³åˆ°å•Šï¼Ÿè€Œä¸”æ•ˆç‡è¿˜çœŸçš„nmçš„é«˜ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for(int i = 0; i < 32; ++i){
            int cnt = 0;
            for(int n : nums){
                // n & 1 << i çš„å€¼å¤§äº0å³ä¸ºçœŸ
                if(n & (1 << i)) cnt++;
            }
            // æ„é€ åªå‡ºç°ä¸€æ¬¡çš„é‚£ä¸ªæ•°å­—ï¼Œé‡‡ç”¨å¼‚æˆ–çš„æ–¹æ³•ç”ŸæˆäºŒè¿›åˆ¶ä¸­çš„æ¯ä¸€ä½
            if(cnt % 3 == 1) ans ^= (1 << i);
        }
        return ans;
    }
};
```

## 3.8 å‰‘æŒ‡ Offer 53 - II. 0ï½n-1ä¸­ç¼ºå¤±çš„æ•°å­—

[å‰‘æŒ‡ Offer 53 - II. 0ï½n-1ä¸­ç¼ºå¤±çš„æ•°å­— - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)

### 3.8.1 äºŒåˆ†æ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(logN)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int left = 0, right = nums.size();
        while(left < right){
            int mid = (left + right) / 2;
            if(mid == nums[mid]) left = mid + 1;
            else right = mid;
        }
        return left;
    }
};
```

### 3.8.2 é—®é¢˜è½¬æ¢æ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int sum = 0;
        for(int i = 0; i < n; i ++)
            sum += nums[i];
        return n*(n + 1)/2 - sum;
    }
};
```

### 3.8.3 å“ˆå¸Œæ•°ç»„

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int hash[50000]{0};
        for(int i = 0; i < nums.size(); ++i)
        {
            ++hash[nums[i]];
        }
        for(int i = 0; i < nums.size(); ++i)
        {
            if(hash[i] == 0)
            {
                return i;
            }
        }

        return nums.size();
    }
};
```

## 3.9 æŒ‰å¥‡å¶æ’åºæ•°ç»„

[905. æŒ‰å¥‡å¶æ’åºæ•°ç»„ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/sort-array-by-parity/)

### 3.9.1 æš´åŠ›è§£æ³•

```c++
class Solution {
public:
    vector<int> sortArrayByParity(vector<int>& nums) {
        vector<int> fore_res, back_res;
        for(int i = 0; i < nums.size(); ++i)
        {
            if(nums[i] % 2 == 0)    fore_res.emplace_back(nums[i]);
            else    back_res.emplace_back(nums[i]);
        }

        for(int i = 0; i < back_res.size(); ++i)
        {
            fore_res.emplace_back(back_res[i]);
        }

        return fore_res;
    }
};
```

### 3.9.2 å·¦å³æŒ‡é’ˆ

```c++
class Solution {
public:
    vector<int> sortArrayByParity(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;

        while(left != right)
        {
            if(nums[left] % 2 != 0)
            {
                swap(nums[left], nums[right]);
                --right;
            }
            else    ++left;
        }

        return nums;
    }
};
```

## 3.10 å­˜åœ¨é‡å¤å…ƒç´  II

[219. å­˜åœ¨é‡å¤å…ƒç´  II - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/contains-duplicate-ii/)

### 3.10.1 å“ˆå¸Œè¡¨

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$

```c++
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> map;
        int length = nums.size();
        for (int i = 0; i < length; i++) {
            int num = nums[i];
            if (map.count(num) && i - map[num] <= k) {
                return true;
            }
            map[num] = i;
        }
        return false;
    }
};
```

### 3.10.2 æ»‘åŠ¨çª—å£

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(k)$

```c++
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_set<int> s;
        int length = nums.size();
        for (int i = 0; i < length; i++) {
            if (i > k) {
                s.erase(nums[i - k - 1]);   // å°†è¯¥å…ƒç´ ä»æ»‘åŠ¨çª—å£ç§»é™¤ï¼Œä»¥ä¿è¯æ»‘åŠ¨çª—å£æ’å®šå¤§å°
            }
            if (s.count(nums[i])) {         
                return true;
            }
            s.insert(nums[i]);
        }
        return false;
    }
};
```

## 3.11 æœ‰åºæ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡25%çš„å…ƒç´ ï¼ˆ1287ï¼‰

[1287. æœ‰åºæ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡25%çš„å…ƒç´  - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/)

### 3.11.1 å“ˆå¸Œè¡¨

```c++
class Solution {
public:
    int findSpecialInteger(vector<int>& arr) {
        int size = arr.size();
        unordered_map<int, int> hash;
        for(int i = 0; i < size; ++i)
        {
            ++hash[arr[i]];
        }

        auto iter = hash.begin();
        while(iter != hash.end())
        {
            printf("iter%d: %d\r\n", iter->first, iter->second);
            if(iter->second * 100 > size * 25)  return iter->first;
            ++iter;
        }

        return -1;
    }
};
```

### 3.11.2 å¿«æ…¢æŒ‡é’ˆ

```c++
class Solution {
public:
    int findSpecialInteger(vector<int>& arr) {
        // æœ‰åºæ•°ç»„ï¼Œæ— éœ€sort
        int slow(0), fast(0), size(arr.size());
        while(fast < size)
        {
            if(arr[fast] == arr[slow])
            {
                ++fast;
                if(fast == size)    return arr[slow];       // ä¸€å®šå­˜åœ¨å¯¹åº”æ•´æ•°ï¼Œåˆ°å°¾éƒ¨åˆ™è¿”å›æœ€åçš„å…ƒç´ 
                continue;
            }

            if((fast - slow) * 100 > size * 25)    return arr[slow];
            slow = fast;
        }

        return -1;
    }
};
```

### 3.11.3 é—®é¢˜è½¬æ¢

> æ€è·¯ç‰›é€¼ï¼šğŸ˜°ğŸ˜°ğŸ˜°ğŸ˜°ğŸ˜°

1. æ•°ç»„æœ‰åºï¼Œä¸”æŸå…ƒç´ å‡ºç°æ¬¡æ•°è¶…è¿‡25%
2. é‚£ä¹ˆå¯¹äºæ­¤å…ƒç´ ç¬¬1æ¬¡å‡ºç°ä½ç½®ï¼ŒåŠ 25%æ•°ç»„é•¿åº¦ï¼Œå¿…å®šä»ä¸ºå®ƒè‡ªèº«

```c++
class Solution {
public:
    int findSpecialInteger(vector<int>& arr) {
        for(int i = 0; i < arr.size(); ++i)
        {
            if(i + arr.size() / 4 < arr.size())
                if(arr[i] == arr[i + arr.size() / 4])   return arr[i];
        }

        return 0;  
    }
};
```

## 3.12 æœ‰æ•ˆçš„å±±è„‰æ•°ç»„ï¼ˆ941ï¼‰

[941. æœ‰æ•ˆçš„å±±è„‰æ•°ç»„ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/valid-mountain-array/)

### 3.12.1 çº¿æ€§æ‰«æï¼ˆåŒæŒ‡é’ˆï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        if(arr.size() < 3) return false;
        int slow(0), fast(0);

        for(fast = 0; fast < arr.size() - 1; ++fast)
        {
            if(slow == 0)
            {
                if(arr[fast] < arr[fast + 1])   continue;
                if(arr[fast] > arr[fast + 1])
                {
                    if(fast == 0)   return false;
                    slow = fast;
                    continue;
                }
               
                return false;
            }

            if(slow > 0)
            {
                if(arr[fast] > arr[fast + 1])   continue;
                return false;
            }
        }

        if(slow == 0)  return false;
        return true;
    }
};

// æ¢ä¸€ç§æ›´ç®€æ´çš„å†™æ³•
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        int head(0), tail(arr.size() - 1);

        if(arr.size() < 3)  return false;
        for(; head < arr.size() - 1; ++head)
            if(arr[head] >= arr[head + 1])   break;
        for(; tail > 1; --tail)
            if(arr[tail] >= arr[tail - 1])  break;
        
        if(head == tail and head != 0 and tail != arr.size() - 1)    return true;
        return false;
    }
};
```

## 3.13 æœ€é•¿è¿ç»­é€’å¢åºåˆ—

[674. æœ€é•¿è¿ç»­é€’å¢åºåˆ— - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

### 3.13.1 åŒæŒ‡é’ˆï¼ˆå¿«æ…¢æŒ‡é’ˆã€å°ºå–æ³•ã€è´ªå¿ƒï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int slow(0), fast(0), size(nums.size()), max_size(1);
        
        while(fast < size - 1)
        {                
            if(nums[fast] < nums[fast + 1])
            {
                ++fast;
                max_size = max(max_size, fast - slow + 1);
                continue;
            }
            ++fast;
            slow = fast;
        }

        return max_size;
    }
};

// æ›´ç®€æ´çš„å†™æ³•
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int slow(0), fast(0), size(nums.size()), max_size(1);
        
        while(fast != size)
        {                
            while(fast != size - 1 and nums[fast] < nums[fast + 1])  ++fast;
            max_size = max(max_size, fast - slow + 1);
            slow = ++fast;
        }

        return max_size;
    }
};
```

### 3.13.2 åŠ¨æ€è§„åˆ’

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        int result = 1;
        vector<int> dp(nums.size() ,1);
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i + 1] > nums[i]) { // è¿ç»­è®°å½•
                dp[i + 1] = dp[i] + 1;
            }
            if (dp[i + 1] > result) result = dp[i + 1];
        }
        return result;
    }
};
```

# 4 å­—ç¬¦ä¸²

## 4.1 æœ‰æ•ˆçš„æ‹¬å·ï¼ˆ20ï¼‰

[20. æœ‰æ•ˆçš„æ‹¬å· - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/valid-parentheses/)

### 4.1.1 å“ˆå¸Œä¸æ ˆ

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$

```c++
class Solution {
public:
    bool isValid(string s) {
        unordered_map<char,int> m{{'(',1},{'[',2},{'{',3},
                                {')',4},{']',5},{'}',6}};
        stack<char> st;
        bool istrue=true;
        for(char c:s){
            int flag=m[c];
            if(flag>=1&&flag<=3) st.push(c);
            else if(!st.empty()&&m[st.top()]==flag-3) st.pop();
            else {istrue=false;break;}
        }
        if(!st.empty()) istrue=false;
        return istrue;
    }
};

// å¦ä¸€ç§å†™æ³•
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        unordered_map<char, char>   hash{{'(', ')'}, {'[', ']'}, {'{', '}'}};
        for(int i(0); i < s.size(); ++i)
        {
            if(s[i] == '(' or s[i] == '[' or s[i] == '{')   st.push(s[i]);
            else if(!st.empty())
            {
                if(hash[st.top()] != s[i])  return false;
                st.pop();
            }
            else    return false;
        }
        if(!st.empty()) return false;
        return true;
    }
};
```

## 4.2 å­—ç¬¦ä¸²ç›¸åŠ ï¼ˆ415ï¼‰

[415. å­—ç¬¦ä¸²ç›¸åŠ  - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/add-strings/)

### 4.2.1 æ¨¡æ‹Ÿ

æ—¶é—´å¤æ‚åº¦ï¼š$O(MAX(M, N))$

ç©ºé—´å¤æ‚åº¦ï¼š$O(MAX(M, N))$

```c++
class Solution {
public:
    string addStrings(string num1, string num2) {
        int size1(num1.size() - 1), size2(num2.size() - 1);
        int carry(0);
        string res;

        while(size1 >= 0 or size2 >= 0)
        {
            int x = size1 >= 0 ? num1[size1] - '0' : 0;
            int y = size2 >= 0 ? num2[size2] - '0' : 0;
            int  temp = x + y + carry;

            res.push_back('0' + temp % 10);
            carry = temp / 10;
            --size1;
            --size2;
        }
        if(carry)   res.push_back('1');
        reverse(res.begin(), res.end());

        return res;
    }
};
```

## 4.3 äºŒè¿›åˆ¶æ±‚å’Œï¼ˆ67ï¼‰

[67. äºŒè¿›åˆ¶æ±‚å’Œ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/add-binary/)

### 4.3.1 æ¨¡æ‹Ÿ

```c++
class Solution {
public:
    string addBinary(string a, string b) {
        int size_a(a.size() - 1), size_b(b.size() - 1);
        int carry(0);
        string res;

        while(size_a >= 0 or size_b >= 0)
        {
            int temp_a = size_a >= 0 ? a[size_a] - '0' : 0;
            int temp_b = size_b >= 0 ? b[size_b] - '0' : 0;
            int temp = temp_a + temp_b + carry;
            if(temp >= 2)
            {
                temp = temp - 2;
                carry = 1;
            }
            else    carry = 0;

            res.push_back(temp + '0');
            --size_a, --size_b;
        }
        if(carry)   res.push_back('1');
        reverse(res.begin(), res.end());
        return res;
    }
};
```

## 4.4 åè½¬å­—ç¬¦ä¸²ï¼ˆ344ï¼‰

[344. åè½¬å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/reverse-string/)

### 4.4.1 æš´åŠ›è§£æ³•ï¼ˆåŒæŒ‡é’ˆï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        for(int i = 0; i < s.size() / 2; ++i)
            swap(s[i], s[s.size() - i - 1]);
    }
};

// åŒæŒ‡é’ˆ
class Solution {
public:
    void reverseString(vector<char>& s) {
        int n = s.size();
        for (int left = 0, right = n - 1; left < right; ++left, --right) {
            swap(s[left], s[right]);
        }
    }
};
```

### 4.4.2 å¼‚æˆ–ï¼ˆå¯å‚è€ƒçš„å†™æ³•ï¼Œä¸ä½¿ç”¨STLåº“ï¼‰

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        for(int l = 0, r = s.size() - 1; l < r; ++l, --r)
        {
            s[l] ^= s[r];		//æ„é€  a ^ b çš„ç»“æœï¼Œå¹¶æ”¾åœ¨ a ä¸­
        	s[r] ^= s[l];		//å°† a ^ b è¿™ä¸€ç»“æœå† ^ b ï¼Œå­˜å…¥bä¸­ï¼Œæ­¤æ—¶ b = a, a = a ^ b
        	s[l] ^= s[r];		//a ^ b çš„ç»“æœå† ^ a ï¼Œå­˜å…¥ a ä¸­ï¼Œæ­¤æ—¶ b = a, a = b å®Œæˆäº¤æ¢
        }
    }
};
```

## 4.5 åè½¬å­—ç¬¦ä¸² IIï¼ˆ541ï¼‰

[541. åè½¬å­—ç¬¦ä¸² II - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/reverse-string-ii/)

### 4.5.1 æ¨¡æ‹Ÿ

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        int n = s.length();
        for (int i = 0; i < n; i += 2 * k) {
            reverse(s.begin() + i, s.begin() + min(i + k, n));
        }
        return s;
    }
};
```

## 4.6 åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯ IIIï¼ˆ557ï¼‰

[557. åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯ III - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)

### 4.6.1 å¿«æ…¢æŒ‡é’ˆ

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    string reverseWords(string s) {
        auto slow(s.begin());
        auto fast = s.begin();

        while(fast <= s.end())
        {
            if(*fast == ' ' || fast == s.end())
            {
                reverse(slow, fast);
                slow = fast + 1;
            }
            ++fast;
        }

        return s;
    }
};
```

### 4.6.2 ä½¿ç”¨é¢å¤–ç©ºé—´

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$

```c++
class Solution {
public:
    string reverseWords(string s) {
        string ret;
        int length = s.length();
        int i = 0;
        while (i < length) {
            int start = i;
            while (i < length && s[i] != ' ') {
                i++;
            }
            for (int p = start; p < i; p++) {
                ret.push_back(s[start + i - 1 - p]);
            }
            while (i < length && s[i] == ' ') {
                i++;
                ret.push_back(' ');
            }
        }
        return ret;
    }
};
```

## 4.7 åè½¬å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—æ¯ï¼ˆ345ï¼‰

[345. åè½¬å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—æ¯ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/reverse-vowels-of-a-string/)

### 4.7.1 å·¦å³æŒ‡é’ˆ

```c++
class Solution {
    unordered_set<char> set{'a', 'e', 'i', 'o', 'u',
                            'A', 'E', 'I', 'O', 'U'};
public:
    string reverseVowels(string s) {
        int left(0), right(s.size() - 1);

        while(left < right)
        {
            if(set.count(s[left]) and set.count(s[right]))  
            {
                swap(s[left], s[right]);
                ++left;
                --right;
            }
                
            if(set.count(s[left]) == 0)     ++left;
            if(set.count(s[right]) == 0)    --right;
        }

        return s;
    }
};
```

## 4.8 éªŒè¯å›æ–‡ä¸²ï¼ˆ125ï¼‰

[125. éªŒè¯å›æ–‡ä¸² - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/valid-palindrome/)

### 4.8.1 åŒæŒ‡é’ˆ

```c++
class Solution {
public:
    bool isPalindrome(string s) {
        int slow(0), fast(0);
        for(; fast < s.size(); ++fast)          // å¿«æ…¢æŒ‡é’ˆé™¤å»éå­—æ¯ç¬¦å·
        {
            if((s[fast] <= 'z' and s[fast] >= 'a') or 
                (s[fast] <= 'Z' and s[fast] >= 'A'))
            {
                s[slow++] = tolower(s[fast]);
            }
            if((s[fast] <= '9' and s[fast] >= '0'))
            {
                s[slow++] = s[fast];
            }
        }

        int left(0), right(slow - 1);
        while(left < right)
        {
            if(s[left++] != s[right--]) return false;
        }
        return true;
    }
};

// è¿›ä¸€æ­¥ä¼˜åŒ–
class Solution {
public:
    bool isPalindrome(string s) {
        int slow(0), fast(0);
        for(; fast < s.size(); ++fast)          // å¿«æ…¢æŒ‡é’ˆé™¤å»éå­—æ¯æ•°å­—ç¬¦å·
        {
            if(islower(s[fast]) or isupper(s[fast]) or isdigit(s[fast]))
            {
                s[slow++] = tolower(s[fast]);	// å¯¹äºæ•°å­—ï¼Œtolowerä¼šç›´æ¥è¿”å›å¯¹åº”æ•°å­—
            }
        }

        int left(0), right(slow - 1);
        while(left < right)
        {
            if(s[left++] != s[right--]) return false;
        }
        return true;
    }
};

// æ›´è¿›ä¸€æ­¥
class Solution {
public:
    bool isPalindrome(string s) {
        int slow(0), fast(0);
        for(; fast < s.size(); ++fast)          // å¿«æ…¢æŒ‡é’ˆé™¤å»éå­—æ¯æ•°å­—ç¬¦å·
        {
            if(isalnum(s[fast]))				// åˆ¤æ–­æ˜¯å¦æ˜¯å­—æ¯æˆ–æ•°å­—
            {
                s[slow++] = tolower(s[fast]); 	// å¯¹äºæ•°å­—ï¼Œtolowerä¼šç›´æ¥è¿”å›å¯¹åº”æ•°å­—
            }
        }

        int left(0), right(slow - 1);
        while(left < right)
        {
            if(s[left++] != s[right--]) return false;
        }
        return true;
    }
};
```

## 4.9 éªŒè¯å›æ–‡ä¸² IIï¼ˆ680ï¼‰

[680. éªŒè¯å›æ–‡ä¸² II - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/valid-palindrome-ii/)

### 4.9.1 åŠ¨æ€è§„åˆ’

```c++
// æä½æ•ˆç‡
class Solution {
public:
    bool validPalindrome(string s) {
        int left(0), right(s.size() - 1);
        int flag_l(0), flag_r(0);
        string temp;

        while(left < right)
        {
            if(s[left] != s[right])
            {
                if(left + 1 == right)   return true;
                else if(s[left + 1] == s[right] and s[left] == s[right - 1])
                {
                    flag_r = 1, flag_l = 1;
                    break;
                }
                else if(s[left + 1] == s[right])    
                {   
                    flag_l = 1;
                    break;
                }
                else if(s[left] == s[right - 1])    
                {
                    flag_r = 1;
                    break;
                }
                else    return false;
            }

            --right, ++left;
        }

        if(left >= right)  return true;  

        cout << "r: " << right << endl;
        cout << "l: " << left << endl;
        cout << "flagl: " << flag_l << endl;
        cout << "flagR: " << flag_r << endl;

        if(flag_l)
        {
            for(int i = 0; i < s.size(); ++i) 
                if(i != left)  temp.push_back(s[i]);
            
            int l = 0, r = temp.size() - 1;
            while(l < r)
            {
                if(temp[l] != temp[r]) break;
                ++l, --r;
            }

            if(l >= r)  return true;  
        }

        temp.clear();
        if(flag_r)
        {
            for(int i = 0; i < s.size(); ++i) 
                if(i != right)  temp.push_back(s[i]);
            
            int l = 0, r = temp.size() - 1;
            while(l < r)
            {
                if(temp[l] != temp[r]) break;
                ++l, --r;
            }

            if(l >= r)  return true;  
        }

        return false;
    }
};

// å‚è€ƒåˆ«äººçš„é¢˜è§£
class Solution {
public:
    bool check(string& ss, int left, int right){
        if (left >= right) return true;
        while (left < right){
            if (ss[left] != ss[right]) return false;
            ++ left, -- right;
        }
        return true;
    }

    bool validPalindrome(string s) {
        int l(0), r(s.size() - 1); 
        
        while (l < r){
            if (s[l] != s[r]){
                return check(s, l, r - 1) || check(s, l + 1, r);		// è¿™ä¸ªå¤„ç†å¾ˆå¦™å•Š
            }
            ++ l, -- r;
        }

        return true;
    }
};
```

## 4.10 æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åºï¼ˆ451ï¼‰

[451. æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/sort-characters-by-frequency/)

### 4.10.1 ä½¿ç”¨Vector+è‡ªå®šä¹‰æ’åº

```c++
// bool mysort(const pair<char, int> &p1, const pair<char, int> &p2)
// {
//     return p1.second > p2.second;
// }

class Solution {
public:
    static bool mysort(const pair<char, int> &p1, const pair<char, int> &p2)		
    {
        return p1.second > p2.second;
    }

    string frequencySort(string s) {
        unordered_map<char, int> map;
        for (const auto &c : s) {
            ++map[c];
        }
        vector<pair<char, int>> vec;
        for (const auto &m : map) {
            vec.push_back(m);
        }
        
        sort(vec.begin(), vec.end(), mysort);
        string ret;
        for (const auto &v : vec) {
            ret += string(v.second, v.first);
        }
        return ret;
    }
};
```

### 4.10.2 ä¼˜å…ˆé˜Ÿåˆ—

```c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> map;
        for (const auto &c : s) {
            ++map[c];
        }
        priority_queue<pair<int, char>> pq;     // é»˜è®¤æŒ‰ç¬¬ä¸€ä¸ªå…ƒç´ è‡ªåŠ¨æ’åºï¼Œä»å¤§åˆ°å°
        for (const auto &m : map) {
            pq.push({m.second, m.first});
        }        
        string ret;
        while (!pq.empty()) {
            auto t = pq.top(); 
            pq.pop();
            ret.append(t.first, t.second);
        }
        return ret;
    }
};
```

### <span style="background:#FF9999;">4.10.3 åˆ©ç”¨lambdaè‡ªå®šä¹‰æ’åº</span>

![image-20230512113334746](figures/image-20230512113334746.png)

```c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> map;
        for (const auto &c : s) {
            ++map[c];
        }
        sort(s.begin(), s.end(), [&map](char &a, char &b)		// æ­¤å¤„åªèƒ½ç”¨lambdaçš„å½¢å¼å†™ 
             						{ return map[a] > map[b] || (map[a] == map[b] && a < b); });
        return s;
    }
};
```

### <span style="background:#FF9999;">4.10.4 æ•°ç»„ä¸‹æ ‡ç´¢å¼•</span>

> ğŸ«¥æŠ€ä¸å¦‚äººï¼Œç”˜æ‹œä¸‹é£

```c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> map;
        for (const auto &c : s) {
            ++map[c];
        }
        vector<string> vec(s.size() + 1);
        string res;
        for (const auto &m : map) {
            vec[m.second].append(m.second, m.first);    // m.secondä¸ªm.first
        }
        for (int i = s.size(); i > 0; --i) {
            if (!vec[i].empty()) {
                res.append(vec[i]);
            }
        }
        return res;
    }
};
```

### 4.10.5 å“ˆå¸Œè¡¨

æŒ‰ç†è¯´ï¼Œæˆ‘è§‰å¾—è¿™ä¸ªæ•ˆç‡åº”è¯¥è›®ä½çš„ï¼Œä½†å®é™…è¿˜è›®é«˜ã€‚

![image-20230512113138551](figures/image-20230512113138551.png)

æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$

æŒ‰ç†è¯´ï¼Œsortçš„æ•ˆç‡åº”è¯¥æ¯”è¿™ä¸ªé«˜ï¼Œç–‘æƒ‘ç–‘æƒ‘ã€‚

```c++
class Solution {
public:
    string frequencySort(string s) {
        int hash[128] = {0};
        
        if(s.size() <= 2)   return s;
        for(int i = 0; i < s.size(); ++i)   ++hash[s[i]];

        vector<pair<char, int>> p;   
        while(1)
        {
            int flag = 0;
            int max_size = 0;
            char max_ch = 0;
            for(int i = 0; i < 128; ++i)
            {
                if(hash[i]) flag = 1;
                if(max_size < hash[i])
                {
                    max_ch = i;
                    max_size = hash[i];
                }
            }

            if(flag == 1)   hash[max_ch] = 0;
            if(flag == 1)   p.emplace_back(pair{max_ch, max_size});    
            else    break;
        }

        s.clear();
        for(auto &iter : p)
        {
            while(iter.second--)
                s.push_back(iter.first);
        }

        return s;
    }
};
```

## 4.11 å­—ç¬¦ä¸²ä¸­çš„å•è¯æ•°ï¼ˆ434ï¼‰

[434. å­—ç¬¦ä¸²ä¸­çš„å•è¯æ•° - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/number-of-segments-in-a-string/)

### 4.11.1 é—®é¢˜è½¬æ¢ã€

è€ƒè™‘åˆ°ï¼Œæœ€åä¸€ä¸ªå­—ç¬¦åé¢è·Ÿçš„å°±æ˜¯å°¾åè¿­ä»£å™¨ï¼Œè€Œä¸æ˜¯`' '`ï¼Œè¿™ä¼šå¯¼è‡´æ¡ä»¶åˆ¤æ–­çš„å¤æ‚åŒ–ï¼Œå› æ­¤å¯ä»¥è€ƒè™‘ç›´æ¥åœ¨å°¾éƒ¨æ·»åŠ ä¸€ä¸ª`' '`ã€‚

```c++
class Solution {
public:
    int countSegments(string s) {
        int ans = 0;
        s += ' ';
        for (int i = 1; i < s.size(); i++) 
            if (s[i] == ' ' && s[i - 1] != ' ') ans++;
        return ans;
    }
};
```

### 4.11.2 åŸåœ°æ³•

æ»¡è¶³å•è¯çš„ç¬¬ä¸€ä¸ªä¸‹æ ‡æœ‰ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ï¼š

- è¯¥ä¸‹æ ‡å¯¹åº”çš„å­—ç¬¦ä¸ä¸ºç©ºæ ¼ï¼›
- è¯¥ä¸‹æ ‡ä¸ºåˆå§‹ä¸‹æ ‡æˆ–è€…è¯¥ä¸‹æ ‡çš„å‰ä¸‹æ ‡å¯¹åº”çš„å­—ç¬¦ä¸ºç©ºæ ¼ï¼›

```c++
class Solution {
public:
    int countSegments(string s) {
        int segmentCount = 0;

        for (int i = 0; i < s.size(); i++) {
            if ((i == 0 || s[i - 1] == ' ') && s[i] != ' ') {
                segmentCount++;
            }
        }

        return segmentCount;
    }
};
```

### <span style="background:#FF9999;">4.11.3 STLåº“</span>

```c++
class Solution {
public:
    int countSegments(string s) {
        /* é¢˜ç›®ä¸­çš„å•è¯å¹¶ä¸æ˜¯ä¸¥æ ¼æ„ä¹‰ä¸Šçš„å•è¯, è¯´æ˜¯ä¸€ä¸²è¿ç»­çš„å­—ç¬¦æ›´åˆé€‚ã€‚ä¸¤ç§æ€è·¯: 
        * 1ã€ç”¨ç©ºæ ¼åšsplit, æŠŠç©ºçš„ç›´æ¥å¹²æ‰, å‰©ä¸‹çš„ç»Ÿè®¡ä¸€ä¸‹æ•°é‡. 
        * 2ã€ä½¿ç”¨istringstreamå¤„ç†
        */
        istringstream temp(s);   /* ç±»ä¼¼äºcin, ä»¥ç©ºæ ¼(åŒ…æ‹¬è¿ç»­ç©ºæ ¼)ä¸ºåˆ†éš”ç¬¦å°†åŸå­—ç¬¦ä¸²ä¸­çš„å­å­—ç¬¦ä¸²ä¿å­˜ */
        int count = 0;
        while (temp >> s) 
            count++;
        
        return count;
    }
};
```

### 4.11.4 å¤„ç†è¿ç»­çš„0 + åŸºäºsplitæ¥åš

> æƒ³ä¸åˆ°çš„ï¼Œåˆ«çœ‹äº†ã€‚ğŸ½

ç”¨ç©ºæ ¼åšsplit, æŠŠç©ºçš„ç›´æ¥å¹²æ‰, å‰©ä¸‹çš„ç»Ÿè®¡ä¸€ä¸‹æ•°é‡ã€‚ C++ä¸­å¹¶æ²¡æœ‰åº“å‡½æ•°å®ç°split, æ•…è‡ªå·±å®ç°äº†ä¸€ä¸ªsplit, è€ŒJavaã€C#ã€Pythonç­‰ç­‰å¯ä»¥ä½¿ç”¨åº“å‡½æ•°çš„splitã€‚

```c++
class Solution {
public:
    int countSegments(string s) {
        /* é¢˜ç›®ä¸­çš„å•è¯å¹¶ä¸æ˜¯ä¸¥æ ¼æ„ä¹‰ä¸Šçš„å•è¯, è¯´æ˜¯ä¸€ä¸²è¿ç»­çš„å­—ç¬¦æ›´åˆé€‚ã€‚æ€è·¯2: 
        * ç”¨ç©ºæ ¼åšsplit, æŠŠç©ºçš„ç›´æ¥å¹²æ‰, å‰©ä¸‹çš„ç»Ÿè®¡ä¸€ä¸‹æ•°é‡. 
        */
        s.erase(s.find_last_not_of(' ')+1);         // åˆ é™¤å°¾éƒ¨è¿ç»­ç©ºæ ¼
        s.erase(0, s.find_first_not_of(' '));       // åˆ é™¤å¼€å¤´è¿ç»­ç©ºæ ¼
        auto bothAreSpaces = [](char a, char b) 
        { 
            return isspace(a) && isspace(b); 
        };
        s.erase(unique(s.begin(), s.end(), bothAreSpaces), s.end());  /* å°†ä¸­é—´è¿ç»­çš„ç©ºæ ¼æ¢æˆ1ä¸ª */

        vector<string> parts = split(s, ' ');
        int len = parts.size();
        for (int i = 0; i < len; i++)
        {
            if (parts[i] == "") 
            {
                if (i < len - 1) parts.erase(parts.begin() + i);
                else parts.pop_back();
            }
        }
        
        return parts.size();
    }
    vector<string> split(const string& s, char separator)
    {
        vector<string> tokens;
        string token;
        istringstream tokenStream(s);
        while (getline(tokenStream, token, separator))
        {
            tokens.push_back(token);
        }
        return tokens;
    }
};
```

## 4.12 å‰Kä¸ªé«˜é¢‘å•è¯ï¼ˆ692ï¼‰

[692. å‰Kä¸ªé«˜é¢‘å•è¯ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/top-k-frequent-words/)

### <span style="background:#FF9999;">4.12.1 åˆ©ç”¨lambdaè‡ªå®šä¹‰æ’åº</span>

```c++
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string , int> hash;

        for(int i = 0; i < words.size(); ++i)
            ++hash[words[i]];

        sort(words.begin(), words.end(), [&hash](const string &a, const string &b) -> bool
                {
                    return (hash[a] > hash[b]) || (hash[a] == hash[b] && a < b);
                });

        vector<string> ans;
        int sum = 0;
        for(int i = 0; i < k; ++i)
        {
            ans.emplace_back(words[sum]);
            sum += hash[words[sum]];
        }
            

        return ans;
    }
};
```

### 4.12.2 ä½¿ç”¨Vector+è‡ªå®šä¹‰æ’åºï¼ˆå¾…éªŒè¯ï¼Œåšçš„æ—¶å€™ç»™æˆ‘æŠ¥äº†è¶…å‡ºå†…å­˜é™åˆ¶ï¼Œä½†ç†è®ºä¸Šä»£ç åº”è¯¥OKï¼‰

![image-20230512222608885](figures/image-20230512222608885.png)

```c++
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> hash;
        for (const auto &c : words)     ++hash[c];
            
        vector<pair<string, int>> vec;
        for (const auto &h : hash)  vec.push_back(h);

        sort(vec.begin(), vec.end(), [](pair<string, int> &a, pair<string, int> &b) -> bool
                                    {
                                        return a.second > b.second || (a.second == b.second and a.first > b.first);
                                    });

        vector<string> res;
        for(int i = 0; i < k; ++k)  res.emplace_back(vec[i].first);

        return res;
    }
};
```

### 4.12.3 ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †æ’åº+lambdaè¡¨è¾¾å¼ + decltypeï¼‰

```c++
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> hash;
        for (const auto &c : words)     ++hash[c];

        auto cmp = [](const pair<string, int>& a, const pair<string, int>& b) {
            return a.second == b.second ? a.first < b.first : a.second > b.second;
        };
            
        priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp)> pq(cmp);
        for(const auto &h: hash)
        {
            pq.push(h);
            if(pq.size() > k)   pq.pop();
        }

        vector<string> res(k);
        for (int i = k - 1; i >= 0; i--)
        {
            res[i] = pq.top().first;		// å…ˆè¿›å…ˆå‡ºï¼Œæœ€å¤§çš„åœ¨æœ€å‰é¢
            pq.pop();
        }

        return res;
    }
};
```

#### 4.12.3.1 ä¸ºä»€ä¹ˆ`priority_queue`çš„ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯`decltype(cmp)`ï¼Œè€Œä¸æ˜¯å¯¹åº”çš„ç±»å‹ï¼Œæ¯”å¦‚`bool`æˆ–å…¶ä»–å†…å®¹ï¼Ÿ

è‡ªå®šä¹‰`priority_queue`æ’åºè§„åˆ™çš„æ—¶å€™ï¼Œå¦‚æœç”¨`lambda`, å°±éœ€è¦ç”¨ `priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp)> que(cmp);`çš„å½¢å¼ã€‚ä¹Ÿå¯ä»¥ä½¿ç”¨ç»“æ„ä½“é‡è½½`operator()`çš„æ–¹æ³•ï¼Œè¿™æ—¶ä¸éœ€è¦`decltype`ã€‚

```c++
typedef pair<string, int> p;
struct comp {
    bool operator() (p& a, p& b) {
         return a.second == b.second ? a.first < b.first : a.second > b.second;//å°é¡¶å †
    }
};
priority_queue<p, vector<p>, comp> pq;
```

ä¹Ÿå¯ä»¥å‚è€ƒï¼š

> priority_queue takes the comparator as a template argument. Lambda functions are objects, and thus can't be used as template arguments (only very few types can be, among them integral types). From [StackOverflow](https://leetcode.cn/link/?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F5807735%2Fc-priority-queue-with-lambda-comparator-error)
>
> [deduction guides for std::priority_queue - cppreference.com](https://en.cppreference.com/w/cpp/container/priority_queue/deduction_guides)

### 4.12.4 ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †æ’åº+ struct + é‡è½½æ“ä½œç¬¦`()`ï¼‰

```c++
class Solution {
public:
    struct cmp {
        bool operator()(const pair<string, int> &a, const pair<string, int> &b) {
			return a.second == b.second ? a.first < b.first : a.second > b.second;
        }
    };
    
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> hash;
        for (const auto &c : words)     ++hash[c];
            
        priority_queue<pair<string, int>, vector<pair<string, int>>, cmp> pq;
        for(const auto &h: hash)
        {
            pq.push(h);
            if(pq.size() > k)   pq.pop();
        }

        vector<string> res(k);
        for (int i = k - 1; i >= 0; i--)
        {
            res[i] = pq.top().first;		// å…ˆè¿›å…ˆå‡ºï¼Œæœ€å¤§çš„åœ¨æœ€å‰é¢
            pq.pop();
        }

        return res;
    }
};
```

## 4.13 æ£€æµ‹å¤§å†™å­—æ¯ï¼ˆ520ï¼‰

[520. æ£€æµ‹å¤§å†™å­—æ¯ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/detect-capital/)

### 4.13.1 æ¨¡æ‹Ÿæ³•ï¼ˆæ ¹æ®é¢˜ç›®è¦æ±‚å®ç°ï¼‰

```c++
class Solution {
public:
    bool detectCapitalUse(string word) {
        int count(0);
        
        for(int i = 0; i < word.size(); ++i)
            if(isupper(word[i]))  ++count;
        
        if(isupper(word[0]))
        {
            if(count == 1)  return true;
            if(word.size() == count)    return true;
            return false;
        }

        if(count >= 1)  return false;
        return true;
    }
};

//å®˜æ–¹é¢˜è§£
class Solution {
public:
    bool detectCapitalUse(string word) {
        // è‹¥ç¬¬ 1 ä¸ªå­—æ¯ä¸ºå°å†™ï¼Œåˆ™éœ€é¢å¤–åˆ¤æ–­ç¬¬ 2 ä¸ªå­—æ¯æ˜¯å¦ä¸ºå°å†™
        if (word.size() >= 2 && islower(word[0]) && isupper(word[1])) {
            return false;
        }
        
        // æ— è®ºç¬¬ 1 ä¸ªå­—æ¯æ˜¯å¦å¤§å†™ï¼Œå…¶ä»–å­—æ¯å¿…é¡»ä¸ç¬¬ 2 ä¸ªå­—æ¯çš„å¤§å°å†™ç›¸åŒ
        for (int i = 2; i < word.size(); ++i) {
            if (islower(word[i]) ^ islower(word[1])) {
                return false;
            }
        }
        return true;
    }
};
```

### 4.13.2 è½¬æ¢é—®é¢˜

è¿™ç§æ–¹æ³•å·²ç»è§è¿‡ä¸æ­¢ä¸€æ¬¡äº†ï¼Œè½¬æ¢é—®é¢˜å¾€å¾€æ˜¯ä¸€ç§è¡Œä¹‹æœ‰æ•ˆçš„æ–¹æ³•ï¼ˆå‰ææ˜¯â€¦â€¦ï¼‰ã€‚

```c++
class Solution {
public:
    bool detectCapitalUse(string word) {
        int uc = 0;
        for (int i = 0; i < word.size(); i++) {
            if (isupper(word[i]) && uc++ < i) {
                return false;
            }
        }
        
        return uc == word.size() || uc <= 1;
    }
};
```

â€¦â€¦å‰ææ˜¯ï¼Œyou can really understand it and realize or achieve it.

## 4.14 æœ€é•¿å…¬å…±å‰ç¼€ï¼ˆ14ï¼‰

[14. æœ€é•¿å…¬å…±å‰ç¼€ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/longest-common-prefix/)

### 4.14.1 çºµå‘æ‰«æ

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        string res = strs[0];             //é€‰æ‹©ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºå¯¹ç…§æ ‡å‡†
        for(int i = 1; i < strs.size(); i++)
        {
            for(int j = 0; j < res.length(); j++)
            {
                if(res[j] == strs[i][j])    continue;
                else    res.erase(j);       //æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸ç¬¦åˆçš„å­—ç¬¦ä½ç½®ï¼Œä»pos=jå¤„å¼€å§‹åˆ é™¤ç›´è‡³ç»“å°¾
                break;
            }
        }
        return res;
    }
};

class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        //å­—ç¬¦ä¸²æ•°ç»„ä¸ºç©ºåˆ™ç½®resä¸ºç©ºï¼Œå¦åˆ™ç½®ä¸ºç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²
        string res = strs.empty() ? "" : strs[0]; 
        //éå†å­—ç¬¦ä¸²æ•°ç»„
        for (string s : strs)
        {
            /*
            åœ¨å­—ç¬¦ä¸²sä¸­æŸ¥æ‰¾reså¹¶è¿”å›é¦–å­—æ¯çš„ä½ç½®ï¼ˆfindå‡½æ•°ï¼‰
            å¦‚æœé¦–åœ°å€ä¸ä¸ºé›¶ï¼Œæ¯æ¬¡ä»¤res-1ä»¥ç¼©çŸ­å…¬å…±å‰ç¼€
            æ¯”å¦‚è¯´å†flowä¸­æŸ¥æ‰¾flowerï¼Œæ²¡æœ‰æ‰¾åˆ°ï¼Œè¿”å›å€¼ä¸ºè¿­ä»£å™¨ç»“å°¾ï¼ˆé0ï¼‰
            å…¬å…±å‰ç¼€ä¼šå‡æ‰æœ€åä¸€ä¸ªå­—æ¯ï¼Œä¸ºfloweã€‚ç»§ç»­å¾ªç¯ç›´åˆ°ä¸ºflow

            å¦‚æœæ˜¯é¦–å­—æ¯ä¸ä¸€æ ·åˆ™å…¬å…±å‰ç¼€ä¼šæ¸…ç©º
            */ 
            while (s.find(res) != 0) 
            {
                res = res.substr(0, res.length() - 1);
            }
        }
        return res;
    }
};
```

## 4.15 æœ€é•¿ç‰¹æ®Šåºåˆ— â… ï¼ˆ521ï¼‰

[521. æœ€é•¿ç‰¹æ®Šåºåˆ— â…  - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/longest-uncommon-subsequence-i/)

### 4.15.1 ç®€å•é¢˜è§£

å…¶å®è¿™é¢˜æœ€é‡è¦çš„æ˜¯çœ‹æ˜ç™½é¢˜ç›®çš„æ„æ€ï¼š

1. ä¸¤å­—ç¬¦ä¸²é•¿åº¦ä¸ç­‰ï¼Œç‰¹æ®Šåºåˆ—å³ä¸ºè¾ƒå¤§å­—ç¬¦ä¸²ï¼›
2. è‹¥é•¿åº¦ç›¸ç­‰ä¸”å­—ç¬¦ä¸²ç›¸åŒè¿”å›-1ï¼›
3. è‹¥é•¿åº¦ç›¸ç­‰ï¼Œå­—ç¬¦ä¸²ä¸åŒï¼Œè¿”å›aæˆ–bé•¿åº¦ã€‚

```c++
class Solution {
public:
    int findLUSlength(string a, string b) {
        return a != b ? max(a.length(), b.length()) : -1;
    }
};
```

## 4.16 æœ€é•¿ç‰¹æ®Šåºåˆ— IIï¼ˆ522ï¼‰

[522. æœ€é•¿ç‰¹æ®Šåºåˆ— II - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/longest-uncommon-subsequence-ii/)

### 4.16.1 åŒæŒ‡é’ˆ

```c++
class Solution {
public:
    int findLUSlength(vector<string>& strs) {
        int i, j;
        int res, flag;
        res = -1;
        for(i = 0;i < strs.size(); i++){
            flag = 1;
            for(j = 0; j < strs.size(); j++){
                if(i == j)  continue;
                if(isSubseq(strs[i], strs[j]) == 1) flag = 0;
            }
            if (flag == 1 && res < (int)strs[i].size()){
                res = strs[i].size();
            }
        }
        return res;
    }
    bool isSubseq(string& s1, string& s2){
        int i = 0, j = 0;
        while (i < s1.size() && j < s2.size()){
            if(s2[j] != s1[i]){
                j++;
            }
            else{
                i++;
                j++;
            }
        }
        return i >= s1.size();
    }
};
```

### 4.16.2 å¼€æ‹“æ€è·¯ï¼ˆåè¯æ³•ï¼‰

æ€§è´¨ï¼š è‹¥ s çš„å­ä¸²æ˜¯ç‰¹æ®Šåºåˆ—ï¼Œåˆ™sä¹Ÿæ˜¯ç‰¹æ®Šåºåˆ—ï¼Œå› æ­¤åªéœ€çœ‹æ•´ä½“å­—ç¬¦å°±å¯ä»¥ã€‚

åè¯æ³•ï¼šè‹¥å­—ç¬¦ä¸² s ä¸æ˜¯ç‰¹æ®Šåºåˆ—çš„è¯ï¼Œåˆ™è¯¥å­—ç¬¦ä¸²ä¸€å®šæ˜¯å…¶å®ƒæŸä¸ªå­—ç¬¦ä¸² t çš„å­åºåˆ—ï¼Œé‚£ä¹ˆå°±å¯ä»¥é€šè¿‡åˆ é™¤ t çš„éƒ¨åˆ†å­—ç¬¦ï¼Œä½¿å¾— t çš„æŸä¸ªå­åºåˆ—æ˜¯ s1 ï¼Œs1 ä¸æ˜¯ç‰¹æ®Šåºåˆ—ï¼Œæ•… sä¸€å®šæ˜¯ç‰¹æ®Šåºåˆ—ã€‚

æ€§è´¨çš„ä½¿ç”¨ï¼šç‰¹æ®Šåºåˆ—åªéœ€è¦è€ƒè™‘æ•´ä¸ªå­—ç¬¦ä¸²å³å¯ï¼Œä¸éœ€è¦æšä¸¾å­ä¸²ï¼Œå› ä¸ºå¦‚æœå­ä¸²æ˜¯ç‰¹æ®Šåºåˆ—ï¼Œé‚£ä¹ˆå­—ç¬¦ä¸² s æœ¬èº«ä¹Ÿæ˜¯ç‰¹æ®Šåºåˆ—ï¼Œä¸”æ›´é•¿ï¼Œå› æ­¤**åªéœ€è¦å¯¹æ¯ä¸ªå­—ç¬¦ä¸² s è¿›è¡Œåˆ¤æ–­ï¼Œæ˜¯å¦æ˜¯å…¶ä»–å­—ç¬¦ä¸²çš„å­ä¸²å³å¯**ã€‚

```c++
class Solution {
public:
    bool isSubStr(string &a, string &b){//åˆ¤æ–­aæ˜¯å¦ä¸ºbçš„å­ä¸²
        int i = 0;
        for (auto c: b)
            if (i < a.size() && c == a[i]) i++ ;
        return i == a.size();
    }
    int findLUSlength(vector<string>& strs) {
        sort(strs.begin(),strs.end(),[](string a, string b){    //æŒ‰ç…§é•¿åº¦ä»å¤§åˆ°å°æ’ 
            return a.size()>b.size();
        });
        for(int i = 0; i < strs.size(); i++){   //æŒ‰ç…§é•¿åº¦ä»å¤§åˆ°å°æšä¸¾ä¸²i åˆ¤æ–­iä¼šå¦æ˜¯ç‰¹æ®Šåºåˆ—
            bool isSub = false;                 //å…ˆå‡è®¾iä¸æ˜¯ä»»ä½•ä¸²çš„å­ä¸²
            for(int j = 0; j < strs.size() && strs[i].size() <= strs[j].size(); j++){   //åˆ¤æ–­iæ˜¯å¦ä¸ºjçš„å­ä¸²
                if(i != j && isSubStr(strs[i], strs[j])){   //è‹¥iæ˜¯jçš„å­ä¸² åˆ™iä¸æ˜¯ç‰¹æ®Šåºåˆ— è·³å‡ºå³å¯ 
                    isSub = true;
                    break;
                }
            }
            if(!isSub) return strs[i].size();       //iä¸æ˜¯ä»»ä½•ä¸²çš„å­ä¸² åˆ™ä¸ºç‰¹æ®Šåºåˆ— ç›´æ¥è¿”å›å³å¯ 
        }
        return -1;
    }
};
```

## 4.17 è®¡æ•°äºŒè¿›åˆ¶å­ä¸²ï¼ˆ696ï¼‰

[696. è®¡æ•°äºŒè¿›åˆ¶å­ä¸² - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/count-binary-substrings/)

### 4.17.1 æš´åŠ›è§£æ³•

è¶…æ—¶äº†

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚

```c++
class Solution {
public:
    int countBinarySubstrings(string s) {
        int res(0);

        if(s.size() == 1)   return 0;
        for(int i(0); i < s.size() - 1; ++i)
        {
            int sum(0);
            int flag(0);
            int size1(1), size2(0);
            for(int j(i + 1); j < s.size(); ++j)
            {
                if(s[j] == s[i] and flag == 0)  size1++;
                if(s[j] == s[i] and flag == 1)  break;
                if(s[j] != s[i])
                {
                    flag = 1;
                    size2++;
                }
                if(flag == 1 and size1 == size2)    res++;  
            }
        }

        return res;
    }
};
```

### 4.17.2 æŒ‰å­—ç¬¦åˆ†ç»„ã€ä¸€æ¬¡éå†

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚

```c++
class Solution {
public:
    int countBinarySubstrings(string s) {
        int ptr = 0, n = s.size(), last = 0, ans = 0;
        while (ptr < n) {
            char c = s[ptr];
            int count = 0;
            while (ptr < n && s[ptr] == c) {
                ++ptr;				// æ­¤å¤„å®ç°äº†ptrçš„ä¸€æ¬¡éå†
                ++count;
            }
            ans += min(count, last);	// æ­¤å¤„è½¬æ¢äº†é—®é¢˜, å°†è®¡æ•°ä¸åŒ¹é…é—®é¢˜, è½¬æ¢ä¸ºäº†æœ‰å¤šå°‘ä¸ª1æˆ–0çš„æœ€å°å€¼
            last = count;
        }
        return ans;
    }
};

// ä¼˜åŒ–ç®—æ³•
class Solution {
public:
    int countBinarySubstrings(string s) {
        int i = 0, pre = 0, cur = 1, ans = 0;
        for (int i = 0; i < s.size() - 1; ++i) {
            if(s[i] == s[i + 1]) ++cur;
            else
            {
                pre = cur;
                cur = 1;
            }
            if(pre >= cur)  ++ans;
        }
        return ans;
    }
};
```

# 5 æ ‘

## 5.0 éå†

> ä»¥äºŒå‰æ ‘ä¸ºä¾‹ã€‚

æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š

```c
struct BTree{
	int vertex;
	struct BTree *left;
	struct BTree *right;
};
typedef struct BTree *btlink;

//nodestack define
static btlink stack[STACKSIZE];
static int sp=-1;
static int empty(void){
	return sp==-1;
}
static void push(btlink item){
	stack[++sp]=item;
}
static btlink pop(void){
	return stack[sp--];
}
static btlink top(void){
	return stack[sp];
}

//statusstack define
static int stack2[STACKSIZE];
static int sp2=-1;
static int empty2(void){
	return sp2==-1;
}
static void push2(int status){
	stack2[++sp2]=status;
}
static int pop2(void){
	return stack2[sp2--];
}
static int top2(void){
	return stack2[sp2];
}
static void change2(int newstatus){
	stack2[sp]=newstatus;
}
```

Reference: [LeechanX/Data-Structures-and-Algorithms-in-C](https://github.com/LeechanX/Data-Structures-and-Algorithms-in-C)

> å‰åºã€ä¸­åºã€ååºéƒ½æ˜¯DFSç®—æ³•ï¼Œå±‚åºéå†å±äºBFSç®—æ³•ã€‚

### 5.0.1 å…ˆï¼ˆå‰ï¼‰åºéå†ï¼ˆé€’å½’ï¼‰

å…ˆåºéå†ï¼šæ ¹ç»“ç‚¹ ---> å·¦å­æ ‘ ---> å³å­æ ‘

```c
void prefix_recursive(btlink root){
	if(root){
		printf("%d ",root->vertex );
		prefix_recursive(root->left);
		prefix_recursive(root->right);
	}
}
```

### 5.0.2 å…ˆï¼ˆå‰ï¼‰åºéå†ï¼ˆè¿­ä»£ï¼‰

![äºŒå‰æ ‘å‰åºéå†ï¼ˆè¿­ä»£æ³•ï¼‰](figures/äºŒå‰æ ‘å‰åºéå†ï¼ˆè¿­ä»£æ³•ï¼‰.gif)

```c
void prefix_nonrecursive(btlink btree){
	printf("prefix_nonrecursive:\n");
	btlink cur=btree;
	while(cur || !empty()){
		while(cur){
			printf("%d ",cur->vertex);
			push(cur);
			cur=cur->left;
		}
		if(!cur){
			cur=pop();
			cur=cur->right;
		}
	}
	printf("\n");
}
```

### 5.0.3 ä¸­åºéå†ï¼ˆé€’å½’ï¼‰

ä¸­åºéå†ï¼šå·¦å­æ ‘---> æ ¹ç»“ç‚¹ ---> å³å­æ ‘

```c
void infix_recursive(btlink root){
	if(root){
		infix_recursive(root->left);
		printf("%d ",root->vertex );
		infix_recursive(root->right);
	}
}
```

### 5.0.4 ä¸­åºéå†ï¼ˆè¿­ä»£ï¼‰

![äºŒå‰æ ‘ä¸­åºéå†ï¼ˆè¿­ä»£æ³•ï¼‰](figures/äºŒå‰æ ‘ä¸­åºéå†ï¼ˆè¿­ä»£æ³•ï¼‰.gif)

```c
void infix_nonrecursive(btlink btree){
	printf("infix_nonrecursive:\n");
	btlink cur=btree;
	while(cur || !empty()){
		while(cur){
			push(cur);
			cur=cur->left;
		}
		if(!cur){
			cur=pop();
			printf("%d ",cur->vertex );
			cur=cur->right;
		}
	}
	printf("\n");
}
```

### 5.0.5 ååºéå†ï¼ˆé€’å½’ï¼‰

ååºéå†ï¼šå·¦å­æ ‘ ---> å³å­æ ‘ ---> æ ¹ç»“ç‚¹

```c
void suffix_recursive(btlink root){
	if(root){
		suffix_recursive(root->left);
		suffix_recursive(root->right);
		printf("%d ",root->vertex );
	}
}
```

### 5.0.6 ååºéå†ï¼ˆè¿­ä»£ï¼‰

![å‰åºåˆ°ååº](figures/20200808200338924.png)

```c
void suffix_nonrecursive(btlink btree){
	printf("suffix_nonrecursive:\n");
	btlink cur=btree;
	int status;
	push(cur);push2(0);
	while(!empty()){
		status=top2();
		switch(status){
			case 0:
				cur=top();
				change2(1);
				if(cur->left){
					push(cur->left);
					push2(0);
				}
				break;
			case 1:
				cur=top();
				change2(2);
				if(cur->right){
					push(cur->right);
					push2(0);
				}
				break;
			default:
				cur=pop();pop2();
				printf("%d ",cur->vertex);
		}
	}
	printf("\n");
}
```

### 5.0.7 å±‚åºéå†ï¼ˆé€’å½’ï¼ŒC++ï¼‰

å±‚åºéå†ï¼šåªéœ€æŒ‰å±‚æ¬¡ï¼Œä»å·¦å¾€å³éå†å³å¯ã€‚

```c++
void levelorder_recursive(TreeNode *root, size_t level, vector<vector<int>> &res){
	if(!root)	return;
    if(res.size() < level)	res.emplace_back();		// ä½¿ç”¨é»˜è®¤çš„æ„é€ å‡½æ•°
    
    res[level - 1].push_back(root->val);
    levelorder_recursive(root->left, level + 1, res);
    levelorder_recursive(root->right, level + 1, res);
}
```

### 5.0.8 å±‚åºéå†ï¼ˆè¿­ä»£ï¼ŒåŸºäºé˜Ÿåˆ—ï¼ŒC++ï¼‰

![img](figures/20180226001828381.png)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
vector<vector<int>> levelOrder(TreeNode *root) {
        vector<vector<int>> res;
        queue<TreeNode *> queue_;
        if(root)	queue_.push(root);

        while(!queue_.empty()){
            int size = queue_.size();
            vector<int> nums;
            for (size_t i = 0; i < size; i++){
                TreeNode* node = queue_.front();
                queue_.pop();
                nums.push_back(node->val);
                if(node->left){
                    queue_.push(node->left);
                }
                if(node->right){
                    queue_.push(node->right);
                }
            }
            res.push_back(move(nums));
        }

        return res;
    }
};
```

### 5.0.9 BFSï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ŒBreadth-First Searchï¼‰

![Animated_BFS.gif](figures/Animated_BFS.gif)

```c++
void enqueue(btlink item){
	queue[rear]=item;
	rear=(rear+1)%QUEUESIZE;
}

btlink dequeue(){
	btlink retval=queue[head];
	head=(head+1)%QUEUESIZE;
	return retval;
}

void bfs(btlink tree){
	enqueue(tree);
	btlink cur;
	while(!empty_queue()){
		cur=dequeue();
		printf("%d ", cur->vertex);
		if(cur->left)
			enqueue(cur->left);
		if(cur->right)
			enqueue(cur->right);
	}
	printf("\n");
}
```

## 5.1 æ±‚äºŒå‰æ ‘çš„æ·±åº¦

[å‰‘æŒ‡ Offer 55 - I. äºŒå‰æ ‘çš„æ·±åº¦ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/)

### 5.1.1 DFSï¼ˆæ·±åº¦ä¼˜å…ˆæœç´¢ï¼ŒDepth-First Searchï¼‰

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(struct TreeNode* root){
        if (root == nullptr) {
            return 0;
        }

        /* å½“å‰èŠ‚ç‚¹çš„å·¦å­æ ‘çš„æ·±åº¦ */
        int lenLeft = maxDepth(root->left);

        /* å½“å‰èŠ‚ç‚¹çš„å³å­æ ‘çš„æ·±åº¦ */
        int lenRight = maxDepth(root->right);

        /* äºŒå‰æ ‘çš„æ·±åº¦ç­‰äºå·¦å³å­æ ‘æ·±åº¦çš„çš„è¾ƒå¤§è€…åŠ  1ï¼ˆå½“å‰èŠ‚ç‚¹çš„æ·±åº¦ï¼‰*/
        return lenLeft > lenRight ? lenLeft + 1 : lenRight + 1;
    }
};

// è¿›ä¸€æ­¥ä¼˜åŒ–
class Solution {
public:
    int maxDepth(struct TreeNode* root){
		return root == nullptr ? 0 : max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

### 5.1.2 BFSï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ŒBreadth-First Searchï¼‰

> ç±»ä¼¼äºå±‚æ¬¡éå†

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> q;
        if (root) q.push(root);
        int ans = 0;
        while (!q.empty()) {
            for (int i = q.size() - 1; i >= 0; --i) {
                TreeNode* cur = q.front();
                q.pop();
                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right);
            }
            ++ans;
        }
        return ans;
    }
};
```

## 5.2 ç›¸åŒçš„æ ‘ï¼ˆ100ï¼‰

[100. ç›¸åŒçš„æ ‘ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/same-tree/)

### 5.2.1 BFS+å±‚æ¬¡éå†+é€’å½’

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
		if(p == nullptr and q == nullptr)   return true;

        if(p->val == q->val and p != nullptr and q != nullptr)
            return isSameTree(p->left, q->left) and isSameTree(p->right, q->right);
        
        return false;
    }
};
```

### 5.2.2 BFS+å±‚æ¬¡éå†+è¿­ä»£

```c++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == NULL || q == NULL) return p == q;
        queue<TreeNode*> que;
        que.push(p);   
        que.push(q);  
        while (!que.empty()) {  
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode)    continue;
            
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val)))
                return false;
            
            que.push(leftNode->left);   
            que.push(rightNode->left); 
            que.push(leftNode->right);  
            que.push(rightNode->right); 
        }
        return true;
    }
};
```

## 5.3 å¹³è¡¡äºŒå‰æ ‘ï¼ˆAVLæ ‘ï¼‰

[å‰‘æŒ‡ Offer 55 - II. å¹³è¡¡äºŒå‰æ ‘ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/)

å¹³è¡¡äºŒå‰æ ‘ä¹Ÿå« **å¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼ˆSelf-balancing binary search treeï¼‰**ï¼Œåˆè¢«ç§°ä¸º AVL æ ‘ï¼Œå¯ä»¥ä¿è¯ **æŸ¥è¯¢æ•ˆç‡è¾ƒé«˜**ã€‚å®ƒæ˜¯è§£å†³ **äºŒå‰æ’åº** å¯èƒ½å‡ºç°çš„æŸ¥è¯¢é—®é¢˜ã€‚

å®ƒçš„ç‰¹ç‚¹ï¼šæ˜¯ä¸€é¢—ç©ºæ ‘æˆ–å®ƒçš„ **å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1**ï¼Œå¹¶ä¸”å·¦å³ä¸¤ä¸ªå­æ ‘éƒ½æ˜¯ä¸€é¢—å¹³è¡¡äºŒå‰æ ‘ã€‚

å¹³è¡¡äºŒå‰æ ‘çš„å¸¸ç”¨å®ç°æ–¹æ³•æœ‰ï¼š

- çº¢é»‘æ ‘
- AVLï¼ˆç®—æ³•ï¼‰
- æ›¿ç½ªç¾Šæ ‘
- Treap
- ä¼¸å±•æ ‘

ä»¥ä¸‹ä¸¤ç§éƒ½å¯ä»¥ç§°ä¸ºAVLæ ‘ã€‚

![image-20230517143017682](figures/image-20230517143017682.png)

### 5.3.1 DFS+ååºéå†

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int dfs(TreeNode* root) {
        if(root == nullptr) return 0;
        int left = dfs(root->left);
        if(left == -1)  return -1;
        int right = dfs(root->right);
        if(right == -1)  return -1;

        return abs(left - right) > 1 ? -1 : max(left, right) + 1;
    }

    bool isBalanced(TreeNode* root) {
        return dfs(root) != -1;
    }
};
```

### 5.3.2 DFS+å‰åºéå†

```c++
class Solution {
public:
	bool isBalanced(TreeNode* root) {
		if (root == NULL) return true;//å¦‚æœè¯¥å­æ ‘ä¸ºç©ºï¼Œåˆ™ä¸€å®šæ˜¯å¹³è¡¡çš„ï¼ˆå› ä¸ºæ²¡æœ‰å·¦å³å­æ ‘ï¼‰
		if (abs(getHeight(root->left) - getHeight(root->right)) > 1) return false;
		return isBalanced(root->left)&& isBalanced(root->right);
	}
	int getHeight(TreeNode* root)
	{
		if (root == NULL) return 0;
		int leftHeight = getHeight(root->left);
		int rightHeight = getHeight(root->right);
		return leftHeight > rightHeight ? leftHeight + 1 : rightHeight + 1;
	}
};
```

# 6 å…«å¤§æ’åºç®—æ³•

Reference: æ•°æ®ç»“æ„ï¼ˆC++è¯­è¨€ç‰ˆï¼‰	é‚“ä¿Šè¾‰ç¬¬ä¸‰ç‰ˆ

[OI Wiki - OI Wiki (oi-wiki.org)](https://oi-wiki.org/)

## 6.0 æ’åºç®—æ³•å¯¹æ¯”

![æ’åº](figures/æ’åº-1684484697149-4.png)

![image-20230522174350309](figures/image-20230522174350309.png)

ä»¥ä¸‹æ˜¯å‡ ç§æ’åºç®—æ³•çš„æ¯”è¾ƒã€‚

![å‡ ç§æ’åºç®—æ³•çš„æ¯”è¾ƒ](figures/sort-intro-1.apng)

## 6.1 ç›´æ¥æ’å…¥æ’åº

### 6.1.1 å®šä¹‰

æ’å…¥æ’åºï¼ˆè‹±è¯­ï¼šInsertion sortï¼‰æ˜¯ä¸€ç§ç®€å•ç›´è§‚çš„æ’åºç®—æ³•ã€‚

**é€‚ç”¨æ€§ï¼š**é€‚ç”¨äºåŒ…æ‹¬å‘é‡ä¸åˆ—è¡¨åœ¨å†…çš„ä»»ä½•åºåˆ—ç»“æ„ã€‚

**ç¨³å®šæ€§ï¼š**å¦‚æœç¢°è§ä¸€ä¸ªå’Œæ’å…¥å…ƒç´ ç›¸ç­‰çš„ï¼Œé‚£ä¹ˆæ’å…¥å…ƒç´ æŠŠæƒ³æ’å…¥çš„å…ƒç´ æ”¾åœ¨ç›¸ç­‰å…ƒç´ çš„åé¢ã€‚æ‰€ä»¥ï¼Œ**ç›¸ç­‰å…ƒç´ çš„å‰åé¡ºåºæ²¡æœ‰æ”¹å˜ï¼ˆå› ä¸ºä»å‰å¾€åæ’å…¥ï¼‰**ï¼Œä»åŸæ— åºåºåˆ—å‡ºå»çš„é¡ºåºå°±æ˜¯æ’å¥½åºåçš„é¡ºåºï¼Œæ‰€ä»¥æ’å…¥æ’åºæ˜¯ç¨³å®šçš„ã€‚

### 6.1.2 åŸºæœ¬æ€æƒ³

ç®—æ³•çš„æ€è·¯å¯ç®€è¦æè¿°ä¸ºï¼š å§‹ç»ˆå°†æ•´ä¸ªåºåˆ—è§†ä½œå¹¶åˆ‡åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š æœ‰åºçš„å‰ç¼€ï¼Œ æ— åºçš„åç¼€ï¼›é€šè¿‡è¿­ä»£ï¼Œåå¤åœ°å°†åç¼€çš„é¦–å…ƒç´ è½¬ç§»è‡³å‰ç¼€ä¸­ã€‚ ç”±æ­¤äº¦å¯çœ‹å‡ºæ’å…¥æ’åºç®—æ³•çš„ä¸å˜æ€§ï¼š  

> åœ¨ä»»ä½•æ—¶åˆ»ï¼Œ ç›¸å¯¹äºå½“å‰èŠ‚ç‚¹`e = S[r]`ï¼Œ å‰ç¼€`S[0, r)`æ€»æ˜¯ä¸šå·²æœ‰åºã€‚

ç®—æ³•å¼€å§‹æ—¶è¯¥å‰ç¼€ä¸ºç©ºï¼Œä¸å˜æ€§è‡ªç„¶æ»¡è¶³ã€‚  

![image-20230521205513344](figures/image-20230521205513344.png)

å‡è®¾å¦‚å›¾3.5(a)æ‰€ç¤ºï¼Œ å‰ç¼€`S[0, r)`å·²ç»æœ‰åºã€‚æ¥ä¸‹æ¥ï¼Œ å€ŸåŠ©æœ‰åºåºåˆ—çš„æŸ¥æ‰¾ç®—æ³•ï¼Œ å¯åœ¨è¯¥å‰ç¼€ä¸­å®šä½åˆ°ä¸å¤§äºeçš„æœ€å¤§å…ƒç´ ã€‚äºæ˜¯åªéœ€å°†eä»æ— åºåç¼€ä¸­å–å‡ºï¼Œ å¹¶ç´§é‚»äºæŸ¥æ‰¾è¿”å›çš„ä½ç½®ä¹‹åæ’å…¥ï¼Œå³å¯å¦‚å›¾(b)æ‰€ç¤ºï¼Œä½¿å¾—æœ‰åºå‰ç¼€çš„èŒƒå›´æ‰©å¤§è‡³`S[0, r]`ã€‚
å¦‚æ­¤ï¼Œè¯¥å‰ç¼€çš„èŒƒå›´å¯ä¸æ–­æ‹“å±•ã€‚ å½“å…¶æœ€ç»ˆè¦†ç›–æ•´ä¸ªåºåˆ—æ—¶ï¼Œ äº¦å³æ•´ä½“æœ‰åºã€‚

ä¸€ä¸ªä¸æ’å…¥æ’åºç›¸åŒçš„æ“ä½œæ˜¯æ‰“æ‰‘å…‹ç‰Œæ—¶ï¼Œä»ç‰Œæ¡Œä¸ŠæŠ“ä¸€å¼ ç‰Œï¼ŒæŒ‰ç‰Œé¢å¤§å°æ’åˆ°æ‰‹ç‰Œåï¼Œå†æŠ“ä¸‹ä¸€å¼ ç‰Œã€‚

![insertion-sort-1-animate-example](figures/insertion-sort-1-animate-example-1684659276312-15-1684659280067-17.svg)

### 6.1.3 å®ç°

![image-20230521164949178](figures/image-20230521164949178.png)

```c++
void insertion_sort(int arr[], int len) {
  for (int i = 1; i < len; ++i) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j];
      j--;
    }
    arr[j + 1] = key;
  }
}
```

## 6.2 Shellæ’åº

> ğŸ˜°å£°æ˜ï¼šæˆ‘è§‰å¾—çœŸä¸è‡³äºè€ƒé‚£ä¹ˆéš¾çš„ï¼Œé™¤éé¢å‘åå­ã€å¤§ç–†é¢è¯•ã€‚

### 6.2.1 å®šä¹‰

å¸Œå°”æ’åºï¼ˆè‹±è¯­ï¼šShell sortï¼‰ï¼Œä¹Ÿç§°ä¸ºç¼©å°å¢é‡æ’åºæ³•ï¼Œæ˜¯æ’å…¥æ’åºçš„ä¸€ç§æ”¹è¿›ç‰ˆæœ¬ã€‚å¸Œå°”æ’åºä»¥å®ƒçš„å‘æ˜è€…å¸Œå°”ï¼ˆè‹±è¯­ï¼šDonald Shellï¼‰å‘½åã€‚

æœ€ä¼˜æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$ï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦ä¸æœ€åæ—¶é—´å¤æ‚åº¦ä¸å¢é‡åºåˆ—çš„é€‰æ‹©æ¯æ¯ç›¸å…³ã€‚

**é€‚ç”¨åœºæ™¯ï¼š**é€‚ç”¨äºåŒ…æ‹¬å‘é‡ä¸åˆ—è¡¨åœ¨å†…çš„ä»»ä½•åºåˆ—ç»“æ„ã€‚ï¼ˆå¾…è¡¥å……ï¼‰

**ç¨³å®šæ€§ï¼š**ä¸ç¨³å®šã€‚

### 6.2.2 é€’å‡å¢é‡ç­–ç•¥

#### 6.2.2.1 å¢é‡

å¸Œå°”æ’åºï¼ˆShell sortï¼‰ ç®—æ³•é¦–å…ˆå°†æ•´ä¸ªå¾…æ’åºå‘é‡`A[]`ç­‰æ•ˆåœ°è§†ä½œä¸€ä¸ªäºŒç»´çŸ©é˜µ`B[][]`ã€‚ï¼ˆæ³¨æ„ï¼šæ­¤å¤„åªæ˜¯çœ‹ä½œï¼Œå®é™…ä¸Šå¸Œå°”æ’åºçš„ç©ºé—´å¤æ‚åº¦ä»ç„¶æ˜¯$O(1)$ï¼‰

![image-20230521210420282](figures/image-20230521210420282.png)

äºæ˜¯å¦‚å›¾12.14æ‰€ç¤ºï¼Œè‹¥åŸä¸€ç»´å‘é‡ä¸º`A[0, n)`ï¼Œåˆ™å¯¹äºä»»ä¸€å›ºå®šçš„çŸ©é˜µå®½åº¦`w`ï¼Œ `A`ä¸`B`ä¸­å…ƒç´ ä¹‹é—´æ€»æœ‰ä¸€ä¸€å¯¹åº”å…³ç³»ï¼š

 `B[i][j] = A[i + jw]`  

æˆ–

`A[k] = B[k % w][k / w]`  

ä»ç§©çš„è§’åº¦æ¥çœ‹ï¼ŒçŸ©é˜µ`B`çš„å„åˆ—ä¾æ¬¡å¯¹åº”äºæ•´æ•°å­é›†`[0, n)`å…³äºå®½åº¦wçš„æŸä¸€åŒä½™ç±»ã€‚è¿™ä¹Ÿç­‰æ•ˆäºä»ä¸Šåˆ°ä¸‹ã€è‡ªå·¦è€Œå³åœ°å°†åŸå‘é‡`A`ä¸­çš„å…ƒç´ ï¼Œ ä¾æ¬¡å¡«å…¥çŸ©é˜µ`B`çš„å„ä¸ªå•å…ƒã€‚
ä¸ºç®€åŒ–èµ·è§ï¼Œ ä»¥ä¸‹ä¸å¦¨å‡è®¾`w`æ•´é™¤`n`ã€‚å¦‚æ­¤ï¼Œ `B`ä¸­åŒå±ä¸€åˆ—çš„å…ƒç´ è‡ªä¸Šè€Œä¸‹ä¾æ¬¡å¯¹åº”äº`A`ä¸­ä»¥`w`ä¸ºé—´éš”çš„`n/w`ä¸ªå…ƒç´ ã€‚å› æ­¤ï¼ŒçŸ©é˜µçš„å®½åº¦`w`äº¦ç§°ä½œå¢é‡ï¼ˆincrementï¼‰ ã€‚

#### 6.2.2.2 ç®—æ³•æ¡†æ¶

å¸Œå°”æ’åºçš„ç®—æ³•æ¡†æ¶ï¼Œ å¯ä»¥æ‰¼è¦åœ°æè¿°å¦‚ä¸‹ï¼š  

```c++
Shellsort(A, n)
è¾“å…¥ï¼šè§„æ¨¡ä¸ºnçš„æ— åºå‘é‡A
è¾“å‡ºï¼šAå¯¹åº”çš„æœ‰åºå‘é‡
{
    å–ä¸€ä¸ªé€’å¢çš„å¢é‡åºåˆ—: H = {w1 = 1, w2, w3, ..., wk, ...}
    è®¾k = max{i | wi < n}, å³wkä¸ºå¢é‡åºåˆ—Hä¸­å°äºnçš„æœ€åä¸€é¡¹
    for(t = k; t > 0; t--)
    {
        å°†å‘é‡Aè§†ä½œä»¥wtä¸ºå®½åº¦çš„çŸ©é˜µBt
        å¯¹Btçš„æ¯ä¸€é¡¹åˆ†åˆ«æ’åº: Bt[i], i = 0, 1, ..., wt-1
    }
}
```

#### 6.2.2.3 å¢é‡åºåˆ—

å¦‚å›¾12.15æ‰€ç¤ºï¼Œå¸Œå°”æ’åºæ˜¯ä¸ªè¿­ä»£å¼é‡å¤çš„è¿‡ç¨‹ã€‚  

![image-20230521212223836](figures/image-20230521212223836.png)

æ¯ä¸€æ­¥è¿­ä»£ä¸­ï¼Œéƒ½ä»äº‹å…ˆè®¾å®šçš„æŸä¸ªæ•´æ•°åºåˆ—ä¸­å–å‡ºä¸€é¡¹ï¼Œå¹¶ä»¥è¯¥é¡¹ä¸ºå®½åº¦ï¼Œ å°†è¾“å…¥å‘é‡é‡æ’ä¸ºå¯¹åº”å®½åº¦çš„äºŒç»´çŸ©é˜µï¼Œç„¶åé€åˆ—åˆ†åˆ«æ’åºã€‚å½“ç„¶ï¼Œå„æ­¥è¿­ä»£å¹¶ä¸éœ€è¦çœŸåœ°ä»ç‰©ç†ä¸Šé‡æ’åŸå‘é‡ã€‚ äº‹å®ä¸Šï¼Œ å€ŸåŠ©ä»¥ä¸Šä¸€ä¸€å¯¹åº”å…³ç³»ï¼Œ å³å¯ä¾¿æ·åœ°ä»é€»è¾‘ä¸Šæ ¹æ®å…¶åœ¨`B`[][]ä¸­çš„ä¸‹æ ‡ï¼Œ è®¿é—®ç»Ÿä¸€ä¿å­˜äº`A[]`ä¸­çš„å…ƒç´ ã€‚
ä¸è¿‡ï¼Œä¸ºä¾¿äºå¯¹ç®—æ³•çš„ç†è§£ï¼Œä»¥ä¸‹æˆ‘ä»¬ä¸å¦¨ä»ç„¶å‡æƒ³åœ°è¿›è¡Œè¿™ä¸€é‡æ’è½¬æ¢ã€‚
å› ä¸ºå¢é‡åºåˆ—ä¸­çš„å„é¡¹æ˜¯é€†å‘å–å‡ºçš„ï¼Œæ‰€ä»¥å„æ­¥è¿­ä»£ä¸­çŸ©é˜µçš„å®½åº¦å‘ˆç¼©å‡çš„è¶‹åŠ¿ï¼Œç›´è‡³æœ€ç»ˆä½¿ç”¨$w_1 = 1$ã€‚çŸ©é˜µæ¯ç¼©å‡ä¸€æ¬¡å¹¶é€åˆ—æ’åºä¸€è½®ï¼Œå‘é‡æ•´ä½“çš„æœ‰åºæ€§å°±å¾—ä»¥è¿›ä¸€æ­¥æ”¹å–„ã€‚å½“å¢é‡ç¼©å‡è‡³1æ—¶ï¼Œå¦‚å›¾12.15æœ€å³ä¾§æ‰€ç¤ºï¼ŒçŸ©é˜µé€€åŒ–ä¸ºå•ç‹¬çš„ä¸€åˆ—ï¼Œæ•…æœ€åä¸€æ­¥è¿­ä»£ä¸­çš„â€œé€åˆ—æ’åºâ€ç­‰æ•ˆäºå¯¹æ•´ä¸ªå‘é‡æ‰§è¡Œä¸€æ¬¡æ’åºã€‚è¿™ç§é€šè¿‡ä¸æ–­ç¼©å‡çŸ©é˜µå®½åº¦è€Œé€æ¸é€¼è¿‘æœ€ç»ˆè¾“å‡ºçš„ç­–ç•¥ï¼Œç§°ä½œ**é€’å‡å¢é‡ï¼ˆdiminishing incrementï¼‰ ç®—æ³•**ï¼Œ è¿™ä¹Ÿæ˜¯å¸Œå°”æ’åºçš„å¦ä¸€åç§°ã€‚

ä»¥é•¿åº¦ä¸º13çš„å‘é‡ï¼š
{ 80, 23, 19, 40, 85, 1, 18, 92, 71, 8, 96, 46, 12 }
ä¸ºä¾‹ï¼Œå¯¹åº”çš„å¸Œå°”æ’åºè¿‡ç¨‹åŠç»“æœå¦‚å›¾12.16æ‰€ç¤ºã€‚

![image-20230521212433559](figures/image-20230521212433559.png)

![image-20230521212450400](figures/image-20230521212450400.png)

#### 6.2.2.4 åº•å±‚ç®—æ³•

æœ€åä¸€è½®è¿­ä»£ç­‰æ•ˆäºå‘é‡çš„æ•´ä½“æ’åºï¼Œ æ•…æ— è®ºæ­¤å‰å„æ­¥å¦‚ä½•è¿­ä»£ï¼Œæœ€ç»ˆå¿…ç„¶è¾“å‡ºæœ‰åºå‘é‡ï¼Œå¸Œå°”æ’åºçš„æ­£ç¡®æ€§æ¯‹åº¸ç½®ç–‘ã€‚ç„¶è€Œåè¿‡æ¥ï¼Œ æˆ‘ä»¬å´ä¸ç¦æœ‰ä¸ªç–‘é—®ï¼šæ—¢ç„¶å¦‚æ­¤ï¼Œ**æ­¤å‰å„æ­¥è¿­ä»£ä¸­çš„é€åˆ—æ’åºåˆæœ‰ä½•å¿…è¦ï¼Ÿä¸ºä½•ä¸ç›´æ¥åšæœ€åä¸€æ¬¡æ’åºå‘¢ï¼Ÿ** è¿™æ¶‰åŠåˆ°åº•å±‚æ’åºç®—æ³•çš„ç‰¹æ€§ã€‚**èƒ½å¤Ÿæœ‰æ•ˆæ”¯æŒå¸Œå°”æ’åºçš„åº•å±‚æ’åºç®—æ³•ï¼Œ å¿…é¡»æ˜¯è¾“å…¥æ•æ„Ÿçš„ï¼Œæ¯”å¦‚æ’å…¥æ’åºç®—æ³•ã€‚**å°½ç®¡è¯¥ç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹éœ€è¦è¿è¡Œ$O(n^2)$æ—¶é—´ï¼Œä½†éšç€å‘é‡çš„æœ‰åºæ€§ä¸æ–­æé«˜ï¼ˆå³é€†åºå¯¹çš„ä¸æ–­å‡å°‘ï¼‰ï¼Œè¿è¡Œæ—¶é—´å°†ä¼šé”å‡ã€‚ å…·ä½“åœ°ï¼Œæ ¹æ®ä¹ é¢˜[3-11]çš„ç»“è®ºï¼ˆæ•°æ®ç»“æ„ï¼ˆC++è¯­è¨€ç‰ˆï¼‰	é‚“ä¿Šè¾‰ç¬¬ä¸‰ç‰ˆï¼‰ï¼Œå½“é€†åºå…ƒç´ çš„é—´è·å‡ä¸è¶…è¿‡$k$æ—¶ï¼Œæ’å…¥æ’åºä»…éœ€$O(kn)$çš„è¿è¡Œæ—¶é—´ã€‚ ä»ä»¥å›¾12.16ä¸ºä¾‹ï¼Œæœ€åä¸€æ­¥è¿­ä»£ï¼ˆæ•´ä½“æ’åºï¼‰ä¹‹å‰ï¼Œå‘é‡ä»…å«ä¸¤å¯¹é€†åºå…ƒç´ ï¼ˆ40å’Œ23ã€ 92å’Œ85ï¼‰ï¼Œå…¶é—´è·ä¸º1ï¼Œæ•…è¯¥æ­¥è¿­ä»£ä»…éœ€çº¿æ€§æ—¶é—´ã€‚

æ­£æ˜¯å¾—ç›Šäºè¿™ä¸€ç‰¹æ€§ï¼Œå„æ­¥è¿­ä»£å¯¹å‘é‡æœ‰åºæ€§çš„æ”¹å–„æ•ˆæœï¼Œæ–¹èƒ½ä¸æ–­ç§¯ç´¯ä¸‹æ¥ï¼Œåç»­å„æ­¥è¿­ä»£çš„è®¡ç®—æˆæœ¬ä¹Ÿèƒ½å¾—ä»¥é™ä½ï¼Œå¹¶æœ€ç»ˆå°†æ€»ä½“æˆæœ¬æ§åˆ¶åœ¨è¶³ä»¥ä»¤äººæ»¡æ„çš„èŒƒå›´ã€‚

### 6.2.3 å¢é‡åºåˆ—

å¸Œå°”æ’åºç®—æ³•çš„ä¸»ä½“æ¡†æ¶å·²ç»å›ºå®šï¼Œå”¯ä¸€å¯ä»¥è°ƒæ•´çš„åªæ˜¯å¢é‡åºåˆ—çš„è®¾è®¡ä¸é€‰ç”¨ã€‚äº‹å®ä¸Šè¿™ä¸€ç‚¹ä¹Ÿçš„ç¡®ååˆ†å…³é”®ï¼Œä¸åŒçš„å¢é‡åºåˆ—å¯¹æ’å…¥æ’åºä»¥ä¸Šç‰¹æ€§çš„åˆ©ç”¨ç¨‹åº¦å„å¼‚ï¼Œç®—æ³•çš„æ•´ä½“æ•ˆç‡ä¹Ÿç›¸åº”åœ°å·®å¼‚æå¤§ã€‚ 

ä¸ºæ”¹è¿›å¸Œå°”æ’åºçš„æ€»ä½“æ€§èƒ½ï¼Œé¦–å…ˆå¿…é¡»å°½å¯èƒ½å‡å°‘ä¸åŒå¢é‡å€¼ä¹‹é—´çš„å…¬å…±å› å­ã€‚  

ä»¥ä¸‹å°†ä»‹ç»å‡ ç§å…¸å‹çš„å¢é‡åºåˆ—ã€‚

#### 6.2.3.1 Shellåºåˆ—

Shellæœ¬äººåœ¨æå‡ºå¸Œå°”ç®—æ³•ä¹‹åˆæ‰€ä½¿ç”¨çš„åºåˆ—ï¼š
$$
Hshell = { 1, 2, 4, 8, 16, 32, ..., 2k, ... }
$$
è‹¥ä½¿ç”¨è¿™ä¸€åºåˆ—ï¼Œ å¸Œå°”æ’åºç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹çš„æ€§èƒ½å¹¶ä¸å¥½ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(N^2)$ã€‚

#### 6.2.3.2 Papernov-Stasevicåºåˆ—

Papernovå’ŒStasevicäº1965å¹´æå‡ºäº†å¦ä¸€å¢é‡åºåˆ—ï¼š
$$
Hps = { 1, 3, 7, 15, 31, 63, ..., 2k - 1, ... }
$$
é‡‡ç”¨è¿™ä¸€å¢é‡åºåˆ—ï¼Œå¸Œå°”æ’åºç®—æ³•çš„æ€§èƒ½å¯ä»¥æ”¹è¿›è‡³$O(n^{3/2})$ï¼Œå…¶ä¸­nä¸ºå¾…æ’åºå‘é‡çš„è§„æ¨¡ã€‚

#### 6.2.3.3 Prattåºåˆ—

Prattäº1971å¹´ä¹Ÿæå‡ºäº†è‡ªå·±çš„å¢é‡åºåˆ—ï¼š
$$
Hpratt = { 1, 2, 3, 4, 6, 8, 9, 12, 16, ..., 2p3q, ... }
$$
å¯ä»¥è¯æ˜ï¼Œ é‡‡ç”¨$Hpratt$åºåˆ—ï¼Œå¸Œå°”æ’åºç®—æ³•è‡³å¤šè¿è¡Œ$O(nlog2n)$æ—¶é—´ã€‚

#### 6.2.3.4 Sedgewickåºåˆ—

å°½ç®¡$Pratt$åºåˆ—çš„æ•ˆç‡è¾ƒé«˜ï¼Œä½†å› å…¶ä¸­å„é¡¹çš„é—´è·å¤ªå°ï¼Œ ä¼šå¯¼è‡´è¿­ä»£è¶Ÿæ•°è¿‡å¤šã€‚ä¸ºæ­¤ï¼Œ$Sedgewick$ç»¼åˆ$Papernov-Stasevic$åºåˆ—ä¸$Pratt$åºåˆ—çš„ä¼˜ç‚¹ï¼Œæå‡ºäº†ä»¥ä¸‹å¢é‡åºåˆ—ï¼š
$$
Hsedgewick = { 1, 5, 19, 41, 109, 209, 505, 929, 2161, 3905, 8929, ... }
$$
å…¶ä¸­å„é¡¹ï¼Œå‡ä¸ºï¼š
$$
9âˆ™4k - 9âˆ™2k + 1
$$
æˆ–
$$
4k - 3âˆ™2k + 1
$$
çš„å½¢å¼ã€‚

å¦‚æ­¤æ”¹è¿›ä¹‹åï¼Œå¸Œå°”æ’åºç®—æ³•åœ¨æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n4/3)$ï¼Œå¹³å‡å¤æ‚åº¦ä¸º$O(n7/6)$ã€‚æ›´é‡è¦çš„æ˜¯ï¼Œåœ¨é€šå¸¸çš„åº”ç”¨ç¯å¢ƒä¸­ï¼Œ è¿™ä¸€å¢é‡åºåˆ—çš„ç»¼åˆæ•ˆç‡æœ€ä½³ã€‚

### 6.2.4 å®ç°

```c++
template <typename T>
void shell_sort(T array[], int length) {
  int h = 1;
  while (h < length / 3) {
    h = 3 * h + 1;
  }
  while (h >= 1) {
    for (int i = h; i < length; i++) {
      for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
        std::swap(array[j], array[j - h]);
      }
    }
    h = h / 3;
  }
}
```

## 6.3 ç›´æ¥é€‰æ‹©æ’åº

### 6.3.1 å®šä¹‰

é€‰æ‹©æ’åºï¼ˆè‹±è¯­ï¼šSelection sortï¼‰æ˜¯ä¸€ç§ç®€å•ç›´è§‚çš„æ’åºç®—æ³•ã€‚å®ƒçš„å·¥ä½œåŸç†æ˜¯æ¯æ¬¡æ‰¾å‡ºç¬¬$i$å°çš„å…ƒç´ ï¼ˆä¹Ÿå°±æ˜¯$A_{i...n}$ä¸­æœ€å°çš„å…ƒç´ ï¼‰ï¼Œç„¶åå°†è¿™ä¸ªå…ƒç´ ä¸æ•°ç»„ç¬¬ ![i](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) ä¸ªä½ç½®ä¸Šçš„å…ƒç´ äº¤æ¢ã€‚

![selection-sort-1-animate-example](figures/selection-sort-1-animate-example-1684721214493-24-1684721216142-26.svg)

**é€‚ç”¨åœºæ™¯ï¼š**é€‰æ‹©æ’åºï¼ˆselection sortï¼‰ ä¹Ÿé€‚ç”¨äºå‘é‡ä¸åˆ—è¡¨ä¹‹ç±»çš„åºåˆ—ç»“æ„ã€‚

**ç¨³å®šæ€§ï¼š**ä¸ç¨³å®šã€‚

### 6.3.2 åŸºæœ¬æ€æƒ³

ä¸æ’å…¥æ’åºç±»ä¼¼ï¼Œ è¯¥ç®—æ³•ä¹Ÿå°†åºåˆ—åˆ’åˆ†ä¸ºæ— åºå‰ç¼€å’Œæœ‰åºåç¼€ä¸¤éƒ¨åˆ†ï¼›æ­¤å¤–ï¼Œè¿˜è¦æ±‚å‰ç¼€ä¸å¤§äºååç¼€ã€‚å¦‚æ­¤ï¼Œæ¯æ¬¡åªéœ€ä»å‰ç¼€ä¸­é€‰å‡ºæœ€å¤§è€…ï¼Œå¹¶ä½œä¸ºæœ€å°å…ƒç´ è½¬ç§»è‡³åç¼€ä¸­ï¼Œå³å¯ä½¿æœ‰åºéƒ¨åˆ†çš„èŒƒå›´ä¸æ–­æ‰©å¼ ã€‚

![image-20230522101936973](figures/image-20230522101936973.png)

### 6.3.4 ç¨³å®šæ€§åˆ†æ

**ç”±äº swapï¼ˆäº¤æ¢ä¸¤ä¸ªå…ƒç´ ï¼‰æ“ä½œçš„å­˜åœ¨ï¼Œé€‰æ‹©æ’åºæ˜¯ä¸€ç§ä¸ç¨³å®šçš„æ’åºç®—æ³•ã€‚**

ä¸Šè¿°æè¿°ä¹Ÿç»™å‡ºäº†é€‰æ‹©æ’åºç®—æ³•è¿‡ç¨‹æ‰€å…·æœ‰çš„ä¸å˜æ€§ï¼š

> åœ¨ä»»ä½•æ—¶åˆ»ï¼Œåç¼€`S[r, n)`å·²ç»æœ‰åºï¼Œä¸”ä¸å°äºå‰ç¼€`S[0, r)`
>

åœ¨ç®—æ³•çš„åˆå§‹æ—¶åˆ»ï¼Œåç¼€ä¸ºç©ºï¼Œä¸å˜æ€§è‡ªç„¶æ»¡è¶³ã€‚å¦‚å›¾3.6(a)æ‰€ç¤ºï¼Œå‡è®¾ä¸å˜æ€§å·²æ»¡è¶³ã€‚äºæ˜¯ï¼Œå¯è°ƒç”¨æ— åºåºåˆ—çš„æŸ¥æ‰¾ç®—æ³•ï¼Œ ä»å‰ç¼€ä¸­æ‰¾å‡ºæœ€å¤§è€…Mã€‚æ¥ä¸‹æ¥ï¼Œ åªéœ€å°†Mä»å‰ç¼€ä¸­å–å‡ºå¹¶ä½œä¸ºé¦–å…ƒç´ æ’å…¥åç¼€ï¼Œå³å¯å¦‚å›¾(b)æ‰€ç¤ºï¼Œä½¿å¾—åç¼€çš„èŒƒå›´æ‰©å¤§ï¼Œå¹¶ç»§ç»­ä¿æŒæœ‰åºã€‚å¦‚æ­¤ï¼Œè¯¥åç¼€çš„èŒƒå›´å¯ä¸æ–­æ‹“å±•ã€‚ å½“å…¶æœ€ç»ˆè¦†ç›–æ•´ä¸ªåºåˆ—æ—¶ï¼Œ äº¦å³æ•´ä½“æœ‰åºã€‚

### 6.3.5 å®ç°

![image-20230522102240505](figures/image-20230522102240505.png)

```c++
void selection_sort(int* a, int n) {
  for (int i = 1; i < n; ++i) {
    int ith = i;
    for (int j = i + 1; j <= n; ++j) {
      if (a[j] < a[ith]) {
        ith = j;
      }
    }
    std::swap(a[i], a[ith]);
  }
}
```

## 6.4 å°±åœ°å †æ’åº

### 6.4.1 å®šä¹‰

å †æ’åºï¼ˆè‹±è¯­ï¼šHeap sortï¼‰æ˜¯æŒ‡åˆ©ç”¨ [äºŒå‰å †](https://oi-wiki.org/ds/binary-heap/) è¿™ç§æ•°æ®ç»“æ„æ‰€è®¾è®¡çš„ä¸€ç§æ’åºç®—æ³•ï¼Œæœ¬è´¨æ˜¯å»ºç«‹åœ¨å †ä¸Šçš„é€‰æ‹©æ’åºã€‚

**é€‚ç”¨åœºæ™¯ï¼š**é€‚ç”¨äºå‘é‡ä¸åˆ—è¡¨ä¹‹ç±»çš„åºåˆ—ç»“æ„ã€‚

**ç¨³å®šæ€§ï¼š**åŒé€‰æ‹©æ’åºä¸€æ ·ï¼Œç”±äºå…¶ä¸­äº¤æ¢ä½ç½®çš„æ“ä½œï¼Œæ‰€ä»¥æ˜¯ä¸ç¨³å®šçš„æ’åºç®—æ³•ã€‚

### 6.4.2 åŸºæœ¬æ€æƒ³

ç®—æ³•çš„æ€»ä½“æ€è·¯å’Œç­–ç•¥ä¸é€‰æ‹©æ’åºç®—æ³•åŸºæœ¬ç›¸åŒï¼š**å°†æ‰€æœ‰è¯æ¡åˆ†æˆæœªæ’åºå’Œå·²æ’åºä¸¤ç±»ï¼Œä¸æ–­ä»å‰ä¸€ç±»ä¸­å–å‡ºæœ€å¤§è€…ï¼Œé¡ºåºåŠ è‡³åä¸€ç±»ä¸­ã€‚**ç®—æ³•å¯åŠ¨ä¹‹åˆï¼Œæ‰€æœ‰è¯æ¡å‡å±äºå‰ä¸€ç±»ï¼› æ­¤åï¼Œ åä¸€ç±»ä¸æ–­å¢é•¿ï¼›å½“æ‰€æœ‰è¯æ¡éƒ½å·²è½¬å…¥åä¸€ç±»æ—¶ï¼Œå³å®Œæˆæ’åºã€‚

è¿™é‡Œçš„å¾…æ’åºè¯æ¡æ—¢ç„¶å·²ç»„ç»‡ä¸ºå‘é‡ï¼Œä¸å¦¨å°†å…¶åˆ’åˆ†ä¸ºå‰ç¼€Hå’Œä¸ä¹‹äº’è¡¥çš„åç¼€Sï¼Œåˆ†åˆ«å¯¹åº”äºä¸Šè¿°æœªæ’åºå’Œå·²æ’åºéƒ¨åˆ†ã€‚ä¸å¸¸è§„é€‰æ‹©æ’åºç®—æ³•ä¸€æ ·ï¼Œåœ¨ç®—æ³•å¯åŠ¨ä¹‹åˆ`H`è¦†ç›–æ‰€æœ‰è¯æ¡ï¼Œè€Œ`S`ä¸ºç©ºã€‚æ–°ç®—æ³•çš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œæ•´ä¸ªæ’åºè¿‡ç¨‹ä¸­ï¼Œæ— è®ºHåŒ…å«å¤šå°‘è¯æ¡ï¼Œå§‹ç»ˆéƒ½ç»„ç»‡ä¸ºä¸€ä¸ªå †ã€‚å¦å¤–ï¼Œæ•´ä¸ªç®—æ³•è¿‡ç¨‹å§‹ç»ˆæ»¡è¶³å¦‚ä¸‹ä¸å˜æ€§ï¼š `H`ä¸­çš„æœ€å¤§è¯æ¡ä¸ä¼šå¤§äº`S`ä¸­çš„æœ€å°è¯æ¡â€”â€”é™¤éäºŒè€…ä¹‹ä¸€ä¸ºç©ºï¼Œæ¯”å¦‚ç®—æ³•çš„åˆå§‹å’Œç»ˆæ­¢æ—¶åˆ»ã€‚ ç®—æ³•çš„è¿­ä»£è¿‡ç¨‹å¦‚å›¾10.9æ‰€ç¤ºã€‚

![image-20230522102818539](figures/image-20230522102818539.png)

é¦–å…ˆå¦‚å›¾(a)ï¼Œå–å‡ºé¦–å•å…ƒè¯æ¡`M`ï¼Œå°†å…¶ä¸æœ«å•å…ƒè¯æ¡`X`äº¤æ¢ã€‚ `M`æ—¢æ˜¯å½“å‰å †ä¸­çš„æœ€å¤§è€…ï¼ŒåŒæ—¶æ ¹æ®ä¸å˜æ€§ä¹Ÿä¸å¤§äº`S`ä¸­çš„ä»»ä½•è¯æ¡ï¼Œæ•…å¦‚æ­¤äº¤æ¢ä¹‹å`M`å¿…å¤„äºæ­£ç¡®çš„æ’åºä½ç½®ã€‚ æ•…å¦‚å›¾(b)ï¼Œæ­¤æ—¶å¯ç­‰æ•ˆåœ°è®¤ä¸º`S`å‘å‰æ‰©å¤§äº†ä¸€ä¸ªå•å…ƒï¼Œ `H`ç›¸åº”åœ°ç¼©å°äº†ä¸€ä¸ªå•å…ƒã€‚è¯·æ³¨æ„ï¼Œå¦‚æ­¤é‡æ–°åˆ†ç•Œä¹‹åçš„`H`å’Œ`S`ä¾ç„¶æ»¡è¶³ä»¥ä¸Šä¸å˜æ€§ã€‚è‡³æ­¤ï¼Œå”¯ä¸€å°šæœªè§£å†³çš„é—®é¢˜æ˜¯ï¼Œè¯æ¡`X`é€šå¸¸ä¸èƒ½â€œèƒœä»»â€ å †é¡¶çš„è§’è‰²ã€‚

å¥½åœ¨è¿™å¹¶ééš¾äº‹ã€‚ä»¿ç…§è¯æ¡åˆ é™¤ç®—æ³•ï¼Œåªéœ€å¯¹`X`å®æ–½ä¸€æ¬¡ä¸‹æ»¤è°ƒæ•´ï¼Œå³å¯ä½¿`H`æ•´ä½“çš„å †åºæ€§é‡æ–°æ¢å¤ï¼Œç»“æœå¦‚å›¾(c)æ‰€ç¤ºã€‚å¥½åœ¨è¿™å¹¶ééš¾äº‹ã€‚ä»¿ç…§è¯æ¡åˆ é™¤ç®—æ³•ï¼Œåªéœ€å¯¹`X`å®æ–½ä¸€æ¬¡ä¸‹æ»¤è°ƒæ•´ï¼Œå³å¯ä½¿`H`æ•´ä½“çš„å †åºæ€§é‡æ–°æ¢å¤ï¼Œç»“æœå¦‚å›¾(c)æ‰€ç¤ºã€‚

### 6.4.3 å®ç°

```c++
void sift_down(int arr[], int start, int end) {				// ä¸‹æ»¤è°ƒæ•´ç®—æ³•
  // è®¡ç®—çˆ¶ç»“ç‚¹å’Œå­ç»“ç‚¹çš„ä¸‹æ ‡
  int parent = start;
  int child = parent * 2 + 1;
  while (child <= end) {  // å­ç»“ç‚¹ä¸‹æ ‡åœ¨èŒƒå›´å†…æ‰åšæ¯”è¾ƒ
    // å…ˆæ¯”è¾ƒä¸¤ä¸ªå­ç»“ç‚¹å¤§å°ï¼Œé€‰æ‹©æœ€å¤§çš„
    if (child + 1 <= end && arr[child] < arr[child + 1]) child++;
    // å¦‚æœçˆ¶ç»“ç‚¹æ¯”å­ç»“ç‚¹å¤§ï¼Œä»£è¡¨è°ƒæ•´å®Œæ¯•ï¼Œç›´æ¥è·³å‡ºå‡½æ•°
    if (arr[parent] >= arr[child])
      return;
    else {  // å¦åˆ™äº¤æ¢çˆ¶å­å†…å®¹ï¼Œå­ç»“ç‚¹å†å’Œå­™ç»“ç‚¹æ¯”è¾ƒ
      swap(arr[parent], arr[child]);
      parent = child;
      child = parent * 2 + 1;
    }
  }
}

void heap_sort(int arr[], int len) {
  // ä»æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹å¼€å§‹ sift down ä»¥å®Œæˆå †åŒ– (heapify)
  for (int i = (len - 1 - 1) / 2; i >= 0; i--) sift_down(arr, i, len - 1);
  // å…ˆå°†ç¬¬ä¸€ä¸ªå…ƒç´ å’Œå·²ç»æ’å¥½çš„å…ƒç´ å‰ä¸€ä½åšäº¤æ¢ï¼Œå†é‡æ–°è°ƒæ•´ï¼ˆåˆšè°ƒæ•´çš„å…ƒç´ ä¹‹å‰çš„å…ƒç´ ï¼‰ï¼Œç›´åˆ°æ’åºå®Œæ¯•
  for (int i = len - 1; i > 0; i--) {
    swap(arr[0], arr[i]);
    sift_down(arr, 0, i - 1);
  }
}

```

## 6.5 å†’ï¼ˆèµ·ï¼‰æ³¡æ’åº

### 6.5.1 å®šä¹‰

å†’æ³¡æ’åºï¼ˆè‹±è¯­ï¼šBubble sortï¼‰æ˜¯ä¸€ç§ç®€å•çš„æ’åºç®—æ³•ã€‚ç”±äºåœ¨ç®—æ³•çš„æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œè¾ƒå°çš„å…ƒç´ åƒæ˜¯æ°”æ³¡èˆ¬æ…¢æ…¢ã€Œæµ®ã€åˆ°æ•°åˆ—çš„é¡¶ç«¯ï¼Œæ•…å«åšå†’æ³¡æ’åºã€‚

**é€‚ç”¨åœºæ™¯ï¼š**é€‚ç”¨äºå‘é‡ä¸åˆ—è¡¨ä¹‹ç±»çš„åºåˆ—ç»“æ„ã€‚

**ç¨³å®šæ€§ï¼š**å†’æ³¡æ’åºæ˜¯ä¸€ç§ç¨³å®šçš„æ’åºç®—æ³•ã€‚èµ·æ³¡æ’åºç®—æ³•çš„ä¸å˜æ€§å’Œå•è°ƒæ€§å¯åˆ†åˆ«æ¦‚æ‹¬ä¸ºï¼š<span style="background:#FFDBBB;"> ç»è¿‡kè¶Ÿæ‰«æäº¤æ¢ä¹‹åï¼Œæœ€å¤§çš„å‰kä¸ªå…ƒç´ å¿…ç„¶å°±ä½ï¼›ç»è¿‡kè¶Ÿæ‰«æäº¤æ¢ä¹‹åï¼Œå¾…æ±‚è§£é—®é¢˜çš„æœ‰æ•ˆè§„æ¨¡å°†ç¼©å‡è‡³n - kã€‚  </span>

### 6.5.2 åŸºæœ¬æ€æƒ³

å®ƒçš„å·¥ä½œåŸç†æ˜¯æ¯æ¬¡æ£€æŸ¥ç›¸é‚»ä¸¤ä¸ªå…ƒç´ ï¼Œå¦‚æœå‰é¢çš„å…ƒç´ ä¸åé¢çš„å…ƒç´ æ»¡è¶³ç»™å®šçš„æ’åºæ¡ä»¶ï¼Œå°±å°†ç›¸é‚»ä¸¤ä¸ªå…ƒç´ äº¤æ¢ã€‚å½“æ²¡æœ‰ç›¸é‚»çš„å…ƒç´ éœ€è¦äº¤æ¢æ—¶ï¼Œæ’åºå°±å®Œæˆäº†ã€‚

ç»è¿‡ $i$ æ¬¡æ‰«æåï¼Œæ•°åˆ—çš„æœ«å°¾ $i$ é¡¹å¿…ç„¶æ˜¯æœ€å¤§çš„ $i$ é¡¹ï¼Œå› æ­¤å†’æ³¡æ’åºæœ€å¤šéœ€è¦æ‰«æ $n-1$ éæ•°ç»„å°±èƒ½å®Œæˆæ’åºã€‚

### 6.5.3 å±€éƒ¨æœ‰åºä¸æ•´ä½“æœ‰åº

åœ¨ç”±ä¸€ç»„æ•´æ•°ç»„æˆçš„åºåˆ—$A[0, n-1]$ä¸­ï¼Œæ»¡è¶³$A[i - 1] < A[i]$çš„ç›¸é‚»å…ƒç´ ç§°ä½œé¡ºåºçš„ï¼›å¦åˆ™æ˜¯é€†åºçš„ã€‚ä¸éš¾çœ‹å‡ºï¼Œæœ‰åºåºåˆ—ä¸­æ¯ä¸€å¯¹ç›¸é‚»å…ƒç´ éƒ½æ˜¯é¡ºåºçš„ï¼Œäº¦å³ï¼Œå¯¹ä»»æ„$1 â‰¤ i < n$éƒ½æœ‰$A[i - 1] < A[i]$ï¼›åä¹‹ï¼Œæ‰€æœ‰ç›¸é‚»å…ƒç´ å‡é¡ºåºçš„åºåˆ—ï¼Œä¹Ÿå¿…ç„¶æ•´ä½“æœ‰åºã€‚

### 6.5.4 æ‰«æäº¤æ¢

ç”±æœ‰åºåºåˆ—çš„ä¸Šè¿°ç‰¹å¾ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸æ–­æ”¹å–„å±€éƒ¨çš„æœ‰åºæ€§å®ç°æ•´ä½“çš„æœ‰åºï¼š**ä»å‰å‘åä¾æ¬¡æ£€æŸ¥æ¯ä¸€å¯¹ç›¸é‚»å…ƒç´ ï¼Œä¸€æ—¦å‘ç°é€†åºå³äº¤æ¢äºŒè€…çš„ä½ç½®ã€‚**å¯¹äºé•¿åº¦ä¸º`n`çš„åºåˆ—ï¼Œå…±éœ€åš`n-1`æ¬¡æ¯”è¾ƒå’Œä¸è¶…è¿‡`n-1`æ¬¡äº¤æ¢ï¼Œè¿™ä¸€è¿‡ç¨‹ç§°ä½œä¸€è¶Ÿæ‰«æäº¤æ¢ã€‚

![image-20230518213300256](figures/image-20230518213300256.png)

ä»¥å›¾1.3(a)ä¸­ç”±7ä¸ªæ•´æ•°ç»„æˆçš„åºåˆ—`A[0, 6] = { 5, 2, 7, 4, 6, 3, 1 }`ä¸ºä¾‹ã€‚åœ¨ç¬¬ä¸€è¶Ÿæ‰«æäº¤æ¢è¿‡ç¨‹ä¸­ï¼Œ `{ 5, 2 }`äº¤æ¢ä½ç½®ï¼Œ `{ 7, 4, 6, 3, 1 }`å¾ªç¯äº¤æ¢ä½ç½®ï¼Œæ‰«æäº¤æ¢åçš„ç»“æœå¦‚å›¾(b)æ‰€ç¤ºã€‚

### 6.5.5 å†’ï¼ˆèµ·ï¼‰æ³¡æ’åº

å¯è§ï¼Œç»è¿‡è¿™æ ·çš„ä¸€è¶Ÿæ‰«æï¼Œåºåˆ—æœªå¿…è¾¾åˆ°æ•´ä½“æœ‰åºã€‚æœçœŸå¦‚æ­¤ï¼Œåˆ™å¯å¯¹è¯¥åºåˆ—å†åšä¸€è¶Ÿæ‰«æäº¤æ¢ï¼Œæ¯”å¦‚ï¼Œå›¾(b)å†ç»ä¸€è¶Ÿæ‰«æäº¤æ¢çš„ç»“æœå¦‚å›¾(c)ã€‚äº‹å®ä¸Šï¼Œå¾ˆæœ‰å¯èƒ½å¦‚å›¾(c~f)æ‰€ç¤ºï¼Œ éœ€è¦åå¤è¿›è¡Œå¤šæ¬¡æ‰«æäº¤æ¢ï¼Œç›´åˆ°å¦‚å›¾(g)æ‰€ç¤ºï¼Œ åœ¨åºåˆ—ä¸­ä¸å†å«æœ‰ä»»ä½•é€†åºçš„ç›¸é‚»å…ƒç´ ã€‚å¤šæ•°çš„è¿™ç±»äº¤æ¢æ“ä½œï¼Œéƒ½ä¼šä½¿å¾—è¶Šå°ï¼ˆå¤§ï¼‰çš„å…ƒç´ æœä¸Šï¼ˆä¸‹ï¼‰æ–¹ç§»åŠ¨ï¼ˆä¹ é¢˜[1-3]ï¼‰ï¼Œç›´è‡³å®ƒä»¬æŠµè¾¾å„è‡ªåº”å¤„çš„ä½ç½®ã€‚
**æ’åºè¿‡ç¨‹ä¸­ï¼Œ æ‰€æœ‰å…ƒç´ æœå„è‡ªæœ€ç»ˆä½ç½®äº¦æ­¥äº¦è¶‹çš„ç§»åŠ¨è¿‡ç¨‹ï¼ŒçŠ¹å¦‚æ°”æ³¡åœ¨æ°´ä¸­çš„ä¸Šä¸‹æ²‰æµ®ï¼Œèµ·æ³¡æ’åºï¼ˆbubblesortï¼‰ ç®—æ³•ä¹Ÿå› æ­¤å¾—åã€‚**

### 6.5.6 å®ç°

![image-20230522104619562](figures/image-20230522104619562.png)

```c++
void bubblesort1A ( int A[], int n ) { 		//èµ·æ³¡æ’åºç®—æ³•ï¼ˆç‰ˆæœ¬1Aï¼‰ï¼š 0 <= n
	bool flag = true; 						//æ•´ä½“æ’åºæ ‡å¿—ï¼Œé¦–å…ˆå‡å®šå°šæœªæ’åº
	while ( !flag ) { 						//åœ¨å°šæœªç¡®è®¤å·²å…¨å±€æ’åºä¹‹å‰ï¼Œé€èººè¿›è¡Œæ‰«æäº¤æ¢
		sorted = true; 						//å‡å®šå·²ç»æ’åº
        for ( int i = 1; i < n; i++ ) { 	//è‡ªå·¦å‘å³é€å¯¹æ£€æŸ¥å½“å‰èŒƒå›´A[0, n)å†…çš„å„ç›¸é‚»å…ƒç´ 
            if ( A[i - 1] > A[i] ) { 		//ä¸€æ—¦A[i - 1]ä¸A[i]é€†åºï¼Œåˆ™
                swap ( A[i - 1], A[i] ); 	//äº¤æ¢ä¹‹ï¼Œå¹¶
                flag = false; 				//å› æ•´ä½“æ’åºä¸èƒ½ä¿è¯ï¼Œéœ€è¦æ¸…é™¤æ’åºæ ‡å¿—
            }
        }
		n--; 	//è‡³æ­¤æœ«å…ƒç´ å¿…ç„¶å°±ä½ï¼Œæ•…å¯ä»¥ç¼©çŸ­å¾…æ’åºåºåˆ—çš„æœ‰æ•ˆé•¿åº¦
	}
} //å€ŸåŠ©å¸ƒå°”å‹æ ‡å¿—ä½flagï¼Œå¯åŠæ—¶æå‰é€€å‡ºï¼Œè€Œä¸è‡³äºæ€»æ˜¯è›®åŠ›åœ°åšn - 1è¶Ÿæ‰«æäº¤æ¢
```

## 6.6 å¿«é€Ÿæ’åº

### 6.6.1 å®šä¹‰

å¿«é€Ÿæ’åºï¼ˆè‹±è¯­ï¼šQuicksortï¼‰ï¼Œåˆç§°åˆ†åŒºäº¤æ¢æ’åºï¼ˆè‹±è¯­ï¼špartition-exchange sortï¼‰ï¼Œç®€ç§°ã€Œå¿«æ’ã€ï¼Œæ˜¯ä¸€ç§è¢«å¹¿æ³›è¿ç”¨çš„æ’åºç®—æ³•ã€‚

ä¸å½’å¹¶æ’åºç®—æ³•ä¸€æ ·ï¼Œå¿«é€Ÿæ’åºï¼ˆquicksortï¼‰ ç®—æ³•ä¹Ÿæ˜¯åˆ†æ²»ç­–ç•¥çš„å…¸å‹åº”ç”¨ï¼Œä½†äºŒè€…ä¹‹é—´ä¹Ÿæœ‰æœ¬è´¨åŒºåˆ«ã€‚ 

å½’å¹¶æ’åºçš„è®¡ç®—é‡ä¸»è¦æ¶ˆè€—äºæœ‰åºå­å‘é‡çš„å½’å¹¶æ“ä½œï¼Œ è€Œå­å‘é‡çš„åˆ’åˆ†å´å‡ ä¹ä¸è´¹æ—¶é—´ã€‚å¿«é€Ÿæ’åºæ°å¥½ç›¸åï¼Œå®ƒå¯ä»¥åœ¨$O(1)$æ—¶é—´å†…ï¼Œ ç”±å­é—®é¢˜çš„è§£ç›´æ¥å¾—åˆ°åŸé—®é¢˜çš„è§£ï¼› ä½†ä¸ºäº†å°†åŸé—®é¢˜åˆ’åˆ†ä¸ºä¸¤ä¸ªå­é—®é¢˜ï¼Œ å´éœ€è¦$O(n)$æ—¶é—´ã€‚

å¿«é€Ÿæ’åºç®—æ³•è™½ç„¶èƒ½å¤Ÿç¡®ä¿ï¼Œåˆ’åˆ†å‡ºæ¥çš„å­ä»»åŠ¡å½¼æ­¤ç‹¬ç«‹ï¼Œå¹¶ä¸”å…¶è§„æ¨¡æ€»å’Œä¿æŒæ¸è¿›ä¸å˜ï¼Œå´ä¸èƒ½ä¿è¯ä¸¤ä¸ªå­ä»»åŠ¡çš„è§„æ¨¡å¤§ä½“ç›¸å½“â€”â€”å®é™…ä¸Šï¼Œ ç”šè‡³æœ‰å¯èƒ½æä¸å¹³è¡¡ã€‚å› æ­¤ï¼Œ è¯¥ç®—æ³•å¹¶ä¸èƒ½ä¿è¯æœ€åæƒ…å†µä¸‹çš„$O(nlogn)$æ—¶é—´å¤æ‚åº¦ã€‚å°½ç®¡å¦‚æ­¤ï¼Œå®ƒä»ç„¶å—åˆ°äººä»¬çš„é’çï¼Œå¹¶åœ¨å®é™…åº”ç”¨ä¸­å¾€å¾€æˆä¸ºé¦–é€‰çš„æ’åºç®—æ³•ã€‚ç©¶å…¶åŸå› åœ¨äºï¼Œå¿«é€Ÿæ’åºç®—æ³•æ˜“äºå®ç°ï¼Œä»£ç ç»“æ„ç´§å‡‘ç®€ç»ƒï¼Œè€Œä¸”å¯¹äºæŒ‰é€šå¸¸è§„å¾‹éšæœºåˆ†å¸ƒçš„è¾“å…¥åºåˆ—ï¼Œå¿«é€Ÿæ’åºç®—æ³•å®é™…çš„å¹³å‡è¿è¡Œæ—¶é—´è¾ƒä¹‹åŒç±»ç®—æ³•æ›´å°‘ã€‚

**é€‚ç”¨åœºæ™¯ï¼š**é€‚ç”¨äºåŒ…æ‹¬å‘é‡ä¸åˆ—è¡¨åœ¨å†…çš„ä»»ä½•åºåˆ—ç»“æ„ã€‚

**ç¨³å®šæ€§ï¼š**ä¸ç¨³å®šã€‚

### 6.6.2 åŸºæœ¬æ€æƒ³

å¿«é€Ÿæ’åºçš„å·¥ä½œåŸç†æ˜¯é€šè¿‡ [åˆ†æ²»](https://oi-wiki.org/basic/divide-and-conquer/) çš„æ–¹å¼æ¥å°†ä¸€ä¸ªæ•°ç»„æ’åºã€‚

å¿«é€Ÿæ’åºåˆ†ä¸ºä¸‰ä¸ªè¿‡ç¨‹ï¼š

1. å°†æ•°åˆ—åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼ˆè¦æ±‚ä¿è¯ç›¸å¯¹å¤§å°å…³ç³»ï¼‰ï¼›
2. é€’å½’åˆ°ä¸¤ä¸ªå­åºåˆ—ä¸­åˆ†åˆ«è¿›è¡Œå¿«é€Ÿæ’åºï¼›
3. ä¸ç”¨åˆå¹¶ï¼Œå› ä¸ºæ­¤æ—¶æ•°åˆ—å·²ç»å®Œå…¨æœ‰åºã€‚

å’Œå½’å¹¶æ’åºä¸åŒï¼Œç¬¬ä¸€æ­¥å¹¶ä¸æ˜¯ç›´æ¥åˆ†æˆå‰åä¸¤ä¸ªåºåˆ—ï¼Œè€Œæ˜¯åœ¨åˆ†çš„è¿‡ç¨‹ä¸­è¦ä¿è¯ç›¸å¯¹å¤§å°å…³ç³»ã€‚å…·ä½“æ¥è¯´ï¼Œç¬¬ä¸€æ­¥è¦æ˜¯è¦æŠŠæ•°åˆ—åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†ï¼Œç„¶åä¿è¯å‰ä¸€ä¸ªå­æ•°åˆ—ä¸­çš„æ•°éƒ½å°äºåä¸€ä¸ªå­æ•°åˆ—ä¸­çš„æ•°ã€‚ä¸ºäº†ä¿è¯å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼Œä¸€èˆ¬æ˜¯éšæœºé€‰æ‹©ä¸€ä¸ªæ•° $m$ æ¥å½“åšä¸¤ä¸ªå­æ•°åˆ—çš„åˆ†ç•Œã€‚

ä¹‹åï¼Œç»´æŠ¤ä¸€å‰ä¸€åä¸¤ä¸ªæŒ‡é’ˆ $p$ å’Œ $q$ ï¼Œä¾æ¬¡è€ƒè™‘å½“å‰çš„æ•°æ˜¯å¦æ”¾åœ¨äº†åº”è¯¥æ”¾çš„ä½ç½®ï¼ˆå‰è¿˜æ˜¯åï¼‰ã€‚å¦‚æœå½“å‰çš„æ•°æ²¡æ”¾å¯¹ï¼Œæ¯”å¦‚è¯´å¦‚æœåé¢çš„æŒ‡é’ˆ $q$ é‡åˆ°äº†ä¸€ä¸ªæ¯” $m$  å°çš„æ•°ï¼Œé‚£ä¹ˆå¯ä»¥äº¤æ¢ $p$ å’Œ $q$ ä½ç½®ä¸Šçš„æ•°ï¼Œå†æŠŠ $p$ å‘åç§»ä¸€ä½ã€‚å½“å‰çš„æ•°çš„ä½ç½®å…¨æ”¾å¯¹åï¼Œå†ç§»åŠ¨æŒ‡é’ˆç»§ç»­å¤„ç†ï¼Œç›´åˆ°ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡ã€‚

å…¶å®ï¼Œ**å¿«é€Ÿæ’åºæ²¡æœ‰æŒ‡å®šåº”å¦‚ä½•å…·ä½“å®ç°ç¬¬ä¸€æ­¥ï¼Œä¸è®ºæ˜¯é€‰æ‹© $m$ çš„è¿‡ç¨‹è¿˜æ˜¯åˆ’åˆ†çš„è¿‡ç¨‹ï¼Œéƒ½æœ‰ä¸æ­¢ä¸€ç§å®ç°æ–¹æ³•ã€‚**

ç¬¬ä¸‰æ­¥ä¸­çš„åºåˆ—å·²ç»åˆ†åˆ«æœ‰åºä¸”ç¬¬ä¸€ä¸ªåºåˆ—ä¸­çš„æ•°éƒ½å°äºç¬¬äºŒä¸ªæ•°ï¼Œæ‰€ä»¥ç›´æ¥æ‹¼æ¥èµ·æ¥å°±å¥½äº†ã€‚

### 6.6.3 è½´ç‚¹

![image-20230522105430349](figures/image-20230522105430349.png)

å¦‚å›¾12.1æ‰€ç¤ºï¼Œ è€ƒæŸ¥ä»»ä¸€å‘é‡åŒºé—´$S[lo, hi)$ã€‚å¯¹äºä»»ä½•$lo â‰¤ mi < hi$ï¼Œä»¥å…ƒç´ $S[mi]$ä¸ºç•Œï¼Œ éƒ½å¯åˆ†å‰²å‡ºå‰ã€åä¸¤ä¸ªå­å‘é‡$S[lo, mi)$å’Œ$S(mi, hi)$ã€‚è‹¥$S[lo, mi)$ä¸­çš„å…ƒç´ å‡ä¸å¤§äº$S[mi]$ï¼Œä¸”$S(mi, hi)$ä¸­çš„å…ƒç´ å‡ä¸å°äº$S[mi]$ï¼Œåˆ™å…ƒç´ $S[mi]$ç§°ä½œå‘é‡$S$çš„ä¸€ä¸ªè½´ç‚¹ï¼ˆpivotï¼‰ ã€‚è®¾å‘é‡$S$ç»æ’åºå¯è½¬åŒ–ä¸ºæœ‰åºå‘é‡$S'$ã€‚ä¸éš¾çœ‹å‡ºï¼Œè½´ç‚¹ä½ç½®$mi$å¿…ç„¶æ»¡è¶³å¦‚ä¸‹å……è¦æ¡ä»¶ï¼š

1. $S[mi] = S'[mi]$  
2. $S[lo, mi)$å’Œ$S'[lo, mi)$çš„æˆå‘˜å®Œå…¨ç›¸åŒ  
3. $S(mi, hi)$å’Œ$S'(mi, hi)$çš„æˆå‘˜å®Œå…¨ç›¸åŒ  

å› æ­¤ï¼Œä¸ä»…ä»¥è½´ç‚¹$S[mi]$ä¸ºç•Œï¼Œå‰ã€åå­å‘é‡çš„æ’åºå¯å„è‡ªç‹¬ç«‹åœ°è¿›è¡Œï¼Œè€Œä¸”æ›´é‡è¦çš„æ˜¯ï¼Œä¸€æ—¦å‰ã€åå­å‘é‡å„è‡ªå®Œæˆæ’åºï¼Œå³å¯ç«‹å³ï¼ˆåœ¨$O(1)$æ—¶é—´å†…ï¼‰å¾—åˆ°æ•´ä¸ªå‘é‡çš„æ’åºç»“æœã€‚
é‡‡ç”¨åˆ†æ²»ç­–ç•¥ï¼Œé€’å½’åœ°åˆ©ç”¨è½´ç‚¹çš„ä»¥ä¸Šç‰¹æ€§ï¼Œ ä¾¿å¯å®ŒæˆåŸå‘é‡çš„æ•´ä½“æ’åºã€‚

å› æ­¤ï¼ŒæŒ‰ç…§ä»¥ä¸Šæ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•åœ°å†™å‡ºå¿«é€Ÿæ’åºç®—æ³•çš„ä»£ç å¦‚ä¸‹ï¼š

```c++
template <typename T> //å‘é‡å¿«é€Ÿæ’åº
void Vector<T>::quickSort ( Rank lo, Rank hi ) { //0 <= lo < hi <= size
	if ( hi - lo < 2 ) return; //å•å…ƒç´ åŒºé—´è‡ªç„¶æœ‰åºï¼Œå¦åˆ™...
	Rank mi = partition ( lo, hi - 1 ); //åœ¨[lo, hi - 1]å†…æ„é€ è½´ç‚¹
	quickSort ( lo, mi ); //å¯¹å‰ç¼€é€’å½’æ’åº
	quickSort ( mi + 1, hi ); //å¯¹åç¼€é€’å½’æ’åº
}
```

å¯è§ï¼Œè½´ç‚¹çš„ä½ç½®ä¸€æ—¦ç¡®å®šï¼Œåˆ™åªéœ€ä»¥è½´ç‚¹ä¸ºç•Œï¼Œ åˆ†åˆ«é€’å½’åœ°å¯¹å‰ã€åå­å‘é‡å®æ–½å¿«é€Ÿæ’åºï¼›å­å‘é‡çš„æ’åºç»“æœå°±åœ°è¿”å›ä¹‹åï¼ŒåŸå‘é‡çš„æ•´ä½“æ’åºå³å‘Šå®Œæˆã€‚ç®—æ³•çš„æ ¸å¿ƒä¸å…³é”®åœ¨äºï¼š

<span style="background:#FFDBBB;">è½´ç‚¹æ„é€ ç®—æ³•`partition()`åº”å¦‚ä½•å®ç°ï¼Ÿå¯ä»¥è¾¾åˆ°å¤šé«˜çš„æ•ˆç‡ï¼Ÿ</span>

### 6.6.4 å¿«é€Ÿåˆ’åˆ†ç®—æ³•

ä¸ºåœ¨åŒºé—´$[lo, hi]$å†…æ„é€ å‡ºä¸€ä¸ªè½´ç‚¹ï¼Œ é¦–å…ˆéœ€è¦ä»»å–æŸä¸€å…ƒç´ $m$ä½œä¸ºâ€œåŸ¹å…»å¯¹è±¡â€ ã€‚  

![image-20230522110756947](figures/image-20230522110756947.png)

å¦‚å›¾12.3(a)æ‰€ç¤ºï¼Œ ä¸å¦¨å–é¦–å…ƒç´ $m = S[lo]$ä½œä¸ºå€™é€‰ï¼Œ å°†å…¶ä»å‘é‡ä¸­å–å‡ºå¹¶åšå¤‡ä»½ï¼Œè…¾å‡ºçš„ç©ºé—²å•å…ƒä¾¿äºå…¶å®ƒå…ƒç´ çš„ä½ç½®è°ƒæ•´ã€‚ ç„¶åå¦‚å›¾(b)æ‰€ç¤ºï¼Œä¸æ–­è¯•å›¾ç§»åŠ¨$lo$å’Œ$hi$ï¼Œ ä½¿ä¹‹ç›¸äº’é æ‹¢ã€‚å½“ç„¶ï¼Œæ•´ä¸ªç§»åŠ¨è¿‡ç¨‹ä¸­ï¼Œ éœ€å§‹ç»ˆä¿è¯$lo(hi)$å·¦ä¾§ï¼ˆå³ä¾§ï¼‰çš„å…ƒç´ å‡ä¸å¤§äºï¼ˆä¸å°äºï¼‰ $m$ã€‚
æœ€åå¦‚å›¾(c)æ‰€ç¤ºï¼Œå½“$lo$ä¸$hi$å½¼æ­¤é‡åˆæ—¶ï¼Œåªéœ€å°†åŸå¤‡ä»½çš„må›å¡«è‡³è¿™ä¸€ä½ç½®ï¼Œåˆ™$S[lo = hi]= m$ä¾¿æˆä¸ºä¸€ä¸ªåå‰¯å…¶å®çš„è½´ç‚¹ã€‚
ä»¥ä¸Šè¿‡ç¨‹åœ¨æ„é€ å‡ºè½´ç‚¹çš„åŒæ—¶ï¼Œä¹ŸæŒ‰ç…§ç›¸å¯¹äºè½´ç‚¹çš„å¤§å°å…³ç³»ï¼Œå°†åŸå‘é‡åˆ’åˆ†ä¸ºå·¦ã€å³ä¸¤ä¸ªå­å‘é‡ï¼Œæ•…äº¦ç§°ä½œå¿«é€Ÿåˆ’åˆ†ï¼ˆquick partitioningï¼‰ ç®—æ³•ã€‚

å®ç°å¦‚ä¸‹ï¼š

```c++
template <typename T> //è½´ç‚¹æ„é€ ç®—æ³•ï¼šé€šè¿‡è°ƒæ•´å…ƒç´ ä½ç½®æ„é€ åŒºé—´[lo, hi]çš„è½´ç‚¹ï¼Œå¹¶è¿”å›å…¶ç§©
Rank Vector<T>::partition ( Rank lo, Rank hi ) { //ç‰ˆæœ¬Aï¼šåŸºæœ¬å½¢å¼
	swap ( _elem[lo], _elem[lo + rand() % ( hi - lo + 1 ) ] ); //ä»»é€‰ä¸€ä¸ªå…ƒç´ ä¸é¦–å…ƒç´ äº¤æ¢
	T pivot = _elem[lo]; //ä»¥é¦–å…ƒç´ ä¸ºå€™é€‰è½´ç‚¹â€”â€”ç»ä»¥ä¸Šäº¤æ¢ï¼Œç­‰æ•ˆäºéšæœºé€‰å–
	while ( lo < hi ) { //ä»å‘é‡çš„ä¸¤ç«¯äº¤æ›¿åœ°å‘ä¸­é—´æ‰«æ
		while ( ( lo < hi ) && ( pivot <= _elem[hi] ) ) //åœ¨ä¸å°äºpivotçš„å‰æä¸‹
			hi--; //å‘å·¦æ‹“å±•å³ç«¯å­å‘é‡
		_elem[lo] = _elem[hi]; //å°äºpivotè€…å½’å…¥å·¦ä¾§å­åºåˆ—
		while ( ( lo < hi ) && ( _elem[lo] <= pivot ) ) //åœ¨ä¸å¤§äºpivotçš„å‰æä¸‹
			lo++; //å‘å³æ‹“å±•å·¦ç«¯å­å‘é‡
		_elem[hi] = _elem[lo]; //å¤§äºpivotè€…å½’å…¥å³ä¾§å­åºåˆ—
	} //assert: lo == hi
	_elem[lo] = pivot; //å°†å¤‡ä»½çš„è½´ç‚¹è®°å½•ç½®äºå‰ã€åå­å‘é‡ä¹‹é—´
	return lo; //è¿”å›è½´ç‚¹çš„ç§©
}
```

å¯è§ï¼Œç®—æ³•çš„ä¸»ä½“æ¡†æ¶ä¸ºå¾ªç¯è¿­ä»£ï¼›ä¸»å¾ªç¯çš„å†…éƒ¨ï¼Œé€šè¿‡ä¸¤è½®è¿­ä»£äº¤æ›¿åœ°ç§»åŠ¨$lo$å’Œ$hi$ã€‚

![image-20230522112113090](figures/image-20230522112113090.png)

å„è¿­ä»£çš„åˆå§‹çŠ¶æ€å¦‚å›¾12.4(a)æ‰€ç¤ºã€‚åå¤åœ°å°†å€™é€‰è½´ç‚¹$pivot$ä¸å½“å‰çš„$_elem[hi]$åšæ¯”è¾ƒï¼Œåªè¦å‰è€…ä¸å¤§äºåè€…ï¼Œ å°±ä¸æ–­å‘å·¦ç§»åŠ¨$hi$ï¼ˆé™¤é$hi$å³å°†è¶Šè¿‡$lo$ï¼‰ã€‚ $hi$æ— æ³•ç§»åŠ¨ç»§ç»­æ—¶ï¼Œå½“å¦‚å›¾(b)æ‰€ç¤ºã€‚äºæ˜¯æ¥ä¸‹æ¥å¦‚å›¾(c)æ‰€ç¤ºï¼Œå°†$_elem[hi]$è½¬ç§»è‡³$_elem[lo]$ï¼Œ å¹¶å½’å…¥å·¦ä¾§å­å‘é‡ã€‚
éšåå¯¹ç§°åœ°ï¼Œ å°†$_elem[lo]$ä¸$pivot$åšæ¯”è¾ƒï¼Œ åªè¦å‰è€…ä¸å¤§äºåè€…ï¼Œ å°±ä¸æ–­å‘å³ç§»åŠ¨$lo$ï¼ˆé™¤é$lo$å³å°†è¶Šè¿‡$hi$ï¼‰ã€‚ $lo$æ— æ³•ç»§ç»­ç§»åŠ¨æ—¶ï¼Œå½“å¦‚å›¾(d)æ‰€ç¤ºã€‚äºæ˜¯æ¥ä¸‹æ¥å¦‚å›¾(e)æ‰€ç¤ºï¼Œ å°†$_elem[lo]$è½¬ç§»è‡³$_elem[hi]$ï¼Œ å¹¶å½’å…¥å³ä¾§å­å‘é‡ã€‚
æ¯ç»è¿‡è¿™æ ·çš„ä¸¤è½®ç§»åŠ¨ï¼Œ$lo$ä¸$hi$çš„é—´è·éƒ½ä¼šç¼©çŸ­ï¼Œ æ•…è¯¥ç®—æ³•è¿Ÿæ—©ä¼šç»ˆæ­¢ã€‚å½“ç„¶ï¼Œ è‹¥å¦‚å›¾(e)æ‰€ç¤º$lo$ä¸$hi$ä»æœªé‡åˆï¼Œåˆ™å¯å†åšä¸¤è½®ç§»åŠ¨ã€‚ä¸éš¾éªŒè¯ï¼Œåœ¨ä»»ä¸€æ—¶åˆ»ï¼Œåœ¨ä»¥$lo$å’Œ$hi$ä¸ºç•Œçš„ä¸‰ä¸ªå­å‘é‡ä¸­ï¼Œ å·¦ã€å³å­å‘é‡åˆ†åˆ«æ»¡è¶³æ‰€åˆ—çš„è½´ç‚¹å……è¦æ¡ä»¶2)å’Œ3)ã€‚ è€Œéšç€ç®—æ³•çš„æŒç»­æ¨è¿›ï¼Œä¸­é—´å­å‘é‡çš„èŒƒå›´åˆ™ä¸æ–­å‹ç¼©ã€‚å½“ä¸»å¾ªç¯é€€å‡ºæ—¶$lo$å’Œ$hi$é‡åˆï¼Œå……è¦æ¡ä»¶1)ä¹Ÿéšå³æ»¡è¶³ã€‚ è‡³æ­¤ï¼Œåªéœ€å°†$pivot$â€œé•¶åµŒâ€ äºå·¦ã€å³å­å‘é‡ä¹‹é—´ï¼Œå³å®ç°äº†å¯¹åŸå‘é‡çš„ä¸€æ¬¡è½´ç‚¹åˆ’åˆ†ã€‚
è¯¥ç®—æ³•çš„è¿è¡Œæ—¶é—´çº¿æ€§æ­£æ¯”äºè¢«ç§»åŠ¨å…ƒç´ çš„æ•°ç›®ï¼Œçº¿æ€§æ­£æ¯”äºåŸå‘é‡çš„è§„æ¨¡$O(hi - lo)$ã€‚

ä¸€ä¸ªå®ä¾‹æ“ä½œæ­¥éª¤å¦‚ä¸‹ï¼š

![img](figures/quickSort.gif)

### 6.6.5 å®ç°

```c++
// å†™æ³•1
int Paritition1(int A[], int low, int high) {
    int pivot = A[low];
    while (low < high) {
        while (low < high && A[high] >= pivot) {
        	--high;
        }
        A[low] = A[high];
        while (low < high && A[low] <= pivot) {
        	++low;
        }
    	A[high] = A[low];
    }
    A[low] = pivot;
    return low;
}

void QuickSort(int A[], int low, int high) //å¿«æ’æ¯å‡½æ•°
{
    if (low < high) {
        int pivot = Paritition1(A, low, high);
        QuickSort(A, low, pivot - 1);
        QuickSort(A, pivot + 1, high);
    }
}

// å†™æ³•2
struct Range {
  int start, end;

  Range(int s = 0, int e = 0) { start = s, end = e; }
};

template <typename T>
void quick_sort(T arr[], const int len) {
  if (len <= 0) return;
  Range r[len];
  int p = 0;
  r[p++] = Range(0, len - 1);
  while (p) {
    Range range = r[--p];
    if (range.start >= range.end) continue;
    T mid = arr[range.end];
    int left = range.start, right = range.end - 1;
    while (left < right) {
      while (arr[left] < mid && left < right) left++;
      while (arr[right] >= mid && left < right) right--;
      std::swap(arr[left], arr[right]);
    }
    if (arr[left] >= arr[range.end])
      std::swap(arr[left], arr[range.end]);
    else
      left++;
    r[p++] = Range(range.start, left - 1);
    r[p++] = Range(left + 1, range.end);
  }
}
```

## 6.7 å½’å¹¶æ’åº

### 6.7.1 å®šä¹‰

å½’å¹¶æ’åºï¼ˆ[merge sort](https://en.wikipedia.org/wiki/Merge_sort)ï¼‰æ˜¯é«˜æ•ˆçš„åŸºäºæ¯”è¾ƒçš„ç¨³å®šæ’åºç®—æ³•ã€‚

å½’å¹¶æ’åºåŸºäºåˆ†æ²»æ€æƒ³å°†æ•°ç»„åˆ†æ®µæ’åºååˆå¹¶ï¼Œæ—¶é—´å¤æ‚åº¦åœ¨æœ€ä¼˜ã€æœ€åä¸å¹³å‡æƒ…å†µä¸‹å‡ä¸º$O(nlogn)$ï¼Œç©ºé—´å¤æ‚åº¦ä¸º$O(n)$ã€‚

å½’å¹¶æ’åºå¯ä»¥åªä½¿ç”¨$O(1)$çš„è¾…åŠ©ç©ºé—´ï¼Œä½†ä¸ºä¾¿æ·é€šå¸¸ä½¿ç”¨ä¸åŸæ•°ç»„ç­‰é•¿çš„è¾…åŠ©æ•°ç»„ã€‚

**é€‚ç”¨åœºæ™¯ï¼š**é€‚ç”¨äºåŒ…æ‹¬å‘é‡ä¸åˆ—è¡¨åœ¨å†…çš„ä»»ä½•åºåˆ—ç»“æ„ã€‚ï¼ˆå¾…è¡¥å……ï¼‰

**ç¨³å®šæ€§ï¼š**ä¸ç¨³å®šã€‚

### 6.7.2 åŸºæœ¬æ€æƒ³

å½’å¹¶æ’åºæœ€æ ¸å¿ƒçš„éƒ¨åˆ†æ˜¯**åˆå¹¶ï¼ˆmergeï¼‰è¿‡ç¨‹**ï¼šå°†ä¸¤ä¸ªæœ‰åºçš„æ•°ç»„ `a[i]` å’Œ `b[j]` åˆå¹¶ä¸ºä¸€ä¸ªæœ‰åºæ•°ç»„ `c[k]`ã€‚

1. ä»å·¦å¾€å³æšä¸¾ `a[i]` å’Œ `b[j]`ï¼Œæ‰¾å‡ºæœ€å°çš„å€¼å¹¶æ”¾å…¥æ•°ç»„ `c[k]`ï¼›
2. é‡å¤ä¸Šè¿°è¿‡ç¨‹ç›´åˆ° `a[i]` å’Œ `b[j]` æœ‰ä¸€ä¸ªä¸ºç©ºæ—¶ï¼Œå°†å¦ä¸€ä¸ªæ•°ç»„å‰©ä¸‹çš„å…ƒç´ æ”¾å…¥ `c[k]`ã€‚

ä¸ºä¿è¯æ’åºçš„ç¨³å®šæ€§ï¼Œå‰æ®µé¦–å…ƒç´ å°äºæˆ–ç­‰äºåæ®µé¦–å…ƒç´ æ—¶ï¼ˆ`a[i] <= b[j]`ï¼‰è€Œéå°äºæ—¶ï¼ˆ`a[i] < b[j]`ï¼‰å°±è¦ä½œä¸ºæœ€å°å€¼æ”¾å…¥ `c[k]`ã€‚

### 6.7.3 åˆå¹¶

æˆ‘ä»¬ä¸æ”¾å…ˆç»™å‡ºåˆå¹¶çš„å®ç°è¿‡ç¨‹ï¼š

```c++
template <typename T> //æœ‰åºå‘é‡çš„å½’å¹¶
void Vector<T>::merge(Rank lo, Rank mi, Rank hi){	// å„è‡ªæœ‰åºçš„å­å‘é‡[lo, mi)å’Œ[mi, hi)
    T* A = _elem + lo; //åˆå¹¶åçš„å‘é‡A[0, hi - lo) = _elem[lo, hi)
    int lb = mi - lo; T* B = new T[lb]; //å‰å­å‘é‡B[0, lb) = _elem[lo, mi)
    for ( Rank i = 0; i < lb; B[i] = A[i++] ); //å¤åˆ¶å‰å­å‘é‡
    int lc = hi - mi; T* C = _elem + mi; //åå­å‘é‡C[0, lc) = _elem[mi, hi)
	for ( Rank i = 0, j = 0, k = 0; ( j < lb ) || ( k < lc ); ) { //B[j]å’ŒC[k]ä¸­çš„å°è€…ç»­è‡³Aæœ«å°¾
    	if ( ( j < lb ) && ( ! ( k < lc ) || ( B[j] <= C[k] ) ) ) A[i++] = B[j++];
        if ( ( k < lc ) && ( ! ( j < lb ) || ( C[k] < B[j] ) ) ) A[i++] = C[k++];
    }
    delete [] B; //é‡Šæ”¾ä¸´æ—¶ç©ºé—´B
}//å½’å¹¶åå¾—åˆ°å®Œæ•´çš„æœ‰åºå‘é‡[lo, hi)



```

è¿™é‡Œçº¦å®šï¼Œå‚ä¸å½’å¹¶çš„å­å‘é‡åœ¨åŸå‘é‡ä¸­æ€»æ˜¯å‰ã€åç›¸é‚»çš„ï¼Œæ•…å€ŸåŠ©ä¸‰ä¸ªå…¥å£å‚æ•°å³å¯ç•Œå®šå…¶èŒƒå›´`[lo, mi)`å’Œ`[mi, hi)`ã€‚å¦å¤–ï¼Œä¸ºä¿è¯å½’å¹¶æ‰€å¾—çš„å­å‘é‡èƒ½å¤ŸåŸåœ°ä¿å­˜ä»¥ä¾¿ç»§ç»­å‚ä¸æ›´é«˜å±‚çš„å½’å¹¶ï¼Œè¿™é‡Œä½¿ç”¨äº†ä¸´æ—¶æ•°ç»„`B[]`å­˜æ”¾å‰ä¸€å‘é‡`[lo, mi)`çš„å‰¯æœ¬ã€‚

```c++
// æˆ–æ•°ç»„å†™æ³•
void merge(const int *a, size_t aLen, const int *b, size_t bLen, int *c) {
    size_t i = 0, j = 0, k = 0;
    while (i < aLen && j < bLen) {
    	if (b[j] < a[i]) {  // <!> å…ˆåˆ¤æ–­ b[j] < a[i]ï¼Œä¿è¯ç¨³å®šæ€§
    		c[k] = b[j];
    		++j;
    	} else {
    		c[k] = a[i];
            ++i;
            }
    	++k;
    }
  	// æ­¤æ—¶ä¸€ä¸ªæ•°ç»„å·²ç©ºï¼Œå¦ä¸€ä¸ªæ•°ç»„éç©ºï¼Œå°†éç©ºçš„æ•°ç»„å¹¶å…¥ c ä¸­
    for (; i < aLen; ++i, ++k) c[k] = a[i];
    for (; j < bLen; ++j, ++k) c[k] = b[j];
}

// æˆ–æŒ‡é’ˆå†™æ³•
void merge(const int *aBegin, const int *aEnd, const int *bBegin, const int *bEnd, int *c) {
    while (aBegin != aEnd && bBegin != bEnd) {
        if (*bBegin < *aBegin) {
            *c = *bBegin;
            ++bBegin;
        } else {
            *c = *aBegin;
            ++aBegin;
        }
    	++c;
    }
  	for (; aBegin != aEnd; ++aBegin, ++c) *c = *aBegin;
	for (; bBegin != bEnd; ++bBegin, ++c) *c = *bBegin;
}
```

> ä¹Ÿå¯ä½¿ç”¨ <algorithm> åº“çš„ merge å‡½æ•°ï¼Œç”¨æ³•ä¸ä¸Šè¿°æŒ‡é’ˆå¼å†™æ³•çš„ç›¸åŒã€‚

### 6.7.4 æœ‰åºå‘é‡çš„äºŒè·¯å½’å¹¶

ä¸èµ·æ³¡æ’åºé€šè¿‡åå¤è°ƒç”¨å•è¶Ÿæ‰«æäº¤æ¢ç±»ä¼¼ï¼Œå½’å¹¶æ’åºä¹Ÿå¯ä»¥ç†è§£ä¸ºæ˜¯é€šè¿‡**åå¤è°ƒç”¨**æ‰€è°“äºŒè·¯å½’å¹¶**ï¼ˆ2-way mergeï¼‰** ç®—æ³•è€Œå®ç°çš„ã€‚æ‰€è°“äºŒè·¯å½’å¹¶ï¼Œå°±æ˜¯å°†ä¸¤ä¸ªæœ‰åºåºåˆ—åˆå¹¶æˆä¸ºä¸€ä¸ªæœ‰åºåºåˆ—ã€‚è¿™é‡Œçš„åºåˆ—æ—¢å¯ä»¥æ˜¯å‘é‡ï¼Œ**è¿™é‡Œé¦–å…ˆè€ƒè™‘æœ‰åºå‘é‡**ã€‚ å½’å¹¶æ’åºæ‰€éœ€çš„æ—¶é—´ï¼Œ ä¹Ÿä¸»è¦å†³å®šäºå„è¶ŸäºŒè·¯å½’å¹¶æ‰€éœ€æ—¶é—´çš„æ€»å’Œã€‚

**äºŒè·¯å½’å¹¶å±äºè¿­ä»£å¼ç®—æ³•ã€‚**æ¯æ­¥è¿­ä»£ä¸­ï¼Œåªéœ€æ¯”è¾ƒä¸¤ä¸ªå¾…å½’å¹¶å‘é‡çš„é¦–å…ƒç´ ï¼Œå°†å°è€…å–å‡ºå¹¶è¿½åŠ åˆ°è¾“å‡ºå‘é‡çš„æœ«å°¾ï¼Œ è¯¥å…ƒç´ åœ¨åŸå‘é‡ä¸­çš„åç»§åˆ™æˆä¸ºæ–°çš„é¦–å…ƒç´ ã€‚ å¦‚æ­¤å¾€å¤ï¼Œç›´åˆ°æŸä¸€å‘é‡ä¸ºç©ºã€‚æœ€åï¼Œå°†å¦ä¸€éç©ºçš„å‘é‡æ•´ä½“æ¥è‡³è¾“å‡ºå‘é‡çš„æœ«å°¾ã€‚

å¦‚å›¾2.18(a)æ‰€ç¤ºï¼Œè®¾æ‹Ÿå½’å¹¶çš„æœ‰åºå‘é‡ä¸º`{ 5, 8, 13, 21 }`å’Œ`{ 2, 4, 10, 29 }`ã€‚

![image-20230518214416035](figures/image-20230518214416035.png)

ç¬¬ä¸€æ­¥è¿­ä»£ç»æ¯”è¾ƒï¼Œå–å‡ºå³ä¾§å‘é‡é¦–å…ƒç´ 2å¹¶å½’å…¥è¾“å‡ºå‘é‡ï¼ŒåŒæ—¶å…¶é¦–å…ƒç´ æ›´æ–°ä¸º4ï¼ˆå›¾(b)ï¼‰ã€‚æ­¤åå„æ­¥è¿­ä»£å‡ä¸æ­¤ç±»ä¼¼ï¼Œ éƒ½éœ€æ¯”è¾ƒé¦–å…ƒç´ ï¼Œå°†å°è€…å–å‡ºï¼Œå¹¶æ›´æ–°å¯¹åº”çš„é¦–å…ƒç´ ï¼ˆå›¾(c~h)ï¼‰ã€‚å¦‚æ­¤ï¼Œå³å¯æœ€ç»ˆå®ç°æ•´ä½“å½’å¹¶ï¼ˆå›¾(i)ï¼‰ã€‚
å¯è§ï¼ŒäºŒè·¯å½’å¹¶ç®—æ³•åœ¨ä»»ä½•æ—¶åˆ»åªéœ€è½½å…¥ä¸¤ä¸ªå‘é‡çš„é¦–å…ƒç´ ï¼Œ æ•…é™¤äº†å½’å¹¶è¾“å‡ºçš„å‘é‡å¤–ï¼Œä»…éœ€è¦å¸¸æ•°è§„æ¨¡çš„è¾…åŠ©ç©ºé—´ã€‚ å¦å¤–ï¼Œè¯¥ç®—æ³•å§‹ç»ˆä¸¥æ ¼åœ°æŒ‰é¡ºåºå¤„ç†è¾“å…¥å’Œè¾“å‡ºå‘é‡ï¼Œ æ•…ç‰¹åˆ«é€‚ç”¨äºä½¿ç”¨ç£å¸¦æœºç­‰é¡ºåºå­˜å‚¨å™¨çš„åœºåˆã€‚

### 6.7.5 åˆ†æ²»æ³•å®ç°å½’å¹¶æ’åº

å½’å¹¶æ’åºçš„ä¸»ä½“ç»“æ„å±å…¸å‹çš„åˆ†æ²»ç­–ç•¥ï¼Œå¯é€’å½’åœ°æè¿°å’Œå®ç°ï¼š

```c++
template <typename T> //å‘é‡å½’å¹¶æ’åº
void Vector<T>::mergeSort ( Rank lo, Rank hi ) { //0 <= lo < hi <= size
    if ( hi - lo < 2 ) return; //å•å…ƒç´ åŒºé—´è‡ªç„¶æœ‰åºï¼Œå¦åˆ™...
    int mi = ( lo + hi ) >> 1; 
    mergeSort ( lo, mi ); 
    mergeSort ( mi, hi ); //ä»¥ä¸­ç‚¹ä¸ºç•Œåˆ†åˆ«æ’åº
    merge ( lo, mi, hi ); //å½’å¹¶
}

// æˆ–æŒ‡é’ˆå½¢å¼
void merge_sort(int *a, int l, int r) {
    if (r - l <= 1) return;
    // åˆ†è§£
    int mid = l + ((r - l) >> 1);
    merge_sort(a, l, mid), merge_sort(a, mid, r);
    // åˆå¹¶
    int tmp[1024] = {};  	// è¯·ç»“åˆå®é™…æƒ…å†µè®¾ç½® tmp æ•°ç»„çš„é•¿åº¦ï¼ˆä¸ a ç›¸åŒï¼‰ï¼Œæˆ–ä½¿ç”¨
                   			// vectorï¼›å…ˆå°†åˆå¹¶çš„ç»“æœæ”¾åœ¨ tmp é‡Œï¼Œå†è¿”å›åˆ°æ•°ç»„ a
    merge(a + l, a + mid, a + mid, a + r, tmp + l);  // pointer-style merge
    for (int i = l; i < r; ++i) a[i] = tmp[i];
}

```

å¯è§ï¼Œ ä¸ºå°†å‘é‡`S[lo, hi)`è½¬æ¢ä¸ºæœ‰åºå‘é‡ï¼Œå¯ä»¥å‡åŒ€åœ°å°†å…¶åˆ’åˆ†ä¸ºä¸¤ä¸ªå­å‘é‡ï¼š

`S[lo, mi)`
`S[mi, hi)`

ä»¥ä¸‹ï¼Œåªè¦é€šè¿‡é€’å½’è°ƒç”¨å°†äºŒè€…åˆ†åˆ«è½¬æ¢ä¸ºæœ‰åºå‘é‡ï¼Œå³å¯å€ŸåŠ©ä»¥ä¸Šçš„äºŒè·¯å½’å¹¶ç®—æ³•ï¼Œå¾—åˆ°ä¸åŸå‘é‡Så¯¹åº”çš„æ•´ä¸ªæœ‰åºå‘é‡ã€‚
è¯·æ³¨æ„ï¼Œè¿™é‡Œçš„é€’å½’ç»ˆæ­¢æ¡ä»¶æ˜¯å½“å‰å‘é‡é•¿åº¦ï¼š
$$
n = hi - lo = 1
$$
æ—¢ç„¶ä»…å«å•ä¸ªå…ƒç´ çš„å‘é‡å¿…ç„¶æœ‰åºï¼Œè¿™ä¸€å¤„ç†åˆ†æ”¯è‡ªç„¶ä¹Ÿå°±å¯ä»¥ä½œä¸ºé€’å½’åŸºã€‚

### 6.7.6 å€å¢æ³•å®ç°å½’å¹¶æ’åº

å·²çŸ¥å½“æ•°ç»„é•¿åº¦ä¸º $1$ æ—¶ï¼Œè¯¥æ•°ç»„å°±å·²ç»æ˜¯æœ‰åºçš„ã€‚

å°†æ•°ç»„å…¨éƒ¨åˆ‡æˆé•¿åº¦ä¸º $1$ çš„æ®µã€‚

ä»å·¦å¾€å³ä¾æ¬¡åˆå¹¶ä¸¤ä¸ªé•¿åº¦ä¸º $1$ çš„æœ‰åºæ®µï¼Œå¾—åˆ°ä¸€ç³»åˆ—é•¿åº¦  $â‰¤2$ çš„æœ‰åºæ®µï¼›

ä»å·¦å¾€å³ä¾æ¬¡åˆå¹¶ä¸¤ä¸ªé•¿åº¦ $â‰¤2$ çš„æœ‰åºæ®µï¼Œå¾—åˆ°ä¸€ç³»åˆ—é•¿åº¦ $â‰¤4$ çš„æœ‰åºæ®µï¼›

ä»å·¦å¾€å³ä¾æ¬¡åˆå¹¶ä¸¤ä¸ªé•¿åº¦ $â‰¤4$ çš„æœ‰åºæ®µï¼Œå¾—åˆ°ä¸€ç³»åˆ—é•¿åº¦ $â‰¤8$ çš„æœ‰åºæ®µï¼›

â€¦â€¦

é‡å¤ä¸Šè¿°è¿‡ç¨‹ç›´è‡³æ•°ç»„åªå‰©ä¸€ä¸ªæœ‰åºæ®µï¼Œè¯¥æ®µå°±æ˜¯æ’å¥½åºçš„åŸæ•°ç»„ã€‚

> ä¸ºä»€ä¹ˆæ˜¯ $â‰¤n$ è€Œä¸æ˜¯ $==n$
>
> æ•°ç»„çš„é•¿åº¦å¾ˆå¯èƒ½ä¸æ˜¯ $2^x$ï¼Œæ­¤æ—¶åœ¨æœ€åå°±å¯èƒ½å‡ºç°é•¿åº¦ä¸å®Œæ•´çš„æ®µï¼Œå¯èƒ½å‡ºç°æœ€åä¸€ä¸ªæ®µæ˜¯ç‹¬ç«‹çš„æƒ…å†µã€‚

ä»£ç å®ç°å¦‚ä¸‹ï¼š

```c
void merge_sort(int *a, size_t n) {
	int tmp[1024] = {};  	// è¯·ç»“åˆå®é™…æƒ…å†µè®¾ç½® tmp æ•°ç»„çš„é•¿åº¦ï¼ˆä¸ a ç›¸åŒï¼‰ï¼Œæˆ–ä½¿ç”¨
							// vectorï¼›å…ˆå°†åˆå¹¶çš„ç»“æœæ”¾åœ¨ tmp é‡Œï¼Œå†è¿”å›åˆ°æ•°ç»„ a
	for (size_t seg = 1; seg < n; seg <<= 1) {
    for (size_t left1 = 0; left1 < n - seg; left1 += seg + seg) {  // n - seg: å¦‚æœæœ€ååªæœ‰ä¸€ä¸ªæ®µå°±ä¸ç”¨åˆå¹¶
        size_t right1 = left1 + seg;
        size_t left2 = right1;
        size_t right2 = std::min(left2 + seg, n);  // <!> æ³¨æ„æœ€åä¸€ä¸ªæ®µçš„è¾¹ç•Œ
        merge(a + left1, a + right1, a + left2, a + right2,
       		tmp + left1);  // pointer-style merge
      	for (size_t i = left1; i < right2; ++i) a[i] = tmp[i];
    }
  }
}
```

### 6.7.7 é€†åºå¯¹

é€†åºå¯¹æ˜¯ $i<j$ ä¸” $a_i<a_j$ çš„æœ‰åºæ•°å¯¹ $(i,j)$ ã€‚

æ’åºåçš„æ•°ç»„æ— é€†åºå¯¹ï¼Œå½’å¹¶æ’åºçš„åˆå¹¶æ“ä½œä¸­ï¼Œæ¯æ¬¡åæ®µé¦–å…ƒç´ è¢«ä½œä¸ºå½“å‰æœ€å°å€¼å–å‡ºæ—¶ï¼Œå‰æ®µå‰©ä½™å…ƒç´ ä¸ªæ•°ä¹‹å’Œå³æ˜¯åˆå¹¶æ“ä½œå‡å°‘çš„é€†åºå¯¹æ•°é‡ï¼›æ•…å½’å¹¶æ’åºè®¡ç®—é€†åºå¯¹æ•°é‡çš„é¢å¤–æ—¶é—´å¤æ‚åº¦ä¸º $O(nlogn)$ï¼Œå¯¹äº C/C++ ä»£ç å°† `merge` è¿‡ç¨‹çš„ `if(b[j] < a[i])` éƒ¨åˆ†åŠ ä¸Š `cnt += aLen - i` æˆ– `cnt += aEnd - aBegin` å³å¯ã€‚

æ­¤å¤–ï¼Œé€†åºå¯¹è®¡æ•°å³æ˜¯å°†å…ƒç´ ä¾æ¬¡åŠ å…¥æ•°ç»„æ—¶ç»Ÿè®¡å½“å‰å¤§äºå…¶çš„å…ƒç´ æ•°é‡ï¼Œå°†æ•°ç»„ç¦»æ•£åŒ–åå³æ˜¯åŒºé—´æ±‚å’Œé—®é¢˜ï¼Œä½¿ç”¨æ ‘çŠ¶æ•°ç»„æˆ–çº¿æ®µæ ‘è§£å†³çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(nlogn)$ä¸”ç©ºé—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

### 6.7.8 å®ç°

```c++
void merge(const int *aBegin, const int *aEnd, const int *bBegin, const int *bEnd, int *c) {
    while (aBegin != aEnd && bBegin != bEnd) {
        if (*bBegin < *aBegin) {
            *c = *bBegin;
            ++bBegin;
        } else {
            *c = *aBegin;
            ++aBegin;
        }
    	++c;
    }
  	for (; aBegin != aEnd; ++aBegin, ++c) *c = *aBegin;
	for (; bBegin != bEnd; ++bBegin, ++c) *c = *bBegin;
}

void merge_sort(int *a, int l, int r) {
    if (r - l <= 1) return;
    // åˆ†è§£
    int mid = l + ((r - l) >> 1);
    merge_sort(a, l, mid), merge_sort(a, mid, r);
    // åˆå¹¶
    int tmp[1024] = {};  	// è¯·ç»“åˆå®é™…æƒ…å†µè®¾ç½® tmp æ•°ç»„çš„é•¿åº¦ï¼ˆä¸ a ç›¸åŒï¼‰ï¼Œæˆ–ä½¿ç”¨
                   			// vectorï¼›å…ˆå°†åˆå¹¶çš„ç»“æœæ”¾åœ¨ tmp é‡Œï¼Œå†è¿”å›åˆ°æ•°ç»„ a
    merge(a + l, a + mid, a + mid, a + r, tmp + l);  // pointer-style merge
    for (int i = l; i < r; ++i) a[i] = tmp[i];
}
```

## 6.8 åŸºæ•°æ’åº

### 6.8.1 å®šä¹‰

åŸºæ•°æ’åºï¼ˆè‹±è¯­ï¼šRadix sortï¼‰æ˜¯ä¸€ç§éæ¯”è¾ƒå‹çš„æ’åºç®—æ³•ï¼Œæœ€æ—©ç”¨äºè§£å†³å¡ç‰‡æ’åºçš„é—®é¢˜ã€‚åŸºæ•°æ’åºå°†å¾…æ’åºçš„å…ƒç´ æ‹†åˆ†ä¸º $k$ ä¸ªå…³é”®å­—ï¼Œé€ä¸€å¯¹å„ä¸ªå…³é”®å­—æ’åºåå®Œæˆå¯¹æ‰€æœ‰å…ƒç´ çš„æ’åºã€‚

å¦‚æœæ˜¯ä»ç¬¬ $1$ å…³é”®å­—åˆ°ç¬¬ $k$ å…³é”®å­—é¡ºåºè¿›è¡Œæ¯”è¾ƒï¼Œåˆ™è¯¥åŸºæ•°æ’åºç§°ä¸º MSDï¼ˆMost Significant Digit first)åŸºæ•°æ’åºï¼›

å¦‚æœæ˜¯ä»ç¬¬ $k$ å…³é”®å­—åˆ°ç¬¬ $1$ å…³é”®å­—é¡ºåºè¿›è¡Œæ¯”è¾ƒï¼Œåˆ™è¯¥åŸºæ•°æ’åºç§°ä¸º LSDï¼ˆLeast Significant Digit first)åŸºæ•°æ’åºã€‚

**é€‚ç”¨åœºæ™¯ï¼š**é€‚ç”¨äºåŒ…æ‹¬å‘é‡ä¸åˆ—è¡¨åœ¨å†…çš„ä»»ä½•åºåˆ—ç»“æ„ï¼Œé€‚ç”¨äºéœ€è¦å­—å…¸åºæˆ–åŸºäºå…¶ä»–å…³é”®å­—çš„éè‡ªç„¶æ•°åºåˆ—çš„æ’åºï¼Œæ—¶é—´å¤æ‚åº¦éšç€ä½æ•°çš„çº¿æ€§å¢é•¿ï¼Œå› æ­¤å¯¹äºå°å‹æ•°æ®é›†çš„æ•ˆç‡ä¸é«˜ã€‚

**ç¨³å®šæ€§ï¼š**ç¨³å®šã€‚

### 6.8.2 å­—å…¸åº

å®é™…åº”ç”¨ç¯å¢ƒä¸­è¯æ¡çš„å…³é”®ç ï¼Œæœªå¿…éƒ½æ˜¯æ•´æ•°ã€‚æ¯”å¦‚ï¼Œ ä¸€ç§å¸¸è§çš„æƒ…å½¢æ˜¯ï¼Œå…³é”®ç ç”±å¤šä¸ªåŸŸï¼ˆå­—æ®µï¼‰ç»„åˆè€Œæˆï¼Œå¹¶é‡‡ç”¨æ‰€è°“çš„å­—å…¸åºï¼ˆlexicographical orderï¼‰ç¡®å®šå¤§å°æ¬¡åºï¼šä»»æ„ä¸¤ä¸ªå…³é”®ç ä¹‹é—´çš„å¤§å°å…³ç³»ï¼Œå–å†³äºå®ƒä»¬ç¬¬ä¸€ä¸ªäº’å¼‚çš„åŸŸã€‚

æ³¨æ„ï¼Œ åŒä¸€å…³é”®ç å†…å„å­—æ®µçš„ç±»å‹ä¹Ÿæœªå¿…ä¸€è‡´ã€‚ä¾‹å¦‚æ—¥æœŸå‹å…³é”®ç ï¼Œ å¯åˆ†è§£ä¸ºyearï¼ˆå¹´ï¼‰ã€monthï¼ˆæœˆï¼‰å’Œdayï¼ˆæ—¥ï¼‰ä¸‰ä¸ªæ•´æ•°å­—æ®µï¼Œå¹¶æŒ‰å¸¸è§„æƒ¯ä¾‹ï¼Œä»¥â€œå¹´-æœˆ-æ—¥â€çš„ä¼˜å…ˆçº§å®šä¹‰å­—å…¸åºã€‚

å†å¦‚æ‰‘å…‹ç‰Œæ‰€å¯¹åº”çš„å…³é”®ç ï¼Œå¯ä»¥åˆ†è§£ä¸ºæšä¸¾å‹çš„suiteï¼ˆèŠ±è‰²ï¼‰å’Œæ•´å‹çš„numberï¼ˆç‚¹æ•°ï¼‰ã€‚äºæ˜¯ï¼Œ è‹¥æŒ‰ç…§æ¡¥ç‰Œçš„çº¦å®šï¼Œä»¥â€œèŠ±è‰²-ç‚¹æ•°â€ä¸ºå­—å…¸åºï¼Œ åˆ™æ¯å‰¯ç‰Œéƒ½å¯æŒ‰å¤§å°æ’åˆ—ä¸ºï¼š

![image-20230522164926642](figures/image-20230522164926642.png)

ä¸»è¦éœ€è¦ç ”ç©¶çš„æ˜¯ï¼Œ å¯¹äºä»»æ„ä¸€ç»„æ­¤ç±»å…³é”®ç ï¼Œè¯¥å¦‚ä½•é«˜æ•ˆåœ°æ’åºã€‚

### 6.8.3 k - å…³é”®å­—å…ƒç´ çš„æ¯”è¾ƒ

ä¸‹é¢ç”¨ $a_i$ è¡¨ç¤ºå…ƒç´  $a$ çš„ç¬¬ $i$ å…³é”®å­—ã€‚

å‡å¦‚å…ƒç´ æœ‰ $k$ ä¸ªå…³é”®å­—ï¼Œå¯¹äºä¸¤ä¸ªå…ƒç´  $a$ å’Œ $b$ï¼Œé»˜è®¤çš„æ¯”è¾ƒæ–¹æ³•æ˜¯ï¼š

æ¯”è¾ƒä¸¤ä¸ªå…ƒç´ çš„ç¬¬ $1$ å…³é”®å­— $a_1$ å’Œ $b_1$ï¼Œå¦‚æœ $a_1$ < $b_1$ åˆ™ $a < b$ï¼Œå¦‚æœ $a_1$ > $b_1$ åˆ™ $a > b$ï¼Œå¦‚æœ $a_1 = b_1$ åˆ™è¿›è¡Œä¸‹ä¸€æ­¥ï¼›
æ¯”è¾ƒä¸¤ä¸ªå…ƒç´ çš„ç¬¬ $2$ å…³é”®å­— $a_2$ å’Œ $b_2$ï¼Œå¦‚æœ $a_2 < b_2$ åˆ™ $a < b$ï¼Œå¦‚æœ $a_2 > b_2$ åˆ™ $a > b$ï¼Œå¦‚æœ $a_2 = b_2$ åˆ™è¿›è¡Œä¸‹ä¸€æ­¥ï¼›
â€¦â€¦
æ¯”è¾ƒä¸¤ä¸ªå…ƒç´ çš„ç¬¬ $k$ å…³é”®å­— $a_k$ å’Œ $b_k$ï¼Œå¦‚æœ $a_k < b_k$ åˆ™ $a < b$ï¼Œå¦‚æœ $a_k > b_k$ åˆ™ $a > b$ï¼Œå¦‚æœ $a_k = b_k$ åˆ™ $a = b$ã€‚

ä¾‹å­ï¼š

- å¦‚æœå¯¹è‡ªç„¶æ•°è¿›è¡Œæ¯”è¾ƒï¼Œå°†è‡ªç„¶æ•°æŒ‰ä¸ªä½å¯¹é½åå¾€é«˜ä½è¡¥é½ $0$ï¼Œåˆ™ä¸€ä¸ªæ•°å­—ä»å·¦å¾€å³æ•°ç¬¬ $i$ ä½æ•°å°±å¯ä»¥ä½œä¸ºç¬¬ $i$ å…³é”®å­—ï¼›
- å¦‚æœå¯¹å­—ç¬¦ä¸²åŸºäºå­—å…¸åºè¿›è¡Œæ¯”è¾ƒï¼Œä¸€ä¸ªå­—ç¬¦ä¸²ä»å·¦å¾€å³æ•°ç¬¬ $i$ ä¸ªå­—ç¬¦å°±å¯ä»¥ä½œä¸ºç¬¬ $i$ å…³é”®å­—ï¼›
- C++ è‡ªå¸¦çš„ `std::pair` ä¸ `std::tuple` çš„é»˜è®¤æ¯”è¾ƒæ–¹æ³•ä¸ä¸Šè¿°çš„ç›¸åŒã€‚

### 6.8.4 MSD åŸºæ•°æ’åº

åŸºäº k - å…³é”®å­—å…ƒç´ çš„æ¯”è¾ƒæ–¹æ³•ï¼Œå¯ä»¥æƒ³åˆ°ï¼šå…ˆæ¯”è¾ƒæ‰€æœ‰å…ƒç´ çš„ç¬¬ $1$ å…³é”®å­—ï¼Œå°±å¯ä»¥ç¡®å®šå‡ºå„å…ƒç´ å¤§è‡´çš„å¤§å°å…³ç³»ï¼›ç„¶åå¯¹ å…·æœ‰ç›¸åŒç¬¬ $1$ å…³é”®å­—çš„å…ƒç´ ï¼Œå†æ¯”è¾ƒå®ƒä»¬çš„ç¬¬ $2$ å…³é”®å­—â€¦â€¦ä»¥æ­¤ç±»æ¨ã€‚

ç”±äºæ˜¯ä»ç¬¬ $1$ å…³é”®å­—åˆ°ç¬¬ $k$ å…³é”®å­—é¡ºåºè¿›è¡Œæ¯”è¾ƒï¼Œç”±ä¸Šè¿°æ€æƒ³å¯¼å‡ºçš„æ’åºç®—æ³•ç§°ä¸º MSDï¼ˆMost Significant Digit firstï¼‰åŸºæ•°æ’åºã€‚

#### 6.8.4.1 ç®—æ³•æµç¨‹

å°†å¾…æ’åºçš„å…ƒç´ æ‹†åˆ†ä¸º $k$ ä¸ªå…³é”®å­—ï¼Œå…ˆå¯¹ç¬¬ $1$ å…³é”®å­—è¿›è¡Œç¨³å®šæ’åºï¼Œç„¶åå¯¹äºæ¯ç»„ å…·æœ‰ç›¸åŒå…³é”®å­—çš„å…ƒç´  å†å¯¹ç¬¬ $2$ å…³é”®å­—è¿›è¡Œç¨³å®šæ’åºï¼ˆé€’å½’æ‰§è¡Œï¼‰â€¦â€¦æœ€åå¯¹äºæ¯ç»„å…·æœ‰ç›¸åŒå…³é”®å­—çš„å…ƒç´ ï¼Œå†å¯¹ç¬¬ $k$ å…³é”®å­—è¿›è¡Œç¨³å®šæ’åºã€‚

MSD åŸºæ•°æ’åºéœ€è¦å€ŸåŠ©ä¸€ç§ ç¨³å®šç®—æ³• å®Œæˆå†…å±‚å¯¹å…³é”®å­—çš„æ’åºï¼Œé€šå¸¸ä½¿ç”¨è®¡æ•°æ’åºæ¥å®Œæˆã€‚

æ­£ç¡®æ€§å‚è€ƒä¸Šæ–‡ k - å…³é”®å­—å…ƒç´ çš„æ¯”è¾ƒã€‚

#### 6.8.4.2 å®ç°

##### å¯¹è‡ªç„¶æ•°æ’åº

ä¸‹é¢æ˜¯ä½¿ç”¨è¿­ä»£å¼ MSD åŸºæ•°æ’åºå¯¹ `unsigned int` èŒƒå›´å†…å…ƒç´ è¿›è¡Œæ’åºçš„ C++ å‚è€ƒä»£ç ï¼Œå¯è°ƒæ•´ $W$ å’Œ $\log_2 W$ çš„å€¼ï¼ˆå»ºè®®å°† $\log_2 W$ è®¾ä¸º $2^k$ ä»¥ä¾¿ä½è¿ç®—ä¼˜åŒ–ï¼‰ã€‚

```c++
#include <algorithm>
#include <stack>
#include <tuple>
#include <vector>

using std::copy;  // from <algorithm>
using std::make_tuple;
using std::stack;
using std::tie;
using std::tuple;
using std::vector;

typedef unsigned int u32;
typedef unsigned int* u32ptr;

void MSD_radix_sort(u32ptr first, u32ptr last) {
  const size_t maxW = 0x100000000llu;
  const u32 maxlogW = 32;  // = log_2 W

  const u32 W = 256;  // è®¡æ•°æ’åºçš„å€¼åŸŸ
  const u32 logW = 8;
  const u32 mask = W - 1;  // ç”¨ä½è¿ç®—æ›¿ä»£å–æ¨¡ï¼Œè¯¦è§ä¸‹é¢çš„ key å‡½æ•°

  u32ptr tmp =
      (u32ptr)calloc(last - first, sizeof(u32));  // è®¡æ•°æ’åºç”¨çš„è¾“å‡ºç©ºé—´

  typedef tuple<u32ptr, u32ptr, u32> node;
  stack<node, vector<node>> s;
  s.push(make_tuple(first, last, maxlogW - logW));

  while (!s.empty()) {
    u32ptr begin, end;
    size_t shift, length;

    tie(begin, end, shift) = s.top();
    length = end - begin;
    s.pop();

    if (begin + 1 >= end) continue;  // elements <= 1

    // è®¡æ•°æ’åº
    u32 cnt[W] = {};
    auto key = [](const u32 x, const u32 shift) { return (x >> shift) & mask; };

    for (u32ptr it = begin; it != end; ++it) ++cnt[key(*it, shift)];
    for (u32 value = 1; value < W; ++value) cnt[value] += cnt[value - 1];

    // æ±‚å®Œå‰ç¼€å’Œåï¼Œè®¡ç®—ç›¸åŒå…³é”®å­—çš„å…ƒç´ èŒƒå›´
    if (shift >= logW) {
      s.push(make_tuple(begin, begin + cnt[0], shift - logW));
      for (u32 value = 1; value < W; ++value)
        s.push(make_tuple(begin + cnt[value - 1], begin + cnt[value],
                          shift - logW));
    }

    u32ptr it = end;
    do {
      --it;
      --cnt[key(*it, shift)];
      tmp[cnt[key(*it, shift)]] = *it;
    } while (it != begin);

    copy(tmp, tmp + length, begin);
  }
}

```

##### å¯¹å­—ç¬¦ä¸²æ’åº

ä¸‹é¢æ˜¯ä½¿ç”¨è¿­ä»£å¼ MSD åŸºæ•°æ’åºå¯¹ [ç©ºç»ˆæ­¢å­—èŠ‚å­—ç¬¦ä¸²](https://zh.cppreference.com/w/cpp/string/byte) åŸºäºå­—å…¸åºè¿›è¡Œæ’åºçš„ C++ å‚è€ƒä»£ç ï¼š

```c++
#include <algorithm>
#include <stack>
#include <tuple>
#include <vector>

using std::copy;  // from <algorithm>
using std::make_tuple;
using std::stack;
using std::tie;
using std::tuple;
using std::vector;

typedef char* NTBS;  // ç©ºç»ˆæ­¢å­—èŠ‚å­—ç¬¦ä¸²
typedef NTBS* NTBSptr;

void MSD_radix_sort(NTBSptr first, NTBSptr last) {
  const size_t W = 128;
  const size_t logW = 7;
  const size_t mask = W - 1;

  NTBSptr tmp = (NTBSptr)calloc(last - first, sizeof(NTBS));

  typedef tuple<NTBSptr, NTBSptr, size_t> node;
  stack<node, vector<node>> s;
  s.push(make_tuple(first, last, 0));

  while (!s.empty()) {
    NTBSptr begin, end;
    size_t index, length;

    tie(begin, end, index) = s.top();
    length = end - begin;
    s.pop();

    if (begin + 1 >= end) continue;  // elements <= 1

    // è®¡æ•°æ’åº
    size_t cnt[W] = {};
    auto key = [](const NTBS str, const size_t index) { return str[index]; };

    for (NTBSptr it = begin; it != end; ++it) ++cnt[key(*it, index)];
    for (char ch = 1; value < W; ++value) cnt[ch] += cnt[ch - 1];

    // æ±‚å®Œå‰ç¼€å’Œåï¼Œè®¡ç®—ç›¸åŒå…³é”®å­—çš„å…ƒç´ èŒƒå›´
    // å¯¹äº NTBSï¼Œå¦‚æœæ­¤åˆ»æœ«å°¾çš„å­—ç¬¦æ˜¯ \0 åˆ™è¯´æ˜è¿™ä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸ç­‰ï¼Œä¸å¿…ç»§ç»­è¿­ä»£
    for (char ch = 1; ch < W; ++ch)
      s.push(make_tuple(begin + cnt[ch - 1], begin + cnt[ch], index + 1));

    NTBSptr it = end;
    do {
      --it;
      --cnt[key(*it, index)];
      tmp[cnt[key(*it, index)]] = *it;
    } while (it != begin);

    copy(tmp, tmp + length, begin);
  }

  free(tmp);
}
```

ç”±äºä¸¤ä¸ªå­—ç¬¦ä¸²çš„æ¯”è¾ƒå¾ˆå®¹æ˜“å†²ä¸Š $O(n)$ çš„çº¿æ€§å¤æ‚åº¦ï¼Œå› æ­¤åœ¨å­—ç¬¦ä¸²æ’åºè¿™ä»¶äº‹æƒ…ä¸Šï¼ŒMSD åŸºæ•°æ’åºæ¯”å¤§å¤šæ•°åŸºäºæ¯”è¾ƒçš„æ’åºç®—æ³•åœ¨æ—¶é—´å¤æ‚åº¦å’Œå®é™…ç”¨æ—¶ä¸Šéƒ½æ›´åŠ ä¼˜ç§€ã€‚

#### 6.8.4.3 ä¸æ¡¶æ’åºçš„å…³ç³»

å‰ç½®çŸ¥è¯†ï¼š[æ¡¶æ’åº](https://oi-wiki.org/basic/bucket-sort/)

æ¡¶æ’åºéœ€è¦å…¶å®ƒçš„æ’åºç®—æ³•æ¥å®Œæˆå¯¹æ¯ä¸ªæ¡¶å†…éƒ¨å…ƒç´ çš„æ’åºã€‚ä½†å®é™…ä¸Šï¼Œå®Œå…¨å¯ä»¥å¯¹æ¯ä¸ªæ¡¶ç»§ç»­æ‰§è¡Œæ¡¶æ’åºï¼Œç›´è‡³æŸä¸€æ­¥æ¡¶çš„å…ƒç´ æ•°é‡ $\le 1$ã€‚

å› æ­¤ MSD åŸºæ•°æ’åºçš„å¦ä¸€ç§ç†è§£æ–¹å¼æ˜¯ï¼šä½¿ç”¨æ¡¶æ’åºå®ç°çš„æ¡¶æ’åºã€‚

ä¹Ÿå› æ­¤ï¼Œå¯ä»¥æå‡º MSD åŸºæ•°æ’åºåœ¨æ—¶é—´å¸¸æ•°ä¸Šçš„ä¸€ç§ä¼˜åŒ–æ–¹æ³•ï¼šå‡å¦‚åˆ°æŸä¸€æ­¥æ¡¶çš„å…ƒç´ æ•°é‡ $\le B$ï¼ˆ$B$ æ˜¯è‡ªå·±é€‰çš„å¸¸æ•°ï¼‰ï¼Œåˆ™ç›´æ¥æ‰§è¡Œæ’å…¥æ’åºç„¶åè¿”å›ï¼Œé™ä½é€’å½’æ¬¡æ•°ã€‚

### 6.8.5 LSD åŸºæ•°æ’åº

MSD åŸºæ•°æ’åºä»ç¬¬ $1$ å…³é”®å­—åˆ°ç¬¬ $k$ å…³é”®å­—é¡ºåºè¿›è¡Œæ¯”è¾ƒï¼Œä¸ºæ­¤éœ€è¦å€ŸåŠ©é€’å½’æˆ–è¿­ä»£æ¥å®ç°ï¼Œæ—¶é—´å¸¸æ•°è¿˜æ˜¯è¾ƒå¤§ï¼Œè€Œä¸”åœ¨æ¯”è¾ƒè‡ªç„¶æ•°ä¸Šè¿˜æ˜¯ç•¥æ˜¾ä¸ä¾¿ã€‚

è€Œå°†é€’å½’çš„æ“ä½œåè¿‡æ¥ï¼šä»ç¬¬ $k$ å…³é”®å­—åˆ°ç¬¬ $1$ å…³é”®å­—é¡ºåºè¿›è¡Œæ¯”è¾ƒï¼Œå°±å¯ä»¥å¾—åˆ° LSDï¼ˆLeast Significant Digit firstï¼‰åŸºæ•°æ’åºï¼Œä¸ä½¿ç”¨é€’å½’å°±å¯ä»¥å®Œæˆçš„æ’åºç®—æ³•ã€‚

#### 6.8.5.1 ç®—æ³•æµç¨‹

å°†å¾…æ’åºçš„å…ƒç´ æ‹†åˆ†ä¸º $k$ ä¸ªå…³é”®å­—ï¼Œç„¶åå…ˆå¯¹ æ‰€æœ‰å…ƒç´  çš„ç¬¬ $k$ å…³é”®å­—è¿›è¡Œç¨³å®šæ’åºï¼Œå†å¯¹ æ‰€æœ‰å…ƒç´  çš„ç¬¬ $k-1$ å…³é”®å­—è¿›è¡Œç¨³å®šæ’åºï¼Œå†å¯¹ æ‰€æœ‰å…ƒç´  çš„ç¬¬ $k-2$ å…³é”®å­—è¿›è¡Œç¨³å®šæ’åºâ€¦â€¦æœ€åå¯¹ æ‰€æœ‰å…ƒç´  çš„ç¬¬ $1$ å…³é”®å­—è¿›è¡Œç¨³å®šæ’åºï¼Œè¿™æ ·å°±å®Œæˆäº†å¯¹æ•´ä¸ªå¾…æ’åºåºåˆ—çš„ç¨³å®šæ’åºã€‚

![ä¸€ä¸ª LSD åŸºæ•°æ’åºå…¨æµç¨‹çš„ä¾‹å­](figures/radix-sort-1.png)

LSD åŸºæ•°æ’åºä¹Ÿéœ€è¦å€ŸåŠ©ä¸€ç§ ç¨³å®šç®—æ³• å®Œæˆå†…å±‚å¯¹å…³é”®å­—çš„æ’åºã€‚åŒæ ·çš„ï¼Œé€šå¸¸ä½¿ç”¨è®¡æ•°æ’åºæ¥å®Œæˆã€‚

LSD åŸºæ•°æ’åºçš„æ­£ç¡®æ€§å¯ä»¥å‚è€ƒ ã€Šç®—æ³•å¯¼è®ºï¼ˆç¬¬ä¸‰ç‰ˆï¼‰ã€‹ç¬¬ 8.3-3 é¢˜çš„è§£æ³• æˆ–å‚è€ƒä¸‹é¢çš„è§£é‡Šï¼š

#### 6.8.5.2 æ­£ç¡®æ€§

å›é¡¾ä¸€ä¸‹ k - å…³é”®å­—å…ƒç´ çš„æ¯”è¾ƒæ–¹æ³•ï¼Œ

- å‡å¦‚æƒ³é€šè¿‡ $a_1$ å’Œ $b_1$ å°±æ¯”è¾ƒå‡ºä¸¤ä¸ªå…ƒç´  $a$ å’Œ $b$ çš„å¤§å°ï¼Œåˆ™éœ€è¦æå‰çŸ¥é“é€šè¿‡æ¯”è¾ƒ $a_2$ å’Œ $b_2$ å¾—åˆ°çš„ç»“è®ºï¼Œä»¥ä¾¿äºåº”å¯¹ $a_1 = b_1$ çš„æƒ…å†µï¼›

- è€Œæƒ³é€šè¿‡ $a_2$ å’Œ $b_2$ å°±æ¯”è¾ƒå‡ºä¸¤ä¸ªå…ƒç´  $a$ å’Œ $b$ çš„å¤§å°ï¼Œåˆ™éœ€è¦æå‰çŸ¥é“é€šè¿‡æ¯”è¾ƒ $a_3$ å’Œ $b_3$ å¾—åˆ°çš„ç»“è®ºï¼Œä»¥ä¾¿äºåº”å¯¹ $a_2 = b_2$ çš„æƒ…å†µï¼›
- â€¦â€¦
- è€Œæƒ³é€šè¿‡ $a_{k-1}$ å’Œ $b_{k-1}$ å°±æ¯”è¾ƒå‡ºä¸¤ä¸ªå…ƒç´  $a$ å’Œ $b$ çš„å¤§å°ï¼Œåˆ™éœ€è¦æå‰çŸ¥é“é€šè¿‡æ¯”è¾ƒ $a_k$ å’Œ $b_k$ å¾—åˆ°çš„ç»“è®ºï¼Œä»¥ä¾¿äºåº”å¯¹ $a_{k-1} = b_{k-1}$ çš„æƒ…å†µï¼›
- $a_k$ å’Œ $b_k$ å¯ä»¥ç›´æ¥æ¯”è¾ƒã€‚

ç°åœ¨ï¼Œå°†é¡ºåºåè¿‡æ¥ï¼š

- $a_k$ å’Œ $b_k$ å¯ä»¥ç›´æ¥æ¯”è¾ƒï¼›
- è€ŒçŸ¥é“é€šè¿‡æ¯”è¾ƒ $a_k$ å’Œ $b_k$ å¾—åˆ°çš„ç»“è®ºåï¼Œå°±å¯ä»¥å¾—åˆ°æ¯”è¾ƒ $a_{k-1}$ å’Œ $b_{k-1}$ çš„ç»“è®ºï¼›
- â€¦â€¦
- è€ŒçŸ¥é“é€šè¿‡æ¯”è¾ƒ $a_2$ å’Œ $b_2$ å¾—åˆ°çš„ç»“è®ºåï¼Œå°±å¯ä»¥å¾—åˆ°æ¯”è¾ƒ $a_1$ å’Œ $b_1$ çš„ç»“è®ºï¼›
- è€ŒçŸ¥é“é€šè¿‡æ¯”è¾ƒ $a_1$ å’Œ $b_1$ å¾—åˆ°çš„ç»“è®ºåï¼Œå°±æœ€ç»ˆå¾—åˆ°äº†æ¯”è¾ƒ $a$ å’Œ $b$ çš„ç»“è®ºã€‚
- åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå¯¹æ¯ä¸ªå…³é”®å­—è¾¹æ¯”è¾ƒè¾¹é‡æ’å…ƒç´ çš„é¡ºåºï¼Œå°±å¾—åˆ°äº† LSD åŸºæ•°æ’åºã€‚

#### 6.8.5.3 å®ç°

![image-20230522172727342](figures/image-20230522172727342.png)

ä½¿ç”¨ LSD åŸºæ•°æ’åºå®ç°çš„å¯¹ k - å…³é”®å­—å…ƒç´ çš„æ’åºï¼ˆLSDçš„å¤šè¶Ÿæ¡¶æ’åºï¼‰ï¼š

```c++
const int N = 100010;
const int W = 100010;
const int K = 100;

int n, w[K], k, cnt[W];

struct Element {
  int key[K];

  bool operator<(const Element& y) const {
    // ä¸¤ä¸ªå…ƒç´ çš„æ¯”è¾ƒæµç¨‹
    for (int i = 1; i <= k; ++i) {
      if (key[i] == y.key[i]) continue;
      return key[i] < y.key[i];
    }
    return false;
  }
} a[N], b[N];

void counting_sort(int p) {
  memset(cnt, 0, sizeof(cnt));
  for (int i = 1; i <= n; ++i) ++cnt[a[i].key[p]];
  for (int i = 1; i <= w[p]; ++i) cnt[i] += cnt[i - 1];
  // ä¸ºä¿è¯æ’åºçš„ç¨³å®šæ€§ï¼Œæ­¤å¤„å¾ªç¯iåº”ä»nåˆ°1
  // å³å½“ä¸¤å…ƒç´ å…³é”®å­—çš„å€¼ç›¸åŒæ—¶ï¼ŒåŸå…ˆæ’åœ¨åé¢çš„å…ƒç´ åœ¨æ’åºåä»åº”æ’åœ¨åé¢
  for (int i = n; i >= 1; --i) b[cnt[a[i].key[p]]--] = a[i];
  memcpy(a, b, sizeof(a));
}

void radix_sort() {
  for (int i = k; i >= 1; --i) {
    // å€ŸåŠ©è®¡æ•°æ’åºå®Œæˆå¯¹å…³é”®å­—çš„æ’åº
    counting_sort(i);
  }
}

```

> å®é™…ä¸Šå¹¶éå¿…é¡»ä»åå¾€å‰æšä¸¾æ‰æ˜¯ç¨³å®šæ’åºï¼Œåªéœ€å¯¹ `cnt` æ•°ç»„è¿›è¡Œ**ç­‰ä»·äº `std::exclusive_scan`** çš„æ“ä½œå³å¯ã€‚

# Reference

æ­¤å¤„ä¸ºå‚è€ƒçš„æ–‡çŒ®æˆ–æ–‡æ¡£ï¼Œä½†å¾ˆå¤šå†…å®¹æ•£è½åœ¨æ–‡ç« ä¸­é—´äº†ï¼Œå¹¶ä¸èƒ½å¾ˆå¥½åœ°åšåˆ°æ•´ç†ï¼Œæ¬¢è¿prã€‚

- [Introduction - Algorithm-Pattern (gitbook.io)](https://mqjyl2012.gitbook.io/algorithm/)
- æ•°æ®ç»“æ„ï¼ˆC++è¯­è¨€ç‰ˆï¼‰	é‚“ä¿Šè¾‰ç¬¬ä¸‰ç‰ˆ
- [OI Wiki - OI Wiki (oi-wiki.org)](https://oi-wiki.org/)

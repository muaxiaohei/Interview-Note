# 0 åŸºç¡€çŸ¥è¯†ç‚¹

## 0.1 å¸¸ç”¨æ•°æ®ç»“æ„æ“ä½œçš„å¤æ‚åº¦

![img](figures/v2-820fa01be2dfcc080ec67d00ed9efd55_720w.jpg)

# 1 åŸºæœ¬è¾“å…¥è¾“å‡ºç»ƒä¹ 

[ç‰›å®¢ç«èµ›_ACM/NOI/CSP/CCPC/ICPCç®—æ³•ç¼–ç¨‹é«˜éš¾åº¦ç»ƒä¹ èµ›_ç‰›å®¢ç«èµ›OJ (nowcoder.com)](https://ac.nowcoder.com/acm/contest/5652#question)

## 1.1 A+B(1)

è®¡ç®—a+b

æ•°æ®èŒƒå›´ï¼š æ•°æ®ç»„æ•°$1â‰¤tâ‰¤100$ï¼Œæ•°æ®å¤§å°æ»¡è¶³ $1â‰¤nâ‰¤1000$
è¾“å…¥æè¿°:

```
è¾“å…¥åŒ…æ‹¬ä¸¤ä¸ªæ­£æ•´æ•°a,b(1 <= a, b <= 1000),è¾“å…¥æ•°æ®åŒ…æ‹¬å¤šç»„ã€‚
```

è¾“å‡ºæè¿°:

```
è¾“å‡ºa+bçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int m, n;
	while(cin >> m >> n)
	{
		cout << m + n << endl;
	}
	return 0;
}
```

## 1.2 A+B(2)

è®¡ç®—a+b

æ•°æ®èŒƒå›´ï¼šæ•°æ®ç»„æ•°æ»¡è¶³$1 <= t <= 100$ï¼Œæ•°æ®å¤§å°æ»¡è¶³ $1 <= a, b <= 1000$

è¾“å…¥æè¿°:

```
è¾“å…¥ç¬¬ä¸€è¡ŒåŒ…æ‹¬ä¸€ä¸ªæ•°æ®ç»„æ•°t(1 <= t <= 100)
æ¥ä¸‹æ¥æ¯è¡ŒåŒ…æ‹¬ä¸¤ä¸ªæ­£æ•´æ•°a,b(1 <= a, b <= 1000)
```

è¾“å‡ºæè¿°:

```
è¾“å‡ºa+bçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int line_num(0);
	int m(0), n(0);
	
	cin >> line_num;
	while(line_num--)
	{
		cin >> m >> n;
		cout << m + n << endl;
	}

	return 0;
}
```

## 1.3 A+B(3)

è®¡ç®—a+b

æ•°æ®èŒƒå›´ï¼šæ•°æ®ç»„æ•°æ»¡è¶³$1â‰¤tâ‰¤100$ï¼Œæ•°æ®å¤§å°æ»¡è¶³$1â‰¤nâ‰¤100$

è¾“å…¥æè¿°:

```
è¾“å…¥åŒ…æ‹¬ä¸¤ä¸ªæ­£æ•´æ•°a,b(1 <= a, b <= 10^9),è¾“å…¥æ•°æ®æœ‰å¤šç»„, å¦‚æœè¾“å…¥ä¸º0 0åˆ™ç»“æŸè¾“å…¥
```

è¾“å‡ºæè¿°:

```
è¾“å‡ºa+bçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>  
usingÂ namespaceÂ std;  
  
intÂ main()  
{  
Â Â Â Â intÂ m(0),Â n(0);  
  
Â Â Â Â while(1)  
Â Â Â Â {  
Â Â Â Â Â Â Â Â cinÂ >>Â mÂ >>Â n;  
Â Â Â Â Â Â Â Â if(mÂ ==Â 0Â andÂ nÂ ==Â 0)Â Â Â Â break;  
Â Â Â Â Â Â Â Â coutÂ <<Â mÂ +Â nÂ <<Â endl;  
Â Â Â Â }  
  
Â Â Â Â returnÂ 0;  
}
```

## 1.4 A+B(4)

è®¡ç®—ä¸€ç³»åˆ—æ•°çš„å’Œ

æ•°æ®èŒƒå›´ï¼šæ•°æ®ç»„æ•°æ»¡è¶³$1â‰¤tâ‰¤100$ï¼Œæ¯ç»„æ•°æ®ä¸­æ•´æ•°ä¸ªæ•°æ»¡è¶³ $1â‰¤nâ‰¤100$Â  ï¼Œæ¯ç»„æ•°æ®ä¸­çš„å€¼æ»¡è¶³ $1â‰¤valâ‰¤100$

è¾“å…¥æè¿°:

```
è¾“å…¥åŒ…æ‹¬ä¸¤ä¸ªæ­£æ•´æ•°a,b(1 <= a, b <= 10^9),è¾“å…¥æ•°æ®æœ‰å¤šç»„, å¦‚æœè¾“å…¥ä¸º0 0åˆ™ç»“æŸè¾“å…¥
```

è¾“å‡ºæè¿°:

```
è¾“å‡ºa+bçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
usingÂ namespaceÂ std;  
  
intÂ main()  
{  
Â Â Â Â intÂ n(0);  
Â Â Â Â intÂ temp(0);  
Â Â Â Â intÂ sum(0);  
  
Â Â Â Â while(1)  
Â Â Â Â {  
Â Â Â Â Â Â Â Â cinÂ >>Â n;  
Â Â Â Â Â Â Â Â if(nÂ ==Â 0)Â Â Â Â break;  
Â Â Â Â Â Â Â Â while(n--)  
Â Â Â Â Â Â Â Â {  
Â Â Â Â Â Â Â Â Â Â Â Â cinÂ >>Â temp;  
Â Â Â Â Â Â Â Â Â Â Â Â sumÂ +=Â temp;  
Â Â Â Â Â Â Â Â }  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â coutÂ <<Â sumÂ <<Â endl;  
Â Â Â Â Â Â Â Â sumÂ =Â 0;  
Â Â Â Â }  
  
Â Â Â Â returnÂ 0;  
}
```

## 1.5 A+B(5)

è®¡ç®—ä¸€ç³»åˆ—æ•°çš„å’Œ

æ•°æ®èŒƒå›´ï¼šæ•°æ®ç»„æ•°æ»¡è¶³$1â‰¤tâ‰¤100$ï¼Œæ¯ç»„æ•°æ®ä¸­æ•´æ•°ä¸ªæ•°æ»¡è¶³ $1â‰¤nâ‰¤100$Â  ï¼Œæ¯ç»„æ•°æ®ä¸­çš„å€¼æ»¡è¶³ $1â‰¤valâ‰¤100$

è¾“å…¥æè¿°:

```
è¾“å…¥çš„ç¬¬ä¸€è¡ŒåŒ…æ‹¬ä¸€ä¸ªæ­£æ•´æ•°t(1 <= t <= 100), è¡¨ç¤ºæ•°æ®ç»„æ•°ã€‚  
æ¥ä¸‹æ¥tè¡Œ, æ¯è¡Œä¸€ç»„æ•°æ®ã€‚  
æ¯è¡Œçš„ç¬¬ä¸€ä¸ªæ•´æ•°ä¸ºæ•´æ•°çš„ä¸ªæ•°n(1 <= n <= 100)ã€‚  
æ¥ä¸‹æ¥nä¸ªæ­£æ•´æ•°, å³éœ€è¦æ±‚å’Œçš„æ¯ä¸ªæ­£æ•´æ•°ã€‚
```

è¾“å‡ºæè¿°:

```
æ¯ç»„æ•°æ®è¾“å‡ºæ±‚å’Œçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int t(0);
	int n(0);
	int temp(0);
	int sum(0);

	cin >> t;
	while(t--)
	{
		cin >> n;
		if(n == 0)	break;
		while(n--)
		{
			cin >> temp;
			sum += temp;
		}
		
		cout << sum << endl;
		sum = 0;
	}

	return 0;
}
```

## 1.6 A+B(6)

è®¡ç®—ä¸€ç³»åˆ—æ•°çš„å’Œ

æ•°æ®èŒƒå›´ï¼š$1â‰¤nâ‰¤1000$ï¼Œæ‰€æœ‰æ•°éƒ½æ»¡è¶³ $1â‰¤valâ‰¤1000$

è¾“å…¥æè¿°:

```
è¾“å…¥æ•°æ®æœ‰å¤šç»„, æ¯è¡Œè¡¨ç¤ºä¸€ç»„è¾“å…¥æ•°æ®ã€‚
æ¯è¡Œçš„ç¬¬ä¸€ä¸ªæ•´æ•°ä¸ºæ•´æ•°çš„ä¸ªæ•°n(1 <= n <= 100)ã€‚
æ¥ä¸‹æ¥nä¸ªæ­£æ•´æ•°, å³éœ€è¦æ±‚å’Œçš„æ¯ä¸ªæ­£æ•´æ•°ã€‚
```

è¾“å‡ºæè¿°:

```
æ¯ç»„æ•°æ®è¾“å‡ºæ±‚å’Œçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int n(0);
	int temp(0);
	int sum(0);

	while(cin >> n)
	{
		if(n == 0)	break;
		while(n--)
		{
			cin >> temp;
			sum += temp;
		}
		
		cout << sum << endl;
		sum = 0;
	}

	return 0;
}
```

## 1.7 A+B(7)

è®¡ç®—ä¸€ç³»åˆ—æ•°çš„å’Œ

è¾“å…¥æè¿°:

```
è¾“å…¥æ•°æ®æœ‰å¤šç»„, æ¯è¡Œè¡¨ç¤ºä¸€ç»„è¾“å…¥æ•°æ®ã€‚

æ¯è¡Œä¸å®šæœ‰nä¸ªæ•´æ•°ï¼Œç©ºæ ¼éš”å¼€ã€‚(1 <= n <= 100)ã€‚
```

è¾“å‡ºæè¿°:

```
æ¯ç»„æ•°æ®è¾“å‡ºæ±‚å’Œçš„ç»“æœ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int temp(0);
	int sum(0);
	
	while(cin >> temp)		// é‡åˆ°ç©ºæ ¼æˆ–æ¢è¡Œç¬¦åœæ­¢
	{	
		sum += temp;
		if(getchar() == '\n')	// è¯»å–æ¢è¡Œç¬¦
		{
			cout << sum << endl;
			sum = 0;
		}
	}
	
	return 0;
}
```

## 1.8 å­—ç¬¦ä¸²æ’åº(1)

å¯¹è¾“å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œæ’åºåè¾“å‡º

è¾“å…¥æè¿°:

```
è¾“å…¥æœ‰ä¸¤è¡Œï¼Œç¬¬ä¸€è¡Œn
ç¬¬äºŒè¡Œæ˜¯nä¸ªå­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€
```

è¾“å‡ºæè¿°:

```
è¾“å‡ºä¸€è¡Œæ’åºåçš„å­—ç¬¦ä¸²ï¼Œç©ºæ ¼éš”å¼€ï¼Œæ— ç»“å°¾ç©ºæ ¼
```

ä»£ç ï¼š

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int main()
{
	vector<string> res;
	string temp;
	int size(0);
	
	cin >> size;
	while(size--)
	{
		cin >> temp;
		res.emplace_back(temp);
	}
	
	sort(res.begin(), res.end());
	for(auto s : res)
		cout << s << " ";
	
	return 0;
}
```

## 1.9 å­—ç¬¦ä¸²æ’åº(2)

å¯¹è¾“å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œæ’åºåè¾“å‡º

è¾“å…¥æè¿°:

```
å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ä¸€è¡Œã€‚
æ¯è¡Œé€šè¿‡ç©ºæ ¼éš”å¼€ï¼Œæœ‰nä¸ªå­—ç¬¦ï¼Œnï¼œ100
```

è¾“å‡ºæè¿°:

```
å¯¹äºæ¯ç»„æµ‹è¯•ç”¨ä¾‹ï¼Œè¾“å‡ºä¸€è¡Œæ’åºè¿‡çš„å­—ç¬¦ä¸²ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²é€šè¿‡ç©ºæ ¼éš”å¼€
```

ä»£ç ï¼š

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

int main()
{
	vector<string> res;
	string temp;
	
	while(cin >> temp)
	{
		res.emplace_back(temp);
		if(getchar() == '\n')
		{
			sort(res.begin(), res.end());
			for(auto s : res)
				cout << s << " ";
			cout << endl;
			
			res.clear();
		}
	}
	
	return 0;
}
```

## 1.10 å­—ç¬¦ä¸²æ’åº(3)

å¯¹è¾“å…¥çš„å­—ç¬¦ä¸²è¿›è¡Œæ’åºåè¾“å‡º

è¾“å…¥æè¿°:

```
å¤šä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹ä¸€è¡Œã€‚
æ¯è¡Œé€šè¿‡ç©ºæ ¼éš”å¼€ï¼Œæœ‰nä¸ªå­—ç¬¦ï¼Œnï¼œ100
```

è¾“å‡ºæè¿°:

```
å¯¹äºæ¯ç»„ç”¨ä¾‹è¾“å‡ºä¸€è¡Œæ’åºåçš„å­—ç¬¦ä¸²ï¼Œç”¨','éš”å¼€ï¼Œæ— ç»“å°¾ç©ºæ ¼
```

ä»£ç ï¼š

```c++
#include<iostream>
#include<algorithm>
#include<vector>
#include<sstream>
using namespace std;

int main()
{
	string s;
	
	while(getline(cin, s))
	{
		vector<string>buf;
		stringstream ss(s);
		string temp;
		while(getline(ss, temp, ','))
		{
			buf.push_back(temp);
		}
		sort(buf.begin(), buf.end());
		for(decltype(buf.size()) i = 0; i < buf.size()-1; i++)
		{
			cout << buf[i] << ",";
		}
		cout << buf.back() << endl;
		
	}
	return 0;
}
```

## 1.11 è‡ªæµ‹æœ¬åœ°é€šè¿‡æäº¤ä¸º0

æ¯å¹´å‰å‡ åœºåœ¨çº¿ç¬”è¯•ç¼–ç¨‹é¢˜çš„æ—¶å€™ï¼Œæ€»æœ‰åŒå­¦è¯¢é—®ä¸ºä»€ä¹ˆæˆ‘æœ¬åœ°æµ‹è¯•é€šè¿‡ï¼Œè‡ªæµ‹ä¹Ÿé€šè¿‡ï¼Œæäº¤ä»£ç ç³»ç»Ÿå´è¿”å›é€šè¿‡ç‡0ã€‚

è¿™ä¸æ˜¯ç³»ç»Ÿçš„é”™ï¼Œå¯èƒ½æ˜¯å› ä¸ºï¼š
1.ä½ å¯¹é¢˜ç›®ç†è§£é”™äº†ï¼Œä½ çš„ä»£ç åªè¿‡äº†æ ·ä¾‹æˆ–ä½ è‡ªå·±çš„æ•°æ®
2.ä½ çš„ä»£ç é€»è¾‘æœ‰é—®é¢˜ï¼Œä½ çš„ä»£ç åªè¿‡äº†æ ·ä¾‹æˆ–ä½ è‡ªå·±çš„æ•°æ®

æ€»ä¹‹å°±æ˜¯ä½ çš„ä»£ç åªæ˜¯è¿‡äº†æ ·ä¾‹å’Œè‡ªæµ‹æ•°æ®ï¼Œåå°çš„æµ‹è¯•æ•°æ®ä½ æ ¹æœ¬ä¸å¯è§ï¼Œè¦å¤šè‡ªå·±æ€è€ƒã€‚

è¿™ä¸ªé¢˜ç›®å¦‚æœä½ æäº¤åé€šè¿‡ç‡ä¸º0ï¼Œåˆè§‰å¾—è‡ªå·±ä»£ç æ˜¯æ­£ç¡®çš„ï¼Œå¯ä»¥ ç‚¹å‡»æŸ¥çœ‹ é€šè¿‡çš„ä»£ç 

è°¨è®°ï¼š
å½“ä½ ç¬”è¯•çš„æ—¶å€™æ€€ç–‘ç³»ç»Ÿæˆ–è€…é¢˜ç›®æ•°æ®æœ‰é—®é¢˜çš„æ—¶å€™è¯·åŠ¡å¿…å…ˆæ€€ç–‘è‡ªå·±çš„ä»£ç !

å½“ä½ ç¬”è¯•çš„æ—¶å€™æ€€ç–‘ç³»ç»Ÿæˆ–è€…é¢˜ç›®æ•°æ®æœ‰é—®é¢˜çš„æ—¶å€™è¯·åŠ¡å¿…å…ˆæ€€ç–‘è‡ªå·±çš„ä»£ç !

æ•°æ®èŒƒå›´ï¼š $0<a,b<2Ã—10^{10}$

è¾“å…¥æè¿°:

```
è¾“å…¥æœ‰å¤šç»„æµ‹è¯•ç”¨ä¾‹ï¼Œæ¯ç»„ç©ºæ ¼éš”å¼€ä¸¤ä¸ªæ•´æ•°
```

è¾“å‡ºæè¿°:

```
å¯¹äºæ¯ç»„æ•°æ®è¾“å‡ºä¸€è¡Œä¸¤ä¸ªæ•´æ•°çš„å’Œ
```

ä»£ç ï¼š

```c++
#include<iostream>
using namespace std;

int main()
{
	int temp(0);
	int sum(0);
	
	while(cin >> temp)		// é‡åˆ°ç©ºæ ¼æˆ–æ¢è¡Œç¬¦åœæ­¢
	{	
		sum += temp;
		if(getchar() == '\n')	// è¯»å–æ¢è¡Œç¬¦
		{
			cout << sum << endl;
			sum = 0;
		}
	}
	
	return 0;
}
```

# 2 é“¾è¡¨

## 2.1 åˆ é™¤å•é“¾è¡¨çš„é‡å¤èŠ‚ç‚¹

[é¢è¯•é¢˜ 02.01. ç§»é™¤é‡å¤èŠ‚ç‚¹ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/remove-duplicate-node-lcci/)

### 2.1.1 åŒæŒ‡é’ˆåŠ äºŒé‡å¾ªç¯

æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$ï¼Œå…¶ä¸­ $N$ æ˜¯ç»™å®šé“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®ã€‚

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) {
        ListNode* ob = head;
        while (ob != nullptr) {
            ListNode* oc = ob;
            while (oc->next != nullptr) {
                if (oc->next->val == ob->val) {
                    oc->next = oc->next->next;
                } else {
                    oc = oc->next;
                }
            }
            ob = ob->next;
        }
        return head;
    }
};
```

### 2.1.2 å“ˆå¸Œè¡¨

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­$N$æ˜¯ç»™å®šé“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°ç›®ã€‚

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ã€‚åœ¨æœ€åæƒ…å†µä¸‹ï¼Œç»™å®šé“¾è¡¨ä¸­æ¯ä¸ªèŠ‚ç‚¹éƒ½ä¸ç›¸åŒï¼Œå“ˆå¸Œè¡¨ä¸­éœ€è¦å­˜å‚¨æ‰€æœ‰çš„$N$ä¸ªå€¼ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* removeDuplicateNodes(ListNode* head) 
    {
        if (head == nullptr) return head;
        unordered_set<int> occurred = {head->val};
        ListNode* pos = head;
        // æšä¸¾å‰é©±èŠ‚ç‚¹
        while (pos->next != nullptr) {
            // å½“å‰å¾…åˆ é™¤èŠ‚ç‚¹
            ListNode* cur = pos->next;
            if (occurred.find(cur->val) == occurred.end()) {
                occurred.insert(cur->val);
                pos = pos->next;
            } else {
                pos->next = pos->next->next;
            }
        }
        pos->next = nullptr;
        return head;
    }
};
```

## 2.2 å¦‚ä½•æ‰¾å‡ºé“¾è¡¨çš„å€’æ•°ç¬¬Kä¸ªå…ƒç´ 

[å‰‘æŒ‡ Offer 22. é“¾è¡¨ä¸­å€’æ•°ç¬¬kä¸ªèŠ‚ç‚¹ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

### 2.2.1 å¿«æ…¢æŒ‡é’ˆæ³•

```c++
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode *p = head, *q = head; //åˆå§‹åŒ–
        while(k--) {   //å°† pæŒ‡é’ˆç§»åŠ¨ k æ¬¡
            p = p->next;
        }
        while(p != nullptr) {//åŒæ—¶ç§»åŠ¨ï¼Œç›´åˆ° p == nullptr
            p = p->next;
            q = q->next;
        }
        return q;
    }
};
```

### 2.2.2 æš´åŠ›è§£æ³•

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        ListNode *temp = head;
        int size = 0;

        while(temp)
        {
            temp = temp->next;
            ++size;
        }

        temp = head;
        size = size - k;
        while(size)
        {
            temp = temp->next;
            size--;
        }

        return temp;
    }
};
```

## 2.3 å¦‚ä½•æ‰¾å‡ºé“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹

[876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/middle-of-the-linked-list/)

### 2.3.1 æš´åŠ›è§£æ³•

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *temp = head;
        int size = 0;

        temp = head;
        while(temp)
        {
            temp = temp->next;
            ++size;
        }

        temp = head;
        size = size / 2;
        while(size)
        {
            --size;
            temp = temp->next;
        }

        return temp;
    }
};
```

### 2.3.2 å¿«æ…¢æŒ‡é’ˆ

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *fast = head, *slow = head;
        while (fast != nullptr && fast->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

## 2.4 åè½¬é“¾è¡¨ï¼ˆ206ï¼‰

[å‰‘æŒ‡ Offer 24. åè½¬é“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/)

### 2.4.1 é€’å½’

1. ä½¿ç”¨é€’å½’å‡½æ•°ï¼Œä¸€ç›´é€’å½’åˆ°é“¾è¡¨çš„æœ€åä¸€ä¸ªç»“ç‚¹ï¼Œè¯¥ç»“ç‚¹å°±æ˜¯åè½¬åçš„å¤´ç»“ç‚¹ï¼Œè®°ä½œ $ret$ï¼›
2. æ­¤åï¼Œæ¯æ¬¡å‡½æ•°åœ¨è¿”å›çš„è¿‡ç¨‹ä¸­ï¼Œè®©å½“å‰ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªç»“ç‚¹çš„  $next$ æŒ‡é’ˆæŒ‡å‘å½“å‰èŠ‚ç‚¹ï¼›
3. åŒæ—¶è®©å½“å‰ç»“ç‚¹çš„  $next$ æŒ‡é’ˆæŒ‡å‘ $nullptr$ï¼Œä»è€Œå®ç°ä»é“¾è¡¨å°¾éƒ¨å¼€å§‹çš„å±€éƒ¨åè½¬ï¼›
4. å½“é€’å½’å‡½æ•°å…¨éƒ¨å‡ºæ ˆåï¼Œé“¾è¡¨åè½¬å®Œæˆã€‚

![img](figures/8951bc3b8b7eb4da2a46063c1bb96932e7a69910c0a93d973bd8aa5517e59fc8.gif)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == nullptr || head->next == nullptr)
            return head;

        ListNode *current = head;
        ListNode *later = head->next;

        head = reverseList(later);
        later->next = current;
        current->next = nullptr;
        return head;
    }
};
```

### 2.4.5 åŒæŒ‡é’ˆ

1. å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆï¼š $pre$ å’Œ $cur$ ï¼›$pre$åœ¨å‰ $cur$åœ¨åã€‚
2. æ¯æ¬¡è®© $pre$çš„ $next$ æŒ‡å‘ $cur$ï¼Œå®ç°ä¸€æ¬¡å±€éƒ¨åè½¬
3. å±€éƒ¨åè½¬å®Œæˆä¹‹åï¼Œ $pre$å’Œ $cur$åŒæ—¶å¾€å‰ç§»åŠ¨ä¸€ä¸ªä½ç½®
4. å¾ªç¯ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´è‡³ $pre$åˆ°è¾¾é“¾è¡¨å°¾éƒ¨

![img](figures/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *cur = nullptr;
        ListNode *pre = head;
        
        while (pre != nullptr) {
            ListNode* t = pre->next;
            pre->next = cur;
            cur = pre;
            pre = t;
        }
        return cur;
    }
};
```

## 2.5 ç¯å½¢é“¾è¡¨

[141. ç¯å½¢é“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/linked-list-cycle/)

### 2.5.1 å¿«æ…¢æŒ‡é’ˆ

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$æ˜¯é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°ã€‚

å½“é“¾è¡¨ä¸­ä¸å­˜åœ¨ç¯æ—¶ï¼Œå¿«æŒ‡é’ˆå°†å…ˆäºæ…¢æŒ‡é’ˆåˆ°è¾¾é“¾è¡¨å°¾éƒ¨ï¼Œé“¾è¡¨ä¸­æ¯ä¸ªèŠ‚ç‚¹è‡³å¤šè¢«è®¿é—®ä¸¤æ¬¡ã€‚

å½“é“¾è¡¨ä¸­å­˜åœ¨ç¯æ—¶ï¼Œæ¯ä¸€è½®ç§»åŠ¨åï¼Œå¿«æ…¢æŒ‡é’ˆçš„è·ç¦»å°†å‡å°ä¸€ã€‚è€Œåˆå§‹è·ç¦»ä¸ºç¯çš„é•¿åº¦ï¼Œå› æ­¤è‡³å¤šç§»åŠ¨ $N$ è½®ã€‚

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚æˆ‘ä»¬åªä½¿ç”¨äº†ä¸¤ä¸ªæŒ‡é’ˆçš„é¢å¤–ç©ºé—´ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        // å¿«æ…¢æŒ‡é’ˆ
        ListNode * bike = head;
        ListNode * car = head;

        // å¾ªç¯å†… bike æ¯æ¬¡åç§»ä¸€ä¸ªç»“ç‚¹ï¼Œ car æ¯æ¬¡åç§» 2 ä¸ªç»“ç‚¹
        // car å’Œ car->next éœ€è¦ä¸ä¸ºç©ºï¼Œå¦åˆ™ä¼šå‘ç”Ÿéæ³•å†…å­˜è®¿é—®
        // car ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆ bike è‚¯å®šä¹Ÿä¸ä¸ºç©º
        while(car != nullptr && car->next != nullptr) 
        {
            bike = bike->next;
            car = car->next->next;

            if(car == bike) return true;
        }
        return false;
    }
};
```

### 2.5.2 å“ˆå¸Œè¡¨

**å¤æ‚åº¦åˆ†æ**

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°ã€‚æœ€åæƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦éå†æ¯ä¸ªèŠ‚ç‚¹ä¸€æ¬¡ã€‚

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œå…¶ä¸­ $N$ æ˜¯é“¾è¡¨ä¸­çš„èŠ‚ç‚¹æ•°ã€‚ä¸»è¦ä¸ºå“ˆå¸Œè¡¨çš„å¼€é”€ï¼Œæœ€åæƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦å°†æ¯ä¸ªèŠ‚ç‚¹æ’å…¥åˆ°å“ˆå¸Œè¡¨ä¸­ä¸€æ¬¡ã€‚

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_set<ListNode*> seen;
        while (head != nullptr) {
            if (seen.count(head)) {
                return true;
            }
            seen.insert(head);
            head = head->next;
        }
        return false;
    }
};
```

## 2.6 é“¾è¡¨ç›¸äº¤

[é¢è¯•é¢˜ 02.07. é“¾è¡¨ç›¸äº¤ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

### 2.6.1 åŒæŒ‡é’ˆ

å¤æ‚åº¦åˆ†æï¼š
æ—¶é—´å¤æ‚åº¦ $O(a+b)$ï¼š æœ€å·®æƒ…å†µä¸‹ï¼ˆå³ $âˆ£aâˆ’bâˆ£=1$ï¼Œ $c=0$ ï¼‰ï¼Œæ­¤æ—¶éœ€éå† $a+b$ ä¸ªèŠ‚ç‚¹ã€‚
ç©ºé—´å¤æ‚åº¦ $O(1)$ï¼š èŠ‚ç‚¹æŒ‡é’ˆ A , B ä½¿ç”¨å¸¸æ•°å¤§å°çš„é¢å¤–ç©ºé—´ã€‚

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *tempA(headA), *tempB(headB);

        while(tempA != tempB)
        {
            if(tempA == nullptr)    tempA = headB;
            else    tempA = tempA->next;

            if(tempB == nullptr)    tempB = headA;
            else    tempB = tempB->next;
        }

        return tempA;
    }
};

// æ›´ç®€æ´ä¸€ç‚¹
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *A = headA, *B = headB;
        while (A != B) {
            A = A != nullptr ? A->next : headB;
            B = B != nullptr ? B->next : headA;
        }
        return A;
    }
};
```

## 2.7 å›æ–‡é“¾è¡¨

[234. å›æ–‡é“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/palindrome-linked-list/)

### 2.7.1 æ ˆ

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        stack<int> s;
        int size(0), i(0);
        ListNode *temp(head);

        while(temp)
        {
            s.push(temp->val);
            temp = temp->next;
            ++size;
        }

        temp = head;
        while(temp)
        {
            if(temp->val != s.top())    return false;
            temp = temp->next;
            s.pop();
            ++i;
            if(i == size / 2)   return true;
        }

        return true;
    }
};
```

### 2.7.2 å¿«æ…¢æŒ‡é’ˆ

ç ´åäº†åŸé“¾è¡¨çš„ç»“æ„ã€‚

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(!head || !head->next)
            return 1;
        ListNode *fast = head, *slow = head;
        ListNode *p, *pre = NULL;
        while(fast && fast->next){
            p = slow;
            slow = slow->next;    //å¿«æ…¢éå†
            fast = fast->next->next;

            p->next = pre;  //ç¿»è½¬
            pre = p;
        }
        if(fast)  //å¥‡æ•°ä¸ªèŠ‚ç‚¹æ—¶è·³è¿‡ä¸­é—´èŠ‚ç‚¹
            slow = slow->next;

        while(p){       //å‰åŠéƒ¨åˆ†å’ŒååŠéƒ¨åˆ†æ¯”è¾ƒ
            if(p->val != slow->val)
                return 0;
            p = p->next;
            slow = slow->next;
        }
        return 1;
    }
};
```

## 2.8 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼ˆ21ï¼‰

[21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/merge-two-sorted-lists/)

### 2.8.1 è¿­ä»£

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode *list = new ListNode(0);
        ListNode *next = list;

        while(list1 && list2)
        {
            if(list1->val <= list2->val)
            {
                next->next = list1;
                list1 = list1->next;
            }
            else
            {
                next->next = list2;
                list2 = list2->next;
            }
            next = next->next;
        }

        // l1 æˆ– l2 å¯èƒ½è¿˜æœ‰å‰©ä½™ç»“ç‚¹æ²¡æœ‰åˆå¹¶ï¼Œ 
        // ç”±äºä»ä¸Šé¢çš„ while å¾ªç¯ä¸­é€€å‡ºï¼Œ é‚£ä¹ˆé“¾è¡¨ l1 å’Œ l2 è‡³å°‘æœ‰ä¸€ä¸ªå·²ç»éå†ç»“æŸ
        if(list1 != nullptr) next->next = list1;
        if(list2 != nullptr) next->next = list2;
        
        return list->next;
    }
};
```

### 2.8.2 é€’å½’

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if (l1 == NULL) {
            return l2;
        }
        if (l2 == NULL) {
            return l1;
        }
        if (l1->val <= l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
};
```

# 3 æ•°ç»„

## 3.1 æœ€å¤§å­æ•°ç»„å’Œï¼ˆ53ï¼‰

[53. æœ€å¤§å­æ•°ç»„å’Œ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/maximum-subarray/)

### 3.1.1 æš´åŠ›è§£æ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int sum(INT_MIN);
        int temp(0);

        for(int i = 0; i < nums.size(); ++i)
        {
            for(int j = i; j < nums.size(); ++j)
            {
                temp += nums.at(j);
                sum = sum > temp ? sum : temp;
            }
            temp = 0;
        }

        return sum;
    }
};
```

### 3.1.2 åˆ†æ²»

1. å–æ•°ç»„ä¸­å¿ƒç‚¹ä¸ºä¸­å¿ƒï¼›
2. æœ€å¤§å­åºè¦ä¹ˆå…¨åœ¨ä¸­å¿ƒå·¦è¾¹ï¼Œè¦ä¹ˆåœ¨å³è¾¹ï¼Œè¦ä¹ˆè·¨ä¸­å¿ƒï¼›
3. åˆ†ä¸‰ç§æƒ…å†µè¿›è¡Œè€ƒè™‘ è·¨ä¸­å¿ƒçš„æƒ…å†µï¼Œå†åˆ†æ²»æˆä¸­å¿ƒç‚¹å·¦ä¾§å’Œå³ä¾§çš„æœ€å¤§å­åºå’Œé—®é¢˜ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$O(Nlog(N))$

ç©ºé—´å¤æ‚åº¦ï¼š$O(log(N))$

![image-20230510093433295](figures/image-20230510093433295.png)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        return maxSubArrayHelper(nums, 0, nums.size() - 1);
    }

    int maxSubArrayHelper(vector<int>& nums, int left, int right)
    {
        if(left == right)   return nums[left];

        int center = (left + right) / 2;
        int leftMax = maxSubArrayHelper(nums, left, center);
        int rightMax = maxSubArrayHelper(nums, center + 1, right);

        int leftCrossMax = INT_MIN; // åˆå§‹åŒ–ä¸€ä¸ªå€¼
        int leftCrossSum = 0;
        for (int i = center ; i >= left ; i --) 
        {
            leftCrossSum += nums[i];
            leftCrossMax = max(leftCrossSum, leftCrossMax);
        }

        // è®¡ç®—åŒ…å«å³ä¾§å­åºåˆ—æœ€åä¸€ä¸ªå…ƒç´ çš„å­åºåˆ—æœ€å¤§å€¼
        int rightCrossMax = nums[center + 1];
        int rightCrossSum = 0;
        for (int i = center + 1; i <= right ; i ++) 
        {
            rightCrossSum += nums[i];
            rightCrossMax = max(rightCrossSum, rightCrossMax);
        }
        
        int crossMax = leftCrossMax + rightCrossMax;
        return max(crossMax, max(leftMax, rightMax));
    }
};
```

### 3.1.3 è´ªå¿ƒæ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution
{
public:
    int maxSubArray(vector<int> &nums)
    {
        //ç±»ä¼¼å¯»æ‰¾æœ€å¤§æœ€å°å€¼çš„é¢˜ç›®ï¼Œåˆå§‹å€¼ä¸€å®šè¦å®šä¹‰æˆç†è®ºä¸Šçš„æœ€å°æœ€å¤§å€¼
        int result = INT_MIN;
        int numsSize = int(nums.size());
        int sum = 0;
        for (int i = 0; i < numsSize; i++)
        {
            sum += nums[i];
            result = max(result, sum);
            //å¦‚æœsum < 0ï¼Œé‡æ–°å¼€å§‹æ‰¾å­åºä¸²
            if (sum < 0)
            {
                sum = 0;
            }
        }

        return result;
    }
};
```

### 3.1.4 åŠ¨æ€è§„åˆ’

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution
{
public:
    int maxSubArray(vector<int> &nums)
    {
        //ç±»ä¼¼å¯»æ‰¾æœ€å¤§æœ€å°å€¼çš„é¢˜ç›®ï¼Œåˆå§‹å€¼ä¸€å®šè¦å®šä¹‰æˆç†è®ºä¸Šçš„æœ€å°æœ€å¤§å€¼
        int result = INT_MIN;
        int numsSize = int(nums.size());

        int sum = nums[0];
        result = nums[0];
        for (int i = 1; i < numsSize; i++)
        {
            sum = max(sum + nums[i], nums[i]);
            result = max(result, sum);
        }

        return result;
    }
};
```

## 3.2 åŸåœ°ç§»é™¤å…ƒç´ ï¼ˆ27ï¼‰

[27. ç§»é™¤å…ƒç´  - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/remove-element/)

### 3.2.1 é€šç”¨è§£æ³•ï¼ˆåŒæŒ‡é’ˆï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;

        for(int i = 0; i < nums.size(); i++)
        {
            if(nums[i] != val)
            {
                nums[slow++] = nums[i];
            }
        }

        return slow;
    }
};
```

### 3.2.2 ä¼˜åŒ–åçš„åŒæŒ‡é’ˆ

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int left = 0, right = nums.size();
        while (left < right) {
            if (nums[left] == val) {
                nums[left] = nums[right - 1];
                right--;
            } else {
                left++;
            }
        }
        return left;
    }
};
```

## 3.3 åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ï¼ˆ88ï¼‰

[88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/merge-sorted-array/)

### 3.3.1 STLåº“

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        for(int i = 0; i < n; ++i)  nums1[m + i] = nums2[i];
        sort(nums1.begin(), nums1.begin() + m + n);
    }
};
```

### 3.3.2 ä»åé¢å¼€å§‹ç¡®å®š

æ—¶é—´å¤æ‚åº¦ï¼š$O(M+N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

å¦‚æœä¸¤ä¸ªæ•°ç»„ä»ç»“å°¾å‘å¼€å¤´ï¼ˆæ•°å­—ä»å¤§åˆ°å°ï¼‰è¿›è¡Œæ¯”è¾ƒï¼Œé‚£ä¹ˆæ¯æ¬¡æŠŠæ¯”è¾ƒä¹‹åçš„æ•°å­—æ”¾ç½®åˆ° nums1 ä¸­çš„åé¢ï¼Œç”±äºåé¢çš„æ•°å­—æœ¬èº«å°±æ˜¯æä¾›å‡ºæ¥çš„å¤šä½™çš„ä½ç½®ï¼Œéƒ½æ˜¯ 0ï¼Œå› æ­¤ä¸éœ€è¦å¯¹ nums1 è¿›è¡Œç§»åŠ¨ã€‚

1. å½“ $m > 0$ å¹¶ä¸” $n > 0 $ æ—¶ï¼Œä»åå‘å‰æ¯”è¾ƒ  $num1[mâˆ’1]$ å’Œ  $nums2[nâˆ’1] $ ï¼š
   - å¦‚æœæ˜¯  $nums1[mâˆ’1]$ å¤§ï¼Œåˆ™æŠŠ   $num1[mâˆ’1]$ æ”¾åˆ° $num1$ çš„ç¬¬ $m+nâˆ’1$ ä½ç½®ï¼Œå¹¶è®© $m-=1$ã€‚
   - å¦‚æœæ˜¯ $nums2[nâˆ’1] $ å¤§ï¼Œåˆ™æŠŠ $nums2[nâˆ’1]$ æ”¾åˆ° $num1$ çš„ç¬¬ $m+nâˆ’1$ ä½ç½®ï¼Œå¹¶è®© $n-=1$ã€‚
2. å½“ä¸Šé¢çš„éå†æ¡ä»¶ç»“æŸçš„æ—¶å€™ï¼Œæ­¤æ—¶ m å’Œ n è‡³å°‘æœ‰ä¸€ä¸ªä¸º 0ã€‚
   - å½“ $m == 0$ æ—¶ï¼Œè¯´æ˜ num1 çš„æ•°å­—æ°å¥½ç”¨å®Œäº†ï¼Œæ­¤æ—¶ nums2 å¯èƒ½è¿˜å‰©å…ƒç´ ï¼Œéœ€è¦å¤åˆ¶åˆ° nums1 çš„å¤´éƒ¨ï¼›
   - å½“ $n == 0$ æ—¶ï¼Œè¯´æ˜ num2 çš„æ•°å­—æ°å¥½ç”¨å®Œäº†ï¼Œæ­¤æ—¶ nums1 å¯èƒ½è¿˜å‰©å…ƒç´ ï¼Œç”±äºå‰©ä½™çš„è¿™äº›å…ƒç´ ä¸€å®šæ˜¯ nums1 å’Œ nums2 ä¸­æœ€å°çš„å…ƒç´ ï¼Œæ‰€ä»¥ä¸ç”¨åŠ¨ï¼Œç›´æ¥ç•™åœ¨åŸåœ°å°±è¡Œã€‚

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int k = m + n - 1;
        while (m > 0 && n > 0) {
            if (nums1[m - 1] > nums2[n - 1]) {
                nums1[k] = nums1[m - 1];
                m --;
            } else {
                nums1[k] = nums2[n - 1];
                n --;
            }
            k --;
        }
        for (int i = 0; i < n; ++i) {
            nums1[i] = nums2[i];
        }
    }
};
```

### 3.3.3 ä»å‰é¢å¼€å§‹ç¡®å®šï¼ˆå½’å¹¶æ’åºï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(M+N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(M+N)$

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {   
        vector<int> temp(nums1);       //åˆå§‹åŒ–mä¸ºnums1çš„æ‹·è´
        int i = 0, j = 0, k = 0;

        while(i <= m-1 && j <= n-1)
        {
            if(temp[i] < nums2[j])                nums1[k++] = temp[i++];
            else               nums1[k++] = nums2[j++];
        }
        while(i <= m-1)         
        {
            nums1[n+i] = temp[i];
            i++;
        }
         while(j <= n-1)
        {
            nums1[m+j] = nums2[j];
            j++;
        }

    }
};
```

## 3.4 æŸ¥æ‰¾å…±ç”¨å­—ç¬¦ï¼ˆ1002ï¼‰

[1002. æŸ¥æ‰¾å…±ç”¨å­—ç¬¦ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/find-common-characters/)

### 3.4.1 åˆ©ç”¨æ•°ç»„æ±‚è§£

```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& A) {
        vector<string> out;
        int num[100][26]={0};                  //å»ºç«‹ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œæ ‡è®°æ‰€æœ‰å‡ºç°çš„å­—æ¯æ¬¡æ•°
        for(int i =0;i<A.size() ;i++)
            for(int j=0;j<A[i].size();j++)
                num[i][(A[i][j]-'a')]++;
        
        for(int j=0;j<26;j++)                  //å°†æ‰€æœ‰åˆ—çš„æœ€å°å€¼å­˜åˆ°ç¬¬ä¸€è¡Œ
            for(int i=1;i<A.size();i++)
                num[0][j] = min (num[0][j],num[i][j]);
                    
        string str;                           //æŒ‰ç…§ç¬¬ä¸€è¡Œä¿å­˜çš„æ¬¡æ•°è¾“å‡ºç›¸åº”å­—æ¯
        for(int i=0;i<26;i++){
            while(num[0][i]--)
            {
                str.clear();
                str.push_back((char)('a'+i));
                out.push_back(str);
            }
        }
        return out;
    }
};

```

### 3.4.2 å“ˆå¸Œ

```c++
class Solution {
public:
    vector<string> commonChars(vector<string>& A) {
        vector<string> res;
        vector<unordered_map<char,int>> vum(A.size());
        for(int i = 0;i < A.size();++i)
            for(char c : A[i])
                vum[i][c]++;        // å¯¹åº”keyçš„value++
 
        for(pair<char, int> pair : vum[0])     // å°†æ‰€æœ‰keyçš„valueçš„æœ€å°å€¼é€‰æ‹©å‡ºæ¥æ”¾åœ¨ç¬¬ä¸€ä¸ªå‘é‡ä¸­
        {
            int n = pair.second;
            for(int i = 1;i < vum.size();++i)
                n = min(n,vum[i][pair.first]);
            while(n--) res.push_back(string(1, pair.first));       
        }
        return res;
    }
};
```

## 3.5 å¯»æ‰¾æ•°ç»„çš„ä¸­å¿ƒä¸‹æ ‡ï¼ˆå¯»æ‰¾æ•°ç»„çš„ä¸­å¿ƒä¸‹æ ‡ï¼‰

[724. å¯»æ‰¾æ•°ç»„çš„ä¸­å¿ƒä¸‹æ ‡ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/find-pivot-index/)

### 3.5.1 æš´åŠ›è§£æ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int middle_index(-1);
        int temp_index(0);

        while(temp_index < nums.size())
        {
            int left_sum(0), right_sum(0);
            for(int i = 0; i < temp_index; ++i)
                left_sum += nums.at(i);
            
            for(int i = temp_index + 1; i < nums.size(); ++i)
                right_sum += nums.at(i);

            if(left_sum == right_sum)   
            {
                middle_index = temp_index;
                return middle_index;
            }

            cout << "left_sum: " << left_sum << endl;
            cout << "right_sum: " << right_sum << endl;

            ++temp_index;
        }

        return middle_index;
    }
};
```

### 3.5.2 è½¬æ¢æ€æƒ³çš„ç®€å•æ€è·¯ï¼ˆå‰ç¼€å’Œï¼Œç±»ä¼¼æ»‘åŠ¨çª—å£ï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sumleft = 0, sumTotal = 0;
        for(int n : nums)   
            sumTotal += n;
        for(int i = 0; i < nums.size(); ++i)
        {
            if(sumleft * 2  == sumTotal - nums[i])  
                return i;       //å¦‚æœiæ­¤æ—¶æ»¡è¶³ä¸­å¿ƒç´¢å¼•è¦æ±‚ï¼Œreturn
            sumleft += nums[i];
        }
        return -1;
    }
};

// å¦ä¸€ç§è§£æ³•ï¼ŒåŸç†ä¸Šæ˜¯ä¸€æ ·çš„
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sumLeft = 0, sumRight = accumulate(nums.begin(), nums.end(), 0);
        for (int i = 0; i < nums.size(); i++) {
            sumRight -= nums[i];
            // è‹¥å·¦ä¾§å…ƒç´ å’Œç­‰äºå³ä¾§å…ƒç´ å’Œï¼Œè¿”å›ä¸­å¿ƒä¸‹æ ‡ i
            if (sumLeft == sumRight)
                return i;
            sumLeft += nums[i];
        }
        return -1;
    }
};
```

## 3.6 æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•°

[å‰‘æŒ‡ Offer 56 - I. æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

### <span style="background:#FFFFBB;">3.6.1 ä½è¿ç®—</span>

**å‚è€ƒé¢˜è§£ï¼š**[å‰‘æŒ‡ Offer 56 - I. æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•° - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solutions/572857/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom/)

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

1. **éå†æ‰§è¡Œå¼‚æˆ–ï¼š**

   - è®¾æ•´å‹æ•°ç»„ $nums = [a,a,b,b,...,x,y]$ ï¼Œå¯¹ $nums$ ä¸­æ‰€æœ‰æ•°å­—æ‰§è¡Œå¼‚æˆ–ï¼Œå¾—åˆ°çš„ç»“æœä¸º $xâŠ•y$

2. **å¾ªç¯å·¦ç§»è®¡ç®— $m$** ï¼š

   - æ ¹æ®å¼‚æˆ–è¿ç®—å®šä¹‰ï¼Œè‹¥æ•´æ•° $xâŠ•y$ æŸäºŒè¿›åˆ¶ä½ä¸º $1$ ï¼Œåˆ™ $x$ å’Œ $y$ çš„æ­¤äºŒè¿›åˆ¶ä½ä¸€å®šä¸åŒã€‚æ¢è¨€ä¹‹ï¼Œæ‰¾åˆ° $xâŠ•y$ æŸä½ä¸º $1$ çš„äºŒè¿›åˆ¶ä½ï¼Œå³å¯å°†æ•°ç»„ $nums$ æ‹†åˆ†ä¸ºä¸Šè¿°çš„ä¸¤ä¸ªå­æ•°ç»„ã€‚æ ¹æ®ä¸è¿ç®—ç‰¹ç‚¹ï¼Œå¯çŸ¥å¯¹äºä»»æ„æ•´æ•° $a$ æœ‰ï¼š
     - è‹¥ $a \& 0001=1$ï¼Œåˆ™  $a$ çš„ç¬¬ä¸€ä½ä¸º $1$  ï¼›
     - è‹¥ $a \& 0010=1$ï¼Œåˆ™ $a$ çš„ç¬¬äºŒä½ä¸º $1$ ï¼›
     - ä»¥æ­¤ç±»æ¨â€¦â€¦
   - å› æ­¤ï¼Œåˆå§‹åŒ–ä¸€ä¸ªè¾…åŠ©å˜é‡ $m=1$ï¼Œé€šè¿‡ä¸è¿ç®—ä»å³å‘å·¦å¾ªç¯åˆ¤æ–­ï¼Œå¯ è·å–æ•´æ•° $xâŠ•y$é¦–ä½ $1$  ï¼Œè®°å½•äº $m$ ä¸­ï¼Œä»£ç å¦‚ä¸‹ï¼š

   ```c++
   while(n & m == 0) // m å¾ªç¯å·¦ç§»ä¸€ä½ï¼Œç›´åˆ° z & m ï¼= 0
       m <<= 1
   ```

3. **æ‹†åˆ† $nums$ ä¸ºä¸¤ä¸ªå­æ•°ç»„ï¼›**

4. åˆ†åˆ«éå†ä¸¤ä¸ªå­æ•°ç»„æ‰§è¡Œå¼‚æˆ–ï¼š

   - é€šè¿‡éå†åˆ¤æ–­ $nums$ ä¸­å„æ•°å­—å’Œ $m$ åšä¸è¿ç®—çš„ç»“æœï¼Œå¯å°†æ•°ç»„æ‹†åˆ†ä¸ºä¸¤ä¸ªå­æ•°ç»„ï¼Œå¹¶åˆ†åˆ«å¯¹ä¸¤ä¸ªå­æ•°ç»„éå†æ±‚å¼‚æˆ–ï¼Œåˆ™å¯å¾—åˆ°ä¸¤ä¸ªåªå‡ºç°ä¸€æ¬¡çš„æ•°å­—ï¼Œä»£ç å¦‚ä¸‹ï¼š

   ```c++
   for(int num : nums) {
       if(num & m) x ^= num;   // è‹¥ num & m != 0 , åˆ’åˆ†è‡³å­æ•°ç»„ 1 ï¼Œæ‰§è¡Œéå†å¼‚æˆ–
       else y ^= num;          // è‹¥ num & m == 0 , åˆ’åˆ†è‡³å­æ•°ç»„ 2 ï¼Œæ‰§è¡Œéå†å¼‚æˆ–
   }
   return vector<int> {x, y};  // éå†å¼‚æˆ–å®Œæ¯•ï¼Œè¿”å›åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— x å’Œ y
   ```

5. **è¿”å›å€¼**ï¼šè¿”å›åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— $x, y$ å³å¯ã€‚



```c++
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        int x = 0, y = 0, n = 0, mask(0);
        for(int num : nums)             // 1. éå†å¼‚æˆ–
            n ^= num;         
        mask = n ^ (-n);                // 2. è·å–maskï¼ŒåŒºåˆ†åˆ†åˆ«åŒ…å«xå’Œyçš„å­æ•°ç»„
        for(int num : nums) {           // 3. éå† nums åˆ†ç»„
            if(num & mask) x ^= num;    // 4. å½“ num & mask != 0
            else y ^= num;              // 5. å½“ num & mask == 0
        }
        return vector<int> {x, y};      // 6. è¿”å›å‡ºç°ä¸€æ¬¡çš„æ•°å­—
    }
};

```



## 3.7 æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•° II  

[å‰‘æŒ‡ Offer 56 - II. æ•°ç»„ä¸­æ•°å­—å‡ºç°çš„æ¬¡æ•° II - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

### 3.7.1 å“ˆå¸Œ

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int, int> hash;
        for(int i = 0; i < nums.size(); ++i)    ++hash[nums[i]];

        for(auto temp : hash)   if(temp.second == 1)   return temp.first;
        return 0;   // ç»“æœå¿…ç„¶ä¸ä¼šèµ°åˆ°è¿™ä¸€æ­¥
    }
};
```

### 3.7.2 ä½è¿ç®—

> ğŸ« ğŸ« ğŸ« ğŸ« ğŸ« ğŸ« ğŸ« ï¼Œè¿™åˆ°åº•æ˜¯æ€ä¹ˆç”¨çš„ä½è¿ç®—ï¼Ÿä»€ä¹ˆè„‘å­èƒ½æƒ³åˆ°å•Šï¼Ÿè€Œä¸”æ•ˆç‡è¿˜çœŸçš„nmçš„é«˜ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans = 0;
        for(int i = 0; i < 32; ++i){
            int cnt = 0;
            for(int n : nums){
                // n & 1 << i çš„å€¼å¤§äº0å³ä¸ºçœŸ
                if(n & (1 << i)) cnt++;
            }
            // æ„é€ åªå‡ºç°ä¸€æ¬¡çš„é‚£ä¸ªæ•°å­—ï¼Œé‡‡ç”¨å¼‚æˆ–çš„æ–¹æ³•ç”ŸæˆäºŒè¿›åˆ¶ä¸­çš„æ¯ä¸€ä½
            if(cnt % 3 == 1) ans ^= (1 << i);
        }
        return ans;
    }
};
```

## 3.8 å‰‘æŒ‡ Offer 53 - II. 0ï½n-1ä¸­ç¼ºå¤±çš„æ•°å­—

[å‰‘æŒ‡ Offer 53 - II. 0ï½n-1ä¸­ç¼ºå¤±çš„æ•°å­— - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/)

### 3.8.1 äºŒåˆ†æ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(logN)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int left = 0, right = nums.size();
        while(left < right){
            int mid = (left + right) / 2;
            if(mid == nums[mid]) left = mid + 1;
            else right = mid;
        }
        return left;
    }
};
```

### 3.8.2 é—®é¢˜è½¬æ¢æ³•

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int sum = 0;
        for(int i = 0; i < n; i ++)
            sum += nums[i];
        return n*(n + 1)/2 - sum;
    }
};
```

### 3.8.3 å“ˆå¸Œæ•°ç»„

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int hash[50000]{0};
        for(int i = 0; i < nums.size(); ++i)
        {
            ++hash[nums[i]];
        }
        for(int i = 0; i < nums.size(); ++i)
        {
            if(hash[i] == 0)
            {
                return i;
            }
        }

        return nums.size();
    }
};
```

## 3.9 æŒ‰å¥‡å¶æ’åºæ•°ç»„

[905. æŒ‰å¥‡å¶æ’åºæ•°ç»„ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/sort-array-by-parity/)

### 3.9.1 æš´åŠ›è§£æ³•

```c++
class Solution {
public:
    vector<int> sortArrayByParity(vector<int>& nums) {
        vector<int> fore_res, back_res;
        for(int i = 0; i < nums.size(); ++i)
        {
            if(nums[i] % 2 == 0)    fore_res.emplace_back(nums[i]);
            else    back_res.emplace_back(nums[i]);
        }

        for(int i = 0; i < back_res.size(); ++i)
        {
            fore_res.emplace_back(back_res[i]);
        }

        return fore_res;
    }
};
```

### 3.9.2 å·¦å³æŒ‡é’ˆ

```c++
class Solution {
public:
    vector<int> sortArrayByParity(vector<int>& nums) {
        int right = 0, left = nums.size() - 1;

        while(right != left)
        {
            if(nums[right] % 2 != 0)
            {
                swap(nums[right], nums[left]);
                --left;
            }
            else    ++right;
        }

        return nums;
    }
};
```

## 3.10 å­˜åœ¨é‡å¤å…ƒç´  II

[219. å­˜åœ¨é‡å¤å…ƒç´  II - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/contains-duplicate-ii/)

### 3.10.1 å“ˆå¸Œè¡¨

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$

```c++
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> map;
        int length = nums.size();
        for (int i = 0; i < length; i++) {
            int num = nums[i];
            if (map.count(num) && i - map[num] <= k) {
                return true;
            }
            map[num] = i;
        }
        return false;
    }
};
```

### 3.10.2 æ»‘åŠ¨çª—å£

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(k)$

```c++
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_set<int> s;
        int length = nums.size();
        for (int i = 0; i < length; i++) {
            if (i > k) {
                s.erase(nums[i - k - 1]);   // å°†è¯¥å…ƒç´ ä»æ»‘åŠ¨çª—å£ç§»é™¤ï¼Œä»¥ä¿è¯æ»‘åŠ¨çª—å£æ’å®šå¤§å°
            }
            if (s.count(nums[i])) {         
                return true;
            }
            s.insert(nums[i]);
        }
        return false;
    }
};
```

## 3.11 æœ‰åºæ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡25%çš„å…ƒç´ ï¼ˆ1287ï¼‰

[1287. æœ‰åºæ•°ç»„ä¸­å‡ºç°æ¬¡æ•°è¶…è¿‡25%çš„å…ƒç´  - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/element-appearing-more-than-25-in-sorted-array/)

### 3.11.1 å“ˆå¸Œè¡¨

```c++
class Solution {
public:
    int findSpecialInteger(vector<int>& arr) {
        int size = arr.size();
        unordered_map<int, int> hash;
        for(int i = 0; i < size; ++i)
        {
            ++hash[arr[i]];
        }

        auto iter = hash.begin();
        while(iter != hash.end())
        {
            printf("iter%d: %d\r\n", iter->first, iter->second);
            if(iter->second * 100 > size * 25)  return iter->first;
            ++iter;
        }

        return -1;
    }
};
```

### 3.11.2 å¿«æ…¢æŒ‡é’ˆ

```c++
class Solution {
public:
    int findSpecialInteger(vector<int>& arr) {
        // æœ‰åºæ•°ç»„ï¼Œæ— éœ€sort
        int slow(0), fast(0), size(arr.size());
        while(fast < size)
        {
            if(arr[fast] == arr[slow])
            {
                ++fast;
                if(fast == size)    return arr[slow];       // ä¸€å®šå­˜åœ¨å¯¹åº”æ•´æ•°ï¼Œåˆ°å°¾éƒ¨åˆ™è¿”å›æœ€åçš„å…ƒç´ 
                continue;
            }

            if((fast - slow) * 100 > size * 25)    return arr[slow];
            slow = fast;
        }

        return -1;
    }
};
```

### 3.11.3 é—®é¢˜è½¬æ¢

> æ€è·¯ç‰›é€¼ï¼šğŸ˜°ğŸ˜°ğŸ˜°ğŸ˜°ğŸ˜°

1. æ•°ç»„æœ‰åºï¼Œä¸”æŸå…ƒç´ å‡ºç°æ¬¡æ•°è¶…è¿‡25%
2. é‚£ä¹ˆå¯¹äºæ­¤å…ƒç´ ç¬¬1æ¬¡å‡ºç°ä½ç½®ï¼ŒåŠ 25%æ•°ç»„é•¿åº¦ï¼Œå¿…å®šä»ä¸ºå®ƒè‡ªèº«

```c++
class Solution {
public:
    int findSpecialInteger(vector<int>& arr) {
        for(int i = 0; i < arr.size(); ++i)
        {
            if(i + arr.size() / 4 < arr.size())
                if(arr[i] == arr[i + arr.size() / 4])   return arr[i];
        }

        return 0;  
    }
};
```

## 3.12 æœ‰æ•ˆçš„å±±è„‰æ•°ç»„ï¼ˆ941ï¼‰

[941. æœ‰æ•ˆçš„å±±è„‰æ•°ç»„ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/valid-mountain-array/)

### 3.12.1 çº¿æ€§æ‰«æï¼ˆåŒæŒ‡é’ˆï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        if(arr.size() < 3) return false;
        int slow(0), fast(0);

        for(fast = 0; fast < arr.size() - 1; ++fast)
        {
            if(slow == 0)
            {
                if(arr[fast] < arr[fast + 1])   continue;
                if(arr[fast] > arr[fast + 1])
                {
                    if(fast == 0)   return false;
                    slow = fast;
                    continue;
                }
               
                return false;
            }

            if(slow > 0)
            {
                if(arr[fast] > arr[fast + 1])   continue;
                return false;
            }
        }

        if(slow == 0)  return false;
        return true;
    }
};

// æ¢ä¸€ç§æ›´ç®€æ´çš„å†™æ³•
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        int head(0), tail(arr.size() - 1);

        if(arr.size() < 3)  return false;
        for(; head < arr.size() - 1; ++head)
            if(arr[head] >= arr[head + 1])   break;
        for(; tail > 1; --tail)
            if(arr[tail] >= arr[tail - 1])  break;
        
        if(head == tail and head != 0 and tail != arr.size() - 1)    return true;
        return false;
    }
};
```

## 3.13 æœ€é•¿è¿ç»­é€’å¢åºåˆ—

[674. æœ€é•¿è¿ç»­é€’å¢åºåˆ— - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

### 3.13.1 åŒæŒ‡é’ˆï¼ˆå¿«æ…¢æŒ‡é’ˆã€å°ºå–æ³•ã€è´ªå¿ƒï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int slow(0), fast(0), size(nums.size()), max_size(1);
        
        while(fast < size - 1)
        {                
            if(nums[fast] < nums[fast + 1])
            {
                ++fast;
                max_size = max(max_size, fast - slow + 1);
                continue;
            }
            ++fast;
            slow = fast;
        }

        return max_size;
    }
};

// æ›´ç®€æ´çš„å†™æ³•
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int slow(0), fast(0), size(nums.size()), max_size(1);
        
        while(fast != size)
        {                
            while(fast != size - 1 and nums[fast] < nums[fast + 1])  ++fast;
            max_size = max(max_size, fast - slow + 1);
            slow = ++fast;
        }

        return max_size;
    }
};
```

### 3.13.2 åŠ¨æ€è§„åˆ’

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        int result = 1;
        vector<int> dp(nums.size() ,1);
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i + 1] > nums[i]) { // è¿ç»­è®°å½•
                dp[i + 1] = dp[i] + 1;
            }
            if (dp[i + 1] > result) result = dp[i + 1];
        }
        return result;
    }
};
```


[RISC-V - üêèüêí suda-morris ‰∏™‰∫∫ÂçöÂÆ¢ üêá](https://suda-morris.github.io/blog/cs/riscv.html)



# 1 Register Convention

## 1.1 Integer Register Convention

| Name      | ABI Mnemonic | Meaning                    | Preserved across calls? |
| --------- | ------------ | -------------------------- | ----------------------- |
| x0        | zero         | Zero                       | ‚Äî(Immutable)            |
| x1        | ra           | Return address             | No                      |
| x2        | sp           | Stack pointer              | Yes                     |
| x3        | gp           | Global pointer             | ‚Äî(Unallocatable)        |
| x4        | tp           | Thread pointer             | ‚Äî(Unallocatable)        |
| x5 - x7   | t0 - t2      | Temporary registers        | No                      |
| x8 - x9   | s0 - s1      | **Callee-saved registers** | Yes                     |
| x10 - x17 | a0 - a7      | Argument registers         | No                      |
| x18 - x27 | s2 - s11     | **Callee-saved registers** | Yes                     |
| x28 - x31 | t3 - t6      | Temporary registers        | No                      |

In the standard ABI, procedures should not modify the integer registers **tp** and **gp**, because signal handlers may rely upon their values.

The presence of a frame pointer is optional. If a frame pointer exists, it must reside in **x8 (s0)**; the register remains callee-saved.

## 1.2 Floating-point Register Convention

| Name      | ABI Mnemonic | Meaning                | Preserved across calls? |
| --------- | ------------ | ---------------------- | ----------------------- |
| f0 - f7   | ft0 - ft7    | Temporary registers    | No                      |
| f8 - f9   | fs0 - fs1    | Callee-saved registers | Yes*                    |
| f10 - f17 | fa0 - fa7    | Argument registers     | No                      |
| f18 - f27 | fs2 - fs11   | Callee-saved registers | Yes*                    |
| f28 - f31 | ft8 - ft11   | Temporary registers    | No                      |

*: Floating-point values in callee-saved registers are only preserved across calls if they are no larger than the width of a floating-point register in the targeted ABI. Therefore, these registers can always be considered temporaries if targeting the base integer calling convention.

The Floating-Point Control and Status Register (fcsr) **must have thread storage duration** in accordance with C11 section 7.6 "Floating-point environment <fenv.h>".  

# 2 Procedure Calling Convention

## 2.1 Integer Calling Convention

8‰∏™Â≠óËäÇ‰ª•ÂÜÖÁöÑÈÉΩÂèØ‰ª•ÈÄöËøáÂØÑÂ≠òÂô®‰º†ÈÄí„ÄÇ

The base integer calling convention provides eight **argument registers**, **a0-a7**, **the first two of which are also used to return values**.  

**Scalars** that are at most **XLEN bits wide** are passed in **a single argument register**, **or on the stack by value if none is available**. When passed in registers or on the stack, integer scalars narrower than XLEN bits are widened according to the sign of their type up to 32 bits, then sign-extended to XLEN bits. When passed in registers or on the stack, floating-point types narrower than XLEN bits are widened to XLEN bits, with the upper bits undefined.

**Scalars** that are **2√óXLEN bits wide** are passed in **a pair of argument registers**, with the low-order XLEN bits in the lower-numbered register and the high-order XLEN bits in the higher-numbered register. If no argument registers are available, the scalar is **passed on the stack by value**. **If exactly one register is available, the low-order XLEN bits are passed in the register and the high-order XLEN bits are passed on the stack.**

**Scalars wider than 2√óXLEN bits are passed by reference and are replaced in the argument list with the address.**

Aggregates whose total size is no more than XLEN bits are passed in a register, with the fields laid out as though they were passed in memory. If no register is available, the aggregate is passed on the stack. Aggregates whose total size is no more than 2√óXLEN bits are passed in a pair of registers; if only one register is available, the first XLEN bits are passed in a register and the remaining bits are passed on the stack. If no registers are available, the aggregate is passed on the stack. Bits unused due to padding, and bits past the end of an aggregate whose size in bits is not divisible by XLEN, are undefined.

**Aggregates or scalars passed on the stack are aligned to the greater of the type alignment and XLEN bits, but never more than the stack alignment.**  

Aggregates larger than 2√óXLEN bits are passed by reference and are replaced in the argument list with the address, as are C++ aggregates with nontrivial copy constructors, destructors, or vtables.

Empty structs or union arguments or return values are ignored by C compilers which support  a non-standard extension. This is not the case for C++, which requires them to be sized types.

Bitfields are packed in little-endian fashion. A bitfield that would span the alignment boundary ofits integer type is padded to begin at the next alignment boundary. For example, `struct { int x :10; int y : 12; }` is a 32-bit type with x in bits 9-0, y in bits 21-10, and bits 31-22 undefined. Bycontrast, `struct { short x : 10; short y : 12; }` is a 32-bit type with x in bits 9-0, y in bits 27-16,and bits 31-28 and bits 15-10 undefined.

Bitfields may larger than its integer type, bits excess than its integer type will treat as padding bits,then padding to begin at the next alignment boundary. For example`struct { char x : 9; char y; }` is a 24 byte type with x in bits 7-0, y in bit 23-16, and bits 15-8 undefined, `struct { char x : 9; chary : 2 }` is a 16-bit type with x in bits 7-0, y in bit 10-9, and bit 8, bits 15-11 is undefined.

**Arguments passed by reference may be modified by the callee.**

Floating-point reals are passed the same way as aggregates of the same size; complex floating-point numbers are passed the same way as a struct containing two floating-point reals. (This constraintchanges when the integer calling convention is augmented by the hardware floating-point callingconvention.)

In the base integer calling convention, **variadic arguments**(ÂèØÂèòÂèÇÊï∞ÂàóË°®) are passed in the same manner as named arguments, with one exception. Variadic arguments with 2√óXLEN-bit alignment and size atmost 2√óXLEN bits are passed in an aligned register pair (i.e., the first register in the pair is evennumbered), or on the stack by value if none is available. **After a variadic argument has been passed on the stack,** all future arguments will also be passed on the stack (i.e. the last argument registermay be left unused due to the aligned register pair rule).

Values are returned in the same manner as a first named argument of the same type would be passed. If such an argument would have been passed by reference, the caller allocates memory for the return value, and **passes the address** as an implicit first parameter.

> There is no requirement that the address be returned from the function and so software should not assume that a0 will hold the address of the return value on return.  

**The stack grows downwards (towards lower addresses)** and the stack pointer shall be aligned to a **128-bit boundary upon procedure entry.** The first argument passed on the stack is located at offset zero of the **stack pointer** on function entry; following arguments are stored at correspondingly higher addresses.

**In the standard ABI, the stack pointer must remain aligned through out procedure execution. Nonstandard ABI code must realign the stack pointer prior to invoking standard ABI procedures.** The operating system must **realign the stack pointer prior to invoking a signal handler**; hence, POSIX signal handlers need not realign the stack pointer. In systems that **service interrupts using the interruptee‚Äôs stack**, the interrupt service routine must realign the stack pointer if linked with any code that uses a non-standard stack-alignment discipline, but need not realign the stack pointer if all code adheres to the standard ABI.

Procedures must not rely upon the persistence of stack-allocated data whose addresses lie below the stack pointer.

**Registers s0-s11 shall be preserved across procedure calls.** No floating-point registers, if present, are preserved across calls. (This property changes when the integer calling convention is augmented by the hardware floating-point calling convention.)

## 2.2. Hardware Floating-point Calling Convention

The hardware floating-point calling convention adds eight floating-point argument registers, fa0-fa7, the first two of which are also used to return values. Values are passed in floating-pointregisters whenever possible, whether or not the integer registers have been exhausted.

The remainder of this section applies only to named arguments. Variadic arguments are passedaccording to the integer calling convention.

ABI_FLEN refers to the width of a floating-point register in the ABI. The ABI_FLEN must be no widerthan the ISA‚Äôs FLEN. The ISA might have wider floating-point registers than the ABI.

For the purposes of this section, "struct" refers to a C struct with its hierarchy flattened, includingany array fields. That is, struct { struct { float f[1]; } g[2]; } and struct { float f; float g; }are treated the same. Fields containing empty structs or unions are ignored while flattening, evenin C++, unless they have nontrivial copy constructors or destructors. Fields containing zero-lengthbit-fields are ignored while flattening. Attributes such as aligned or packed do not interfere with astruct‚Äôs eligibility for being passed in registers according to the rules below, i.e. struct { int i;double d; } and struct __attribute__((__packed__)) { int i; double d } are treated the same, as are struct { float f; float g; } and struct { float f; float g __attribute__ ((aligned (8))); }.

A real floating-point argument is passed in a floating-point argument register if it is no more thanABI_FLEN bits wide and at least one floating-point argument register is available. Otherwise, it ispassed according to the integer calling convention. When a floating-point argument narrower thanFLEN bits is passed in a floating-point register, it is 1-extended (NaN-boxed) to FLEN bits.

A struct containing just one floating-point real is passed as though it were a standalone floatingpoint real.

A struct containing two floating-point reals is passed in two floating-point registers, if neither real ismore than ABI_FLEN bits wide and at least two floating-point argument registers are available.(The registers need not be an aligned pair.) Otherwise, it is passed according to the integer callingconvention.

A complex floating-point number, or a struct containing just one complex floating-point number, ispassed as though it were a struct containing two floating-point reals.

A struct containing one floating-point real and one integer (or bitfield), in either order, is passed ina floating-point register and an integer register, provided the floating-point real is no more thanABI_FLEN bits wide and the integer is no more than XLEN bits wide, and at least one floating-pointargument register and at least one integer argument register is available. If the struct is passed inthis manner, and the integer is narrower than XLEN bits, the remaining bits are unspecified. If the struct is not passed in this manner, then it is passed according to the integer calling convention. 

Unions are never flattened and are always passed according to the integer calling convention.

Values are returned in the same manner as a first named argument of the same type would be passed.

Floating-point registers fs0-fs11 shall be preserved across procedure calls, provided they hold values no more than ABI_FLEN bits wide.


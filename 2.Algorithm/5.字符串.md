# å­—ç¬¦ä¸²

# 0 åŒ¹é…ç®—æ³•

## 0.1 KMPç®—æ³•

### 0.1.1 é—®é¢˜

KMPç®—æ³•è§£å†³å­—ç¬¦ä¸²æ¨¡å¼åŒ¹é…é—®é¢˜ï¼Œç»™å®šå­—ç¬¦ä¸²så’Œpï¼Œè®¡ç®—sä¸­å‡ºç°pçš„ä½ç½®ï¼Œpå³patternã€‚å®é™…ä¸Šå•å°±è¿™ä¸ªé—®é¢˜è€Œè¨€ï¼Œå®Œå…¨å¯ä»¥é‡‡ç”¨æš´åŠ›åŒ¹é…çš„æ–¹å¼ï¼Œå‡è®¾sçš„é•¿åº¦ä¸ºmï¼Œpçš„é•¿åº¦ä¸ºnï¼Œåˆ™æš´åŠ›åŒ¹é…çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(mn)ï¼Œç›¸æ¯”ä¹‹ä¸‹ï¼ŒKMPç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(m+n)ã€‚

```
s: abxcabcycabcc
p:         cabcc
```

### 0.1.2 å®šä¹‰

å…ˆå®šä¹‰ä¸€äº›ä¸œè¥¿ï¼Œæ–¹ä¾¿åé¢é˜é‡ŠKMPç®—æ³•èƒŒåçš„æ€æƒ³ã€‚

**å®šä¹‰1**ï¼š

- å‰ç¼€ prefixï¼šå­—ç¬¦ä¸²aæ˜¯å­—ç¬¦ä¸²bçš„å‰ç¼€ï¼Œæ„å‘³ç€aæ˜¯bçš„å­ä¸²ï¼Œä¸”å‡ºç°åœ¨å¼€å¤´ã€‚
- åç¼€ suffixï¼šå­—ç¬¦ä¸²aæ˜¯å­—ç¬¦ä¸²bçš„åç¼€ï¼Œæ„å‘³ç€aæ˜¯bçš„å­ä¸²ï¼Œä¸”å‡ºç°ä¸ºå°¾éƒ¨ã€‚

```
"abc" is prefix of "abcdefg"
"efg" is suffix of "abcdefg"
```

åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬åªè€ƒè™‘çœŸå­ä¸²çš„æƒ…å†µï¼Œè™½ç„¶æŒ‰ç…§å®šä¹‰ï¼Œä»»æ„å­—ç¬¦ä¸²è‡ªèº«ä¹Ÿæ˜¯è‡ªèº«çš„å‰ç¼€ï¼Œä½†è¿™å¯¹äºKMPæ¥è¯´æ²¡æœ‰æ„ä¹‰ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªæœ‰è¶£çš„ä¸œè¥¿ï¼šç»™å®šå­—ç¬¦ä¸²sï¼Œå¦‚æœå­—ç¬¦ä¸²ræ—¢æ˜¯sçš„å‰ç¼€ï¼Œä¹Ÿæ˜¯sçš„åç¼€ï¼Œå®ƒå°±æ˜¯sçš„å…¬å…±å‰åç¼€ã€‚

![a](figures/presuf-1682432316850-12.png)

å¦‚ä¸Šå›¾ï¼Œå½“æˆ‘ä»¬ç”¨æ¨¡å¼påŒ¹é…å­—ç¬¦ä¸²sæ—¶ï¼Œå¦‚æœsä¸­å¤šæ¬¡å‡ºç°çš„på­˜åœ¨é‡å çš„æƒ…å†µï¼Œé‚£ä¹ˆé‡å éƒ¨åˆ†å…¶å®å°±æ˜¯pçš„ä¸€ä¸ªå…¬å…±å‰åç¼€ã€‚

ç„¶åæˆ‘ä»¬å¯ä»¥å‘ç°å…¬å…±å‰åç¼€çš„ä¸¤ä¸ªæœ‰è¶£çš„æ€§è´¨ï¼š

**æ€§è´¨**ï¼š

1. å¦‚æœå­—ç¬¦ä¸²r1ï¼Œr2æ˜¯sçš„ä¸¤ä¸ªä¸åŒçš„å…¬å…±å‰åç¼€ï¼Œä¸”len(r1)>len(r2)ï¼Œåˆ™r2æ˜¯r1çš„å…¬å…±å‰åç¼€ã€‚
2. è®¾s[0:i]çš„æœ€é•¿å…¬å…±å‰åç¼€ä¸ºs[0:k]ï¼Œåˆ™s[0:k-1]å¿…ç„¶æ˜¯s[0:i-1]çš„ä¸€ä¸ªå…¬å…±å‰åç¼€ã€‚

è¿™ä¸¤ä¸ªæ€§è´¨å…¶å®å¾ˆtrivialï¼Œè¯»è€…è‡ªå·±ç”»ä¸ªå›¾å°±èƒ½ç†è§£äº†ï¼Œæˆ‘æ‡’å¾—ç”»å›¾äº†ï¼Œé€šè¿‡ä¸Šé¢çš„æ€§è´¨1ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“å¯ä»¥å¾—å‡ºä¸‹é¢çš„ç»“è®ºï¼š

**å¼•ç†1**ï¼š

- è®¾r~1~,r~2~â€¦æ˜¯ä¸åŒçš„å­—ç¬¦ä¸²ï¼Œr~i+1~æ˜¯r~i~çš„æœ€é•¿å…¬å…±å‰åç¼€ï¼Œä¸”r~1~æ˜¯r~i~çš„æœ€é•¿å…¬å…±å‰åç¼€ï¼Œåˆ™r~1~,r~2ä¾æ¬¡æ˜¯sé•¿åº¦é€’å‡çš„æ‰€æœ‰çš„å…¬å…±å‰åç¼€ã€‚

### 0.1.3 nextæ•°ç»„

ç°åœ¨æˆ‘ä»¬å…ˆä¸è°ˆKMPç®—æ³•ï¼Œå…ˆè®¡ç®—ä¸€ä¸ªæ•°ç»„nextï¼Œå®ƒçš„é•¿åº¦ç­‰äºå­—ç¬¦ä¸²pçš„é•¿åº¦ï¼ˆå³patternçš„é•¿åº¦ï¼‰ï¼Œè¿™ä¸ªæ•°ç»„æ˜¯è¿™ä¹ˆå®šä¹‰çš„ï¼š

**å®šä¹‰2**ï¼š

- next[k]æ˜¯p[0:k]çš„æœ€é•¿å…¬å…±å‰åç¼€çš„é•¿åº¦ï¼Œä¹Ÿå³p[0:k]çš„æœ€é•¿å…¬å…±å‰åç¼€ä¸ºp[0:next[k]-1]ã€‚ç‰¹åˆ«åœ°ï¼Œnext[0]=0ã€‚æ³¨æ„ï¼šè¿™é‡Œçš„p[0:k]æ˜¯é—­åŒºé—´ã€‚

```cpp
vector<int> make_next(const string& p) {
    vector<int> next(p.size(), 0);
    int i = 0, j = 1;
    while (j < p.size()) {
        while (p[i] != p[j] && i > 0) {// æ ¹æ®å¼•ç†1ï¼ŒæŒ‰é•¿åº¦é€’å‡çš„é¡ºåºå°è¯•æ‰€æœ‰å¯èƒ½çš„p[0:i-1]çš„å…¬å…±å‰åç¼€
            i = next[i - 1];
        }
        if (p[i] == p[j]) {// æ‰¾åˆ°äº†åŒ¹é…çš„p[i]å’Œp[j]ï¼Œåˆ™p[0:j]çš„æœ€é•¿å…¬å…±å‰åç¼€ä¸ºp[0:i]
            next[j] = ++i;
        } else {
            next[j] = 0;// å¦åˆ™ä¸º0
        }
        j++;
    }
    return next;
}
```

ä¸Šé¢çš„ä»£ç è®¡ç®—nextæ•°ç»„ã€‚å®é™…ä¸Šï¼Œå¾ªç¯ä¸­ç»´æŠ¤äº†å¦‚ä¸‹çš„ä¸å˜å¼ï¼š

> p[0:j-1]çš„æœ€é•¿å…¬å…±å‰åç¼€ä¸ºp[0:i-1]ï¼ˆi=0æ—¶ç‰¹æ®Šå¤„ç†ï¼‰ï¼Œä¸”next[0:j-1]å·²readyã€‚

å½“å‰å¾ªç¯çš„ç›®æ ‡å°±æ˜¯è®¡ç®—p[0:j]çš„æœ€é•¿å…¬å…±å‰åç¼€ï¼Œæ ¹æ®**æ€§è´¨1**ï¼Œå®ƒç­‰äºp[0:j-1]çš„æŸä¸€ä¸ªå…¬å…±å‰åç¼€åŠ ä¸Šp[j]ï¼Œé‚£æ˜¾ç„¶æˆ‘ä»¬è¦ä»p[0:j-1]çš„æœ€é•¿å…¬å…±å‰åç¼€p[0:i-1]å¼€å§‹é•¿åº¦é€’å‡åœ°å°è¯•ï¼Œå¦‚ä½•æŒ‰é•¿åº¦é€’å‡å‘¢ï¼Œå‚ç…§**å¼•ç†1**ï¼Œæˆ‘ä»¬åªéœ€è¿­ä»£åœ°æ‹¿p[0:i-1]çš„æœ€é•¿å…¬å…±å‰åç¼€å³å¯ï¼ˆè¿™å·²ç»ç”±nextæ•°ç»„æä¾›äº†ï¼‰ã€‚

ä¸Šé¢çš„æ€æƒ³åœ¨ä»£ç ä¸­çš„ä½“ç°å°±æ˜¯å†…å±‚çš„whileå¾ªç¯ï¼Œç»è¿‡whileå¾ªç¯ååªæœ‰ä¸¤ç§ç»“æœï¼Œä¸€æ˜¯æˆ‘ä»¬æ‰¾åˆ°äº†ä¸€ä¸ªæœ€é•¿çš„åˆé€‚çš„p[0:j-1]çš„å…¬å…±å‰åç¼€p[0:i-1]ï¼Œä¸”p[i]=p[j]ï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥å®£å¸ƒï¼Œp[0:j]çš„æœ€é•¿å…¬å…±å‰åç¼€å°±æ˜¯p[0:i]ï¼Œå¦åˆ™ï¼Œå°±è¯´æ˜p[0:j]æ²¡æœ‰æœ€é•¿å…¬å…±å‰åç¼€ã€‚

æˆ‘ä»¬å†åˆ†æä¸€ä¸‹ä¸Šé¢ç®—æ³•çš„å¤æ‚åº¦ï¼Œæ³¨æ„åˆ°iå’Œjéƒ½æ˜¯æ•´æ•°ï¼Œä¸”å¾ªç¯å†…éƒ¨å˜é‡içš„å¢åŠ å¿…ç„¶ä¼´éšç€jçš„å¢åŠ ï¼Œè€Œjæœ€å¤šå¢å¤§åˆ°len(p)ï¼Œå› æ­¤içš„å‡å°‘æœ€å¤šå‡ºç°len(p)æ¬¡ï¼Œä»è€Œå†…éƒ¨å¾ªç¯æ¬¡æ•°ä¸è¶…è¿‡2len(p)ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(len(p))ã€‚

### 0.1.3 ç®—æ³•ä¸»ä½“

ç»ˆäºå¯ä»¥å¼€å§‹ä»‹ç»KMPç®—æ³•çš„æœ¬ä½“äº†ï¼š

```cpp
vector<int> kmp(const string& s, const string& p) {
    vector<int> res;
    if (s.size() < p.size()) return res;
    int i = 0, j = 0; 
    auto next = make_next(p);
    while (i != s.size()) {
        while (s[i] != p[j] && j > 0) {
            j = next[j - 1];
        }
        if (s[i] == p[j]) {
            i++; j++;
        } else {
            i++;
        }
        if (j == p.size()) {
            res.push_back(i - p.size());
            j = next[j - 1];
        }
    }
    return res;
}
```

ä¾ç„¶é€šè¿‡å¾ªç¯ä¸å˜å¼çš„æ€è·¯æ¥åˆ†æç®—æ³•ï¼Œè¿™ä¸ªå¾ªç¯ç»´æŠ¤äº†è¿™æ ·ä¸€ä¸ªä¸å˜å¼ï¼š

> p[0:j-1]æ˜¯pçš„æ‰€æœ‰å‰ç¼€ï¼ˆè¿™é‡ŒåŒ…æ‹¬pè‡ªèº«ï¼‰ä¸­ä¸s[i-j:i-1]åŒ¹é…çš„æœ€é•¿çš„ä¸€ä¸ªå‰ç¼€ã€‚

é‚£æ˜¾ç„¶ï¼Œæˆ‘ä»¬æŒ‰ièµ°å®Œä¸€éå¾ªç¯ï¼Œä¸€å®šèƒ½å¤ŸæŠŠpåœ¨sä¸­å‡ºç°çš„æ‰€æœ‰ä½ç½®ç»™æ‰¾åˆ°ï¼Œå› ä¸ºåªè¦å‡ºç°äº†ï¼Œpæœ¬èº«å°±ä¼šæ˜¯æœ€é•¿å‰ç¼€ã€‚ç°åœ¨æˆ‘ä»¬çœ‹å¦‚ä½•ç»´æŒè¿™ä¸ªä¸å˜å¼ï¼Œå…¶å®å’Œè®¡ç®—nextæ•°ç»„çš„æ–¹æ³•å¾ˆç›¸ä¼¼ã€‚

![fig6-2](figures/fig6-2.svg)

æˆ‘ä»¬è¿˜æ˜¯å°è¯•åŒ¹é…p[j]å’Œs[i]ï¼Œå¦‚æœä¸åŒ¹é…ï¼Œç”±äºp[0:j-1]å·²ç»å’Œs[i-j:i-1]åŒ¹é…å¥½äº†ï¼Œæ­¤æ—¶æˆ‘ä»¬çœ‹p[0:j-1]çš„æœ€é•¿å…¬å…±å‰åç¼€p[0:next[j-1]-1]ï¼Œå®ƒä¹Ÿå¿…ç„¶å’Œs[i-next[j-1]:i-1]åŒ¹é…å¥½äº†ï¼Œè¿™è¯´æ˜æˆ‘ä»¬å¯ä»¥ç›´æ¥å°è¯•ç”¨p[next[j-1]]å’Œs[i]å°è¯•åŒ¹é…ï¼Œè¿™æ˜¯é™¤p[0:j-1]ä»¥å¤–æœ€é•¿çš„å¯èƒ½çš„å‰ç¼€ï¼›å¦‚æœè¿˜ä¸åŒ¹é…ï¼Œè¿­ä»£ä¸‹å»å³å¯ã€‚

ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦åˆ†æä¸nextæ•°ç»„æ„å»ºå¼‚æ›²åŒå·¥ï¼Œjçš„å¢åŠ ä¾èµ–äºiï¼Œè€Œjæœ€å°ä¸º0ï¼Œæœ€é«˜ä¸è¶…è¿‡iå¢åŠ çš„æ¬¡æ•°ï¼Œè€Œiæœ€å¤§ä¸ºlen(s)ï¼Œå› æ­¤å¾ªç¯æ¬¡æ•°ä¸Šçº¿ä¸º2len(s)ï¼Œä»è€Œå¤æ‚åº¦ä¸ºO(len(s))ã€‚åŠ ä¸Š`make_next`çš„O(len(p))ï¼Œæ•´ä¸ªKMPç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºO(len(s)+len(p))ã€‚

å¯ä»¥çœ‹åˆ°KMPç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯çº¿æ€§çš„ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥çœ‹C++,Pythonç­‰è¯­è¨€ä¸ºå­—ç¬¦ä¸²ç±»å®ç°çš„findæ–¹æ³•ï¼Œéƒ½æ²¡æœ‰é‡‡ç”¨KMPï¼Œè€Œæ˜¯ä½¿ç”¨ä¼ ç»Ÿçš„æš´åŠ›æœç´¢ã€‚è¿™æ˜¯å› ä¸ºKMPç®—æ³•éœ€è¦é¢å¤–åˆ†é…ç©ºé—´å»è®¡ç®—å‰ç¼€æ•°ç»„ï¼Œåœ¨å­—ç¬¦ä¸²è¾ƒå°çš„æ—¶å€™å…¶å®æ˜¯ä¸å¦‚ç›´æ¥æš´åŠ›æœç´¢çš„ã€‚KMPç®—æ³•é€‚ç”¨äºå¯¹äºä¸€ä¸ªå›ºå®šçš„æ¨¡å¼ï¼Œéœ€è¦å¯¹å¤§é‡å­—ç¬¦ä¸²è¿›è¡ŒåŒ¹é…çš„æƒ…å†µï¼Œæ­¤æ—¶è®¡ç®—å¥½nextæ•°ç»„åæˆ‘ä»¬å°±å¯ä»¥ç›´æ¥å¿«é€Ÿè¿›è¡Œçº¿æ€§åŒ¹é…ã€‚

# 1 æœ‰æ•ˆçš„æ‹¬å·ï¼ˆ20ï¼‰

[20. æœ‰æ•ˆçš„æ‹¬å· - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/valid-parentheses/)

## 1.1 å“ˆå¸Œä¸æ ˆ

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$

```c++
class Solution {
public:
    bool isValid(string s) {
        unordered_map<char,int> m{{'(',1},{'[',2},{'{',3},
                                {')',4},{']',5},{'}',6}};
        stack<char> st;
        bool istrue=true;
        for(char c:s){
            int flag=m[c];
            if(flag>=1&&flag<=3) st.push(c);
            else if(!st.empty()&&m[st.top()]==flag-3) st.pop();
            else {istrue=false;break;}
        }
        if(!st.empty()) istrue=false;
        return istrue;
    }
};

// å¦ä¸€ç§å†™æ³•
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        unordered_map<char, char>   hash{{'(', ')'}, {'[', ']'}, {'{', '}'}};
        for(int i(0); i < s.size(); ++i)
        {
            if(s[i] == '(' or s[i] == '[' or s[i] == '{')   st.push(s[i]);
            else if(!st.empty())
            {
                if(hash[st.top()] != s[i])  return false;
                st.pop();
            }
            else    return false;
        }
        if(!st.empty()) return false;
        return true;
    }
};
```

# 2 å­—ç¬¦ä¸²ç›¸åŠ ï¼ˆ415ï¼‰

[415. å­—ç¬¦ä¸²ç›¸åŠ  - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/add-strings/)

## 2.1 æ¨¡æ‹Ÿ

æ—¶é—´å¤æ‚åº¦ï¼š$O(MAX(M, N))$

ç©ºé—´å¤æ‚åº¦ï¼š$O(MAX(M, N))$

```c++
class Solution {
public:
    string addStrings(string num1, string num2) {
        int size1(num1.size() - 1), size2(num2.size() - 1);
        int carry(0);
        string res;

        while(size1 >= 0 or size2 >= 0)
        {
            int x = size1 >= 0 ? num1[size1] - '0' : 0;
            int y = size2 >= 0 ? num2[size2] - '0' : 0;
            int  temp = x + y + carry;

            res.push_back('0' + temp % 10);
            carry = temp / 10;
            --size1;
            --size2;
        }
        if(carry)   res.push_back('1');
        reverse(res.begin(), res.end());

        return res;
    }
};
```

# 3 äºŒè¿›åˆ¶æ±‚å’Œï¼ˆ67ï¼‰

[67. äºŒè¿›åˆ¶æ±‚å’Œ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/add-binary/)

## 3.1 æ¨¡æ‹Ÿ

```c++
class Solution {
public:
    string addBinary(string a, string b) {
        int size_a(a.size() - 1), size_b(b.size() - 1);
        int carry(0);
        string res;

        while(size_a >= 0 or size_b >= 0)
        {
            int temp_a = size_a >= 0 ? a[size_a] - '0' : 0;
            int temp_b = size_b >= 0 ? b[size_b] - '0' : 0;
            int temp = temp_a + temp_b + carry;
            if(temp >= 2)
            {
                temp = temp - 2;
                carry = 1;
            }
            else    carry = 0;

            res.push_back(temp + '0');
            --size_a, --size_b;
        }
        if(carry)   res.push_back('1');
        reverse(res.begin(), res.end());
        return res;
    }
};
```

# 4 åè½¬å­—ç¬¦ä¸²ï¼ˆ344ï¼‰

[344. åè½¬å­—ç¬¦ä¸² - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/reverse-string/)

## 4.1 æš´åŠ›è§£æ³•ï¼ˆåŒæŒ‡é’ˆï¼‰

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        for(int i = 0; i < s.size() / 2; ++i)
            swap(s[i], s[s.size() - i - 1]);
    }
};

// åŒæŒ‡é’ˆ
class Solution {
public:
    void reverseString(vector<char>& s) {
        int n = s.size();
        for (int left = 0, right = n - 1; left < right; ++left, --right) {
            swap(s[left], s[right]);
        }
    }
};
```

## 4.2 å¼‚æˆ–ï¼ˆå¯å‚è€ƒçš„å†™æ³•ï¼Œä¸ä½¿ç”¨STLåº“ï¼‰

```c++
class Solution {
public:
    void reverseString(vector<char>& s) {
        for(int l = 0, r = s.size() - 1; l < r; ++l, --r)
        {
            s[l] ^= s[r];		//æ„é€  a ^ b çš„ç»“æœï¼Œå¹¶æ”¾åœ¨ a ä¸­
        	s[r] ^= s[l];		//å°† a ^ b è¿™ä¸€ç»“æœå† ^ b ï¼Œå­˜å…¥bä¸­ï¼Œæ­¤æ—¶ b = a, a = a ^ b
        	s[l] ^= s[r];		//a ^ b çš„ç»“æœå† ^ a ï¼Œå­˜å…¥ a ä¸­ï¼Œæ­¤æ—¶ b = a, a = b å®Œæˆäº¤æ¢
        }
    }
};
```

# 5 åè½¬å­—ç¬¦ä¸² IIï¼ˆ541ï¼‰

[541. åè½¬å­—ç¬¦ä¸² II - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/reverse-string-ii/)

## 5.1 æ¨¡æ‹Ÿ

```c++
class Solution {
public:
    string reverseStr(string s, int k) {
        int n = s.length();
        for (int i = 0; i < n; i += 2 * k) {
            reverse(s.begin() + i, s.begin() + min(i + k, n));
        }
        return s;
    }
};
```

# 6 åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯ IIIï¼ˆ557ï¼‰

[557. åè½¬å­—ç¬¦ä¸²ä¸­çš„å•è¯ III - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)

## 6.1 å¿«æ…¢æŒ‡é’ˆ

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$

```c++
class Solution {
public:
    string reverseWords(string s) {
        auto slow(s.begin());
        auto fast = s.begin();

        while(fast <= s.end())
        {
            if(*fast == ' ' || fast == s.end())
            {
                reverse(slow, fast);
                slow = fast + 1;
            }
            ++fast;
        }

        return s;
    }
};
```

## 6.2 ä½¿ç”¨é¢å¤–ç©ºé—´

æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$

```c++
class Solution {
public:
    string reverseWords(string s) {
        string ret;
        int length = s.length();
        int i = 0;
        while (i < length) {
            int start = i;
            while (i < length && s[i] != ' ') {
                i++;
            }
            for (int p = start; p < i; p++) {
                ret.push_back(s[start + i - 1 - p]);
            }
            while (i < length && s[i] == ' ') {
                i++;
                ret.push_back(' ');
            }
        }
        return ret;
    }
};
```

# 7 åè½¬å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—æ¯ï¼ˆ345ï¼‰

[345. åè½¬å­—ç¬¦ä¸²ä¸­çš„å…ƒéŸ³å­—æ¯ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/reverse-vowels-of-a-string/)

## 7.1 å·¦å³æŒ‡é’ˆ

```c++
class Solution {
    unordered_set<char> set{'a', 'e', 'i', 'o', 'u',
                            'A', 'E', 'I', 'O', 'U'};
public:
    string reverseVowels(string s) {
        int left(0), right(s.size() - 1);

        while(left < right)
        {
            if(set.count(s[left]) and set.count(s[right]))  
            {
                swap(s[left], s[right]);
                ++left;
                --right;
            }
                
            if(set.count(s[left]) == 0)     ++left;
            if(set.count(s[right]) == 0)    --right;
        }

        return s;
    }
};
```

# 8 éªŒè¯å›æ–‡ä¸²ï¼ˆ125ï¼‰

[125. éªŒè¯å›æ–‡ä¸² - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/valid-palindrome/)

## 8.1 åŒæŒ‡é’ˆ

```c++
class Solution {
public:
    bool isPalindrome(string s) {
        int slow(0), fast(0);
        for(; fast < s.size(); ++fast)          // å¿«æ…¢æŒ‡é’ˆé™¤å»éå­—æ¯ç¬¦å·
        {
            if((s[fast] <= 'z' and s[fast] >= 'a') or 
                (s[fast] <= 'Z' and s[fast] >= 'A'))
            {
                s[slow++] = tolower(s[fast]);
            }
            if((s[fast] <= '9' and s[fast] >= '0'))
            {
                s[slow++] = s[fast];
            }
        }

        int left(0), right(slow - 1);
        while(left < right)
        {
            if(s[left++] != s[right--]) return false;
        }
        return true;
    }
};

// è¿›ä¸€æ­¥ä¼˜åŒ–
class Solution {
public:
    bool isPalindrome(string s) {
        int slow(0), fast(0);
        for(; fast < s.size(); ++fast)          // å¿«æ…¢æŒ‡é’ˆé™¤å»éå­—æ¯æ•°å­—ç¬¦å·
        {
            if(islower(s[fast]) or isupper(s[fast]) or isdigit(s[fast]))
            {
                s[slow++] = tolower(s[fast]);	// å¯¹äºæ•°å­—ï¼Œtolowerä¼šç›´æ¥è¿”å›å¯¹åº”æ•°å­—
            }
        }

        int left(0), right(slow - 1);
        while(left < right)
        {
            if(s[left++] != s[right--]) return false;
        }
        return true;
    }
};

// æ›´è¿›ä¸€æ­¥
class Solution {
public:
    bool isPalindrome(string s) {
        int slow(0), fast(0);
        for(; fast < s.size(); ++fast)          // å¿«æ…¢æŒ‡é’ˆé™¤å»éå­—æ¯æ•°å­—ç¬¦å·
        {
            if(isalnum(s[fast]))				// åˆ¤æ–­æ˜¯å¦æ˜¯å­—æ¯æˆ–æ•°å­—
            {
                s[slow++] = tolower(s[fast]); 	// å¯¹äºæ•°å­—ï¼Œtolowerä¼šç›´æ¥è¿”å›å¯¹åº”æ•°å­—
            }
        }

        int left(0), right(slow - 1);
        while(left < right)
        {
            if(s[left++] != s[right--]) return false;
        }
        return true;
    }
};
```

# 9 éªŒè¯å›æ–‡ä¸² IIï¼ˆ680ï¼‰

[680. éªŒè¯å›æ–‡ä¸² II - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/valid-palindrome-ii/)

## 9.1 åŠ¨æ€è§„åˆ’

```c++
// æä½æ•ˆç‡
class Solution {
public:
    bool validPalindrome(string s) {
        int left(0), right(s.size() - 1);
        int flag_l(0), flag_r(0);
        string temp;

        while(left < right)
        {
            if(s[left] != s[right])
            {
                if(left + 1 == right)   return true;
                else if(s[left + 1] == s[right] and s[left] == s[right - 1])
                {
                    flag_r = 1, flag_l = 1;
                    break;
                }
                else if(s[left + 1] == s[right])    
                {   
                    flag_l = 1;
                    break;
                }
                else if(s[left] == s[right - 1])    
                {
                    flag_r = 1;
                    break;
                }
                else    return false;
            }

            --right, ++left;
        }

        if(left >= right)  return true;  

        cout << "r: " << right << endl;
        cout << "l: " << left << endl;
        cout << "flagl: " << flag_l << endl;
        cout << "flagR: " << flag_r << endl;

        if(flag_l)
        {
            for(int i = 0; i < s.size(); ++i) 
                if(i != left)  temp.push_back(s[i]);
            
            int l = 0, r = temp.size() - 1;
            while(l < r)
            {
                if(temp[l] != temp[r]) break;
                ++l, --r;
            }

            if(l >= r)  return true;  
        }

        temp.clear();
        if(flag_r)
        {
            for(int i = 0; i < s.size(); ++i) 
                if(i != right)  temp.push_back(s[i]);
            
            int l = 0, r = temp.size() - 1;
            while(l < r)
            {
                if(temp[l] != temp[r]) break;
                ++l, --r;
            }

            if(l >= r)  return true;  
        }

        return false;
    }
};

// å‚è€ƒåˆ«äººçš„é¢˜è§£
class Solution {
public:
    bool check(string& ss, int left, int right){
        if (left >= right) return true;
        while (left < right){
            if (ss[left] != ss[right]) return false;
            ++ left, -- right;
        }
        return true;
    }

    bool validPalindrome(string s) {
        int l(0), r(s.size() - 1); 
        
        while (l < r){
            if (s[l] != s[r]){
                return check(s, l, r - 1) || check(s, l + 1, r);		// è¿™ä¸ªå¤„ç†å¾ˆå¦™å•Š
            }
            ++ l, -- r;
        }

        return true;
    }
};
```

# 10 æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åºï¼ˆ451ï¼‰

[451. æ ¹æ®å­—ç¬¦å‡ºç°é¢‘ç‡æ’åº - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/sort-characters-by-frequency/)

## 10.1 ä½¿ç”¨Vector+è‡ªå®šä¹‰æ’åº

```c++
// bool mysort(const pair<char, int> &p1, const pair<char, int> &p2)
// {
//     return p1.second > p2.second;
// }

class Solution {
public:
    static bool mysort(const pair<char, int> &p1, const pair<char, int> &p2)		
    {
        return p1.second > p2.second;
    }

    string frequencySort(string s) {
        unordered_map<char, int> map;
        for (const auto &c : s) {
            ++map[c];
        }
        vector<pair<char, int>> vec;
        for (const auto &m : map) {
            vec.push_back(m);
        }
        
        sort(vec.begin(), vec.end(), mysort);
        string ret;
        for (const auto &v : vec) {
            ret += string(v.second, v.first);
        }
        return ret;
    }
};
```

## 10.2 ä¼˜å…ˆé˜Ÿåˆ—

```c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> map;
        for (const auto &c : s) {
            ++map[c];
        }
        priority_queue<pair<int, char>> pq;     // é»˜è®¤æŒ‰ç¬¬ä¸€ä¸ªå…ƒç´ è‡ªåŠ¨æ’åºï¼Œä»å¤§åˆ°å°
        for (const auto &m : map) {
            pq.push({m.second, m.first});
        }        
        string ret;
        while (!pq.empty()) {
            auto t = pq.top(); 
            pq.pop();
            ret.append(t.first, t.second);
        }
        return ret;
    }
};
```

## <span style="background:#FF9999;">10.3 åˆ©ç”¨lambdaè‡ªå®šä¹‰æ’åº</span>

![image-20230512113334746](figures/image-20230512113334746.png)

```c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> map;
        for (const auto &c : s) {
            ++map[c];
        }
        sort(s.begin(), s.end(), [&map](char &a, char &b)		// æ­¤å¤„åªèƒ½ç”¨lambdaçš„å½¢å¼å†™ 
             						{ return map[a] > map[b] || (map[a] == map[b] && a < b); });
        return s;
    }
};
```

## <span style="background:#FF9999;">10.4 æ•°ç»„ä¸‹æ ‡ç´¢å¼•</span>

> ğŸ«¥æŠ€ä¸å¦‚äººï¼Œç”˜æ‹œä¸‹é£

```c++
class Solution {
public:
    string frequencySort(string s) {
        unordered_map<char, int> map;
        for (const auto &c : s) {
            ++map[c];
        }
        vector<string> vec(s.size() + 1);
        string res;
        for (const auto &m : map) {
            vec[m.second].append(m.second, m.first);    // m.secondä¸ªm.first
        }
        for (int i = s.size(); i > 0; --i) {
            if (!vec[i].empty()) {
                res.append(vec[i]);
            }
        }
        return res;
    }
};
```

## 10.5 å“ˆå¸Œè¡¨

æŒ‰ç†è¯´ï¼Œæˆ‘è§‰å¾—è¿™ä¸ªæ•ˆç‡åº”è¯¥è›®ä½çš„ï¼Œä½†å®é™…è¿˜è›®é«˜ã€‚

![image-20230512113138551](figures/image-20230512113138551.png)

æ—¶é—´å¤æ‚åº¦ï¼š$O(N^2)$

ç©ºé—´å¤æ‚åº¦ï¼š$O(N)$

æŒ‰ç†è¯´ï¼Œsortçš„æ•ˆç‡åº”è¯¥æ¯”è¿™ä¸ªé«˜ï¼Œç–‘æƒ‘ç–‘æƒ‘ã€‚

```c++
class Solution {
public:
    string frequencySort(string s) {
        int hash[128] = {0};
        
        if(s.size() <= 2)   return s;
        for(int i = 0; i < s.size(); ++i)   ++hash[s[i]];

        vector<pair<char, int>> p;   
        while(1)
        {
            int flag = 0;
            int max_size = 0;
            char max_ch = 0;
            for(int i = 0; i < 128; ++i)
            {
                if(hash[i]) flag = 1;
                if(max_size < hash[i])
                {
                    max_ch = i;
                    max_size = hash[i];
                }
            }

            if(flag == 1)   hash[max_ch] = 0;
            if(flag == 1)   p.emplace_back(pair{max_ch, max_size});    
            else    break;
        }

        s.clear();
        for(auto &iter : p)
        {
            while(iter.second--)
                s.push_back(iter.first);
        }

        return s;
    }
};
```

# 11 å­—ç¬¦ä¸²ä¸­çš„å•è¯æ•°ï¼ˆ434ï¼‰

[434. å­—ç¬¦ä¸²ä¸­çš„å•è¯æ•° - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/number-of-segments-in-a-string/)

## 11.1 é—®é¢˜è½¬æ¢ã€

è€ƒè™‘åˆ°ï¼Œæœ€åä¸€ä¸ªå­—ç¬¦åé¢è·Ÿçš„å°±æ˜¯å°¾åè¿­ä»£å™¨ï¼Œè€Œä¸æ˜¯`' '`ï¼Œè¿™ä¼šå¯¼è‡´æ¡ä»¶åˆ¤æ–­çš„å¤æ‚åŒ–ï¼Œå› æ­¤å¯ä»¥è€ƒè™‘ç›´æ¥åœ¨å°¾éƒ¨æ·»åŠ ä¸€ä¸ª`' '`ã€‚

```c++
class Solution {
public:
    int countSegments(string s) {
        int ans = 0;
        s += ' ';
        for (int i = 1; i < s.size(); i++) 
            if (s[i] == ' ' && s[i - 1] != ' ') ans++;
        return ans;
    }
};
```

## 11.2 åŸåœ°æ³•

æ»¡è¶³å•è¯çš„ç¬¬ä¸€ä¸ªä¸‹æ ‡æœ‰ä»¥ä¸‹ä¸¤ä¸ªæ¡ä»¶ï¼š

- è¯¥ä¸‹æ ‡å¯¹åº”çš„å­—ç¬¦ä¸ä¸ºç©ºæ ¼ï¼›
- è¯¥ä¸‹æ ‡ä¸ºåˆå§‹ä¸‹æ ‡æˆ–è€…è¯¥ä¸‹æ ‡çš„å‰ä¸‹æ ‡å¯¹åº”çš„å­—ç¬¦ä¸ºç©ºæ ¼ï¼›

```c++
class Solution {
public:
    int countSegments(string s) {
        int segmentCount = 0;

        for (int i = 0; i < s.size(); i++) {
            if ((i == 0 || s[i - 1] == ' ') && s[i] != ' ') {
                segmentCount++;
            }
        }

        return segmentCount;
    }
};
```

## <span style="background:#FF9999;">11.3 STLåº“</span>

```c++
class Solution {
public:
    int countSegments(string s) {
        /* é¢˜ç›®ä¸­çš„å•è¯å¹¶ä¸æ˜¯ä¸¥æ ¼æ„ä¹‰ä¸Šçš„å•è¯, è¯´æ˜¯ä¸€ä¸²è¿ç»­çš„å­—ç¬¦æ›´åˆé€‚ã€‚ä¸¤ç§æ€è·¯: 
        * 1ã€ç”¨ç©ºæ ¼åšsplit, æŠŠç©ºçš„ç›´æ¥å¹²æ‰, å‰©ä¸‹çš„ç»Ÿè®¡ä¸€ä¸‹æ•°é‡. 
        * 2ã€ä½¿ç”¨istringstreamå¤„ç†
        */
        istringstream temp(s);   /* ç±»ä¼¼äºcin, ä»¥ç©ºæ ¼(åŒ…æ‹¬è¿ç»­ç©ºæ ¼)ä¸ºåˆ†éš”ç¬¦å°†åŸå­—ç¬¦ä¸²ä¸­çš„å­å­—ç¬¦ä¸²ä¿å­˜ */
        int count = 0;
        while (temp >> s) 
            count++;
        
        return count;
    }
};
```

## 11.4 å¤„ç†è¿ç»­çš„0 + åŸºäºsplitæ¥åš

> æƒ³ä¸åˆ°çš„ï¼Œåˆ«çœ‹äº†ã€‚ğŸ½

ç”¨ç©ºæ ¼åšsplit, æŠŠç©ºçš„ç›´æ¥å¹²æ‰, å‰©ä¸‹çš„ç»Ÿè®¡ä¸€ä¸‹æ•°é‡ã€‚ C++ä¸­å¹¶æ²¡æœ‰åº“å‡½æ•°å®ç°split, æ•…è‡ªå·±å®ç°äº†ä¸€ä¸ªsplit, è€ŒJavaã€C#ã€Pythonç­‰ç­‰å¯ä»¥ä½¿ç”¨åº“å‡½æ•°çš„splitã€‚

```c++
class Solution {
public:
    int countSegments(string s) {
        /* é¢˜ç›®ä¸­çš„å•è¯å¹¶ä¸æ˜¯ä¸¥æ ¼æ„ä¹‰ä¸Šçš„å•è¯, è¯´æ˜¯ä¸€ä¸²è¿ç»­çš„å­—ç¬¦æ›´åˆé€‚ã€‚æ€è·¯2: 
        * ç”¨ç©ºæ ¼åšsplit, æŠŠç©ºçš„ç›´æ¥å¹²æ‰, å‰©ä¸‹çš„ç»Ÿè®¡ä¸€ä¸‹æ•°é‡. 
        */
        s.erase(s.find_last_not_of(' ')+1);         // åˆ é™¤å°¾éƒ¨è¿ç»­ç©ºæ ¼
        s.erase(0, s.find_first_not_of(' '));       // åˆ é™¤å¼€å¤´è¿ç»­ç©ºæ ¼
        auto bothAreSpaces = [](char a, char b) 
        { 
            return isspace(a) && isspace(b); 
        };
        s.erase(unique(s.begin(), s.end(), bothAreSpaces), s.end());  /* å°†ä¸­é—´è¿ç»­çš„ç©ºæ ¼æ¢æˆ1ä¸ª */

        vector<string> parts = split(s, ' ');
        int len = parts.size();
        for (int i = 0; i < len; i++)
        {
            if (parts[i] == "") 
            {
                if (i < len - 1) parts.erase(parts.begin() + i);
                else parts.pop_back();
            }
        }
        
        return parts.size();
    }
    vector<string> split(const string& s, char separator)
    {
        vector<string> tokens;
        string token;
        istringstream tokenStream(s);
        while (getline(tokenStream, token, separator))
        {
            tokens.push_back(token);
        }
        return tokens;
    }
};
```

# 12 å‰Kä¸ªé«˜é¢‘å•è¯ï¼ˆ692ï¼‰

[692. å‰Kä¸ªé«˜é¢‘å•è¯ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/top-k-frequent-words/)

## <span style="background:#FF9999;">12.1 åˆ©ç”¨lambdaè‡ªå®šä¹‰æ’åº</span>

```c++
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string , int> hash;

        for(int i = 0; i < words.size(); ++i)
            ++hash[words[i]];

        sort(words.begin(), words.end(), [&hash](const string &a, const string &b) -> bool
                {
                    return (hash[a] > hash[b]) || (hash[a] == hash[b] && a < b);
                });

        vector<string> ans;
        int sum = 0;
        for(int i = 0; i < k; ++i)
        {
            ans.emplace_back(words[sum]);
            sum += hash[words[sum]];
        }
            

        return ans;
    }
};
```

## 12.2 ä½¿ç”¨Vector+è‡ªå®šä¹‰æ’åºï¼ˆå¾…éªŒè¯ï¼Œåšçš„æ—¶å€™ç»™æˆ‘æŠ¥äº†è¶…å‡ºå†…å­˜é™åˆ¶ï¼Œä½†ç†è®ºä¸Šä»£ç åº”è¯¥OKï¼‰

![image-20230512222608885](figures/image-20230512222608885.png)

```c++
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> hash;
        for (const auto &c : words)     ++hash[c];
            
        vector<pair<string, int>> vec;
        for (const auto &h : hash)  vec.push_back(h);

        sort(vec.begin(), vec.end(), [](pair<string, int> &a, pair<string, int> &b) -> bool
                                    {
                                        return a.second > b.second || (a.second == b.second and a.first > b.first);
                                    });

        vector<string> res;
        for(int i = 0; i < k; ++k)  res.emplace_back(vec[i].first);

        return res;
    }
};
```

## 12.3 ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †æ’åº+lambdaè¡¨è¾¾å¼ + decltypeï¼‰

```c++
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> hash;
        for (const auto &c : words)     ++hash[c];

        auto cmp = [](const pair<string, int>& a, const pair<string, int>& b) {
            return a.second == b.second ? a.first < b.first : a.second > b.second;
        };
            
        priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp)> pq(cmp);
        for(const auto &h: hash)
        {
            pq.push(h);
            if(pq.size() > k)   pq.pop();
        }

        vector<string> res(k);
        for (int i = k - 1; i >= 0; i--)
        {
            res[i] = pq.top().first;		// å…ˆè¿›å…ˆå‡ºï¼Œæœ€å¤§çš„åœ¨æœ€å‰é¢
            pq.pop();
        }

        return res;
    }
};
```

### 12.3.1 ä¸ºä»€ä¹ˆ`priority_queue`çš„ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯`decltype(cmp)`ï¼Œè€Œä¸æ˜¯å¯¹åº”çš„ç±»å‹ï¼Œæ¯”å¦‚`bool`æˆ–å…¶ä»–å†…å®¹ï¼Ÿ

è‡ªå®šä¹‰`priority_queue`æ’åºè§„åˆ™çš„æ—¶å€™ï¼Œå¦‚æœç”¨`lambda`, å°±éœ€è¦ç”¨ `priority_queue<pair<string, int>, vector<pair<string, int>>, decltype(cmp)> que(cmp);`çš„å½¢å¼ã€‚ä¹Ÿå¯ä»¥ä½¿ç”¨ç»“æ„ä½“é‡è½½`operator()`çš„æ–¹æ³•ï¼Œè¿™æ—¶ä¸éœ€è¦`decltype`ã€‚

```c++
typedef pair<string, int> p;
struct comp {
    bool operator() (p& a, p& b) {
         return a.second == b.second ? a.first < b.first : a.second > b.second;//å°é¡¶å †
    }
};
priority_queue<p, vector<p>, comp> pq;
```

ä¹Ÿå¯ä»¥å‚è€ƒï¼š

> priority_queue takes the comparator as a template argument. Lambda functions are objects, and thus can't be used as template arguments (only very few types can be, among them integral types). From [StackOverflow](https://leetcode.cn/link/?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F5807735%2Fc-priority-queue-with-lambda-comparator-error)
>
> [deduction guides for std::priority_queue - cppreference.com](https://en.cppreference.com/w/cpp/container/priority_queue/deduction_guides)

## 12.4 ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå †æ’åº+ struct + é‡è½½æ“ä½œç¬¦`()`ï¼‰

```c++
class Solution {
public:
    struct cmp {
        bool operator()(const pair<string, int> &a, const pair<string, int> &b) {
			return a.second == b.second ? a.first < b.first : a.second > b.second;
        }
    };
    
    vector<string> topKFrequent(vector<string>& words, int k) {
        unordered_map<string, int> hash;
        for (const auto &c : words)     ++hash[c];
            
        priority_queue<pair<string, int>, vector<pair<string, int>>, cmp> pq;
        for(const auto &h: hash)
        {
            pq.push(h);
            if(pq.size() > k)   pq.pop();
        }

        vector<string> res(k);
        for (int i = k - 1; i >= 0; i--)
        {
            res[i] = pq.top().first;		// å…ˆè¿›å…ˆå‡ºï¼Œæœ€å¤§çš„åœ¨æœ€å‰é¢
            pq.pop();
        }

        return res;
    }
};
```

# 13 æ£€æµ‹å¤§å†™å­—æ¯ï¼ˆ520ï¼‰

[520. æ£€æµ‹å¤§å†™å­—æ¯ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/detect-capital/)

## 13.1 æ¨¡æ‹Ÿæ³•ï¼ˆæ ¹æ®é¢˜ç›®è¦æ±‚å®ç°ï¼‰

```c++
class Solution {
public:
    bool detectCapitalUse(string word) {
        int count(0);
        
        for(int i = 0; i < word.size(); ++i)
            if(isupper(word[i]))  ++count;
        
        if(isupper(word[0]))
        {
            if(count == 1)  return true;
            if(word.size() == count)    return true;
            return false;
        }

        if(count >= 1)  return false;
        return true;
    }
};

//å®˜æ–¹é¢˜è§£
class Solution {
public:
    bool detectCapitalUse(string word) {
        // è‹¥ç¬¬ 1 ä¸ªå­—æ¯ä¸ºå°å†™ï¼Œåˆ™éœ€é¢å¤–åˆ¤æ–­ç¬¬ 2 ä¸ªå­—æ¯æ˜¯å¦ä¸ºå°å†™
        if (word.size() >= 2 && islower(word[0]) && isupper(word[1])) {
            return false;
        }
        
        // æ— è®ºç¬¬ 1 ä¸ªå­—æ¯æ˜¯å¦å¤§å†™ï¼Œå…¶ä»–å­—æ¯å¿…é¡»ä¸ç¬¬ 2 ä¸ªå­—æ¯çš„å¤§å°å†™ç›¸åŒ
        for (int i = 2; i < word.size(); ++i) {
            if (islower(word[i]) ^ islower(word[1])) {
                return false;
            }
        }
        return true;
    }
};
```

### 4.13.2 è½¬æ¢é—®é¢˜

è¿™ç§æ–¹æ³•å·²ç»è§è¿‡ä¸æ­¢ä¸€æ¬¡äº†ï¼Œè½¬æ¢é—®é¢˜å¾€å¾€æ˜¯ä¸€ç§è¡Œä¹‹æœ‰æ•ˆçš„æ–¹æ³•ï¼ˆå‰ææ˜¯â€¦â€¦ï¼‰ã€‚

```c++
class Solution {
public:
    bool detectCapitalUse(string word) {
        int uc = 0;
        for (int i = 0; i < word.size(); i++) {
            if (isupper(word[i]) && uc++ < i) {
                return false;
            }
        }
        
        return uc == word.size() || uc <= 1;
    }
};
```

â€¦â€¦å‰ææ˜¯ï¼Œyou can really understand it and realize or achieve it.

# 14 æœ€é•¿å…¬å…±å‰ç¼€ï¼ˆ14ï¼‰

[14. æœ€é•¿å…¬å…±å‰ç¼€ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/longest-common-prefix/)

## 14.1 çºµå‘æ‰«æ

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        string res = strs[0];             //é€‰æ‹©ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä½œä¸ºå¯¹ç…§æ ‡å‡†
        for(int i = 1; i < strs.size(); i++)
        {
            for(int j = 0; j < res.length(); j++)
            {
                if(res[j] == strs[i][j])    continue;
                else    res.erase(j);       //æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸ç¬¦åˆçš„å­—ç¬¦ä½ç½®ï¼Œä»pos=jå¤„å¼€å§‹åˆ é™¤ç›´è‡³ç»“å°¾
                break;
            }
        }
        return res;
    }
};

class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        //å­—ç¬¦ä¸²æ•°ç»„ä¸ºç©ºåˆ™ç½®resä¸ºç©ºï¼Œå¦åˆ™ç½®ä¸ºç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²
        string res = strs.empty() ? "" : strs[0]; 
        //éå†å­—ç¬¦ä¸²æ•°ç»„
        for (string s : strs)
        {
            /*
            åœ¨å­—ç¬¦ä¸²sä¸­æŸ¥æ‰¾reså¹¶è¿”å›é¦–å­—æ¯çš„ä½ç½®ï¼ˆfindå‡½æ•°ï¼‰
            å¦‚æœé¦–åœ°å€ä¸ä¸ºé›¶ï¼Œæ¯æ¬¡ä»¤res-1ä»¥ç¼©çŸ­å…¬å…±å‰ç¼€
            æ¯”å¦‚è¯´å†flowä¸­æŸ¥æ‰¾flowerï¼Œæ²¡æœ‰æ‰¾åˆ°ï¼Œè¿”å›å€¼ä¸ºè¿­ä»£å™¨ç»“å°¾ï¼ˆé0ï¼‰
            å…¬å…±å‰ç¼€ä¼šå‡æ‰æœ€åä¸€ä¸ªå­—æ¯ï¼Œä¸ºfloweã€‚ç»§ç»­å¾ªç¯ç›´åˆ°ä¸ºflow

            å¦‚æœæ˜¯é¦–å­—æ¯ä¸ä¸€æ ·åˆ™å…¬å…±å‰ç¼€ä¼šæ¸…ç©º
            */ 
            while (s.find(res) != 0) 
            {
                res = res.substr(0, res.length() - 1);
            }
        }
        return res;
    }
};
```

# 15 æœ€é•¿ç‰¹æ®Šåºåˆ— â… ï¼ˆ521ï¼‰

[521. æœ€é•¿ç‰¹æ®Šåºåˆ— â…  - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/longest-uncommon-subsequence-i/)

## 15.1 ç®€å•é¢˜è§£

å…¶å®è¿™é¢˜æœ€é‡è¦çš„æ˜¯çœ‹æ˜ç™½é¢˜ç›®çš„æ„æ€ï¼š

1. ä¸¤å­—ç¬¦ä¸²é•¿åº¦ä¸ç­‰ï¼Œç‰¹æ®Šåºåˆ—å³ä¸ºè¾ƒå¤§å­—ç¬¦ä¸²ï¼›
2. è‹¥é•¿åº¦ç›¸ç­‰ä¸”å­—ç¬¦ä¸²ç›¸åŒè¿”å›-1ï¼›
3. è‹¥é•¿åº¦ç›¸ç­‰ï¼Œå­—ç¬¦ä¸²ä¸åŒï¼Œè¿”å›aæˆ–bé•¿åº¦ã€‚

```c++
class Solution {
public:
    int findLUSlength(string a, string b) {
        return a != b ? max(a.length(), b.length()) : -1;
    }
};
```

# 16 æœ€é•¿ç‰¹æ®Šåºåˆ— IIï¼ˆ522ï¼‰

[522. æœ€é•¿ç‰¹æ®Šåºåˆ— II - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/longest-uncommon-subsequence-ii/)

## 16.1 åŒæŒ‡é’ˆ

```c++
class Solution {
public:
    int findLUSlength(vector<string>& strs) {
        int i, j;
        int res, flag;
        res = -1;
        for(i = 0;i < strs.size(); i++){
            flag = 1;
            for(j = 0; j < strs.size(); j++){
                if(i == j)  continue;
                if(isSubseq(strs[i], strs[j]) == 1) flag = 0;
            }
            if (flag == 1 && res < (int)strs[i].size()){
                res = strs[i].size();
            }
        }
        return res;
    }
    bool isSubseq(string& s1, string& s2){
        int i = 0, j = 0;
        while (i < s1.size() && j < s2.size()){
            if(s2[j] != s1[i]){
                j++;
            }
            else{
                i++;
                j++;
            }
        }
        return i >= s1.size();
    }
};
```

## 16.2 å¼€æ‹“æ€è·¯ï¼ˆåè¯æ³•ï¼‰

æ€§è´¨ï¼š è‹¥ s çš„å­ä¸²æ˜¯ç‰¹æ®Šåºåˆ—ï¼Œåˆ™sä¹Ÿæ˜¯ç‰¹æ®Šåºåˆ—ï¼Œå› æ­¤åªéœ€çœ‹æ•´ä½“å­—ç¬¦å°±å¯ä»¥ã€‚

åè¯æ³•ï¼šè‹¥å­—ç¬¦ä¸² s ä¸æ˜¯ç‰¹æ®Šåºåˆ—çš„è¯ï¼Œåˆ™è¯¥å­—ç¬¦ä¸²ä¸€å®šæ˜¯å…¶å®ƒæŸä¸ªå­—ç¬¦ä¸² t çš„å­åºåˆ—ï¼Œé‚£ä¹ˆå°±å¯ä»¥é€šè¿‡åˆ é™¤ t çš„éƒ¨åˆ†å­—ç¬¦ï¼Œä½¿å¾— t çš„æŸä¸ªå­åºåˆ—æ˜¯ s1 ï¼Œs1 ä¸æ˜¯ç‰¹æ®Šåºåˆ—ï¼Œæ•… sä¸€å®šæ˜¯ç‰¹æ®Šåºåˆ—ã€‚

æ€§è´¨çš„ä½¿ç”¨ï¼šç‰¹æ®Šåºåˆ—åªéœ€è¦è€ƒè™‘æ•´ä¸ªå­—ç¬¦ä¸²å³å¯ï¼Œä¸éœ€è¦æšä¸¾å­ä¸²ï¼Œå› ä¸ºå¦‚æœå­ä¸²æ˜¯ç‰¹æ®Šåºåˆ—ï¼Œé‚£ä¹ˆå­—ç¬¦ä¸² s æœ¬èº«ä¹Ÿæ˜¯ç‰¹æ®Šåºåˆ—ï¼Œä¸”æ›´é•¿ï¼Œå› æ­¤**åªéœ€è¦å¯¹æ¯ä¸ªå­—ç¬¦ä¸² s è¿›è¡Œåˆ¤æ–­ï¼Œæ˜¯å¦æ˜¯å…¶ä»–å­—ç¬¦ä¸²çš„å­ä¸²å³å¯**ã€‚

```c++
class Solution {
public:
    bool isSubStr(string &a, string &b){//åˆ¤æ–­aæ˜¯å¦ä¸ºbçš„å­ä¸²
        int i = 0;
        for (auto c: b)
            if (i < a.size() && c == a[i]) i++ ;
        return i == a.size();
    }
    int findLUSlength(vector<string>& strs) {
        sort(strs.begin(),strs.end(),[](string a, string b){    //æŒ‰ç…§é•¿åº¦ä»å¤§åˆ°å°æ’ 
            return a.size()>b.size();
        });
        for(int i = 0; i < strs.size(); i++){   //æŒ‰ç…§é•¿åº¦ä»å¤§åˆ°å°æšä¸¾ä¸²i åˆ¤æ–­iä¼šå¦æ˜¯ç‰¹æ®Šåºåˆ—
            bool isSub = false;                 //å…ˆå‡è®¾iä¸æ˜¯ä»»ä½•ä¸²çš„å­ä¸²
            for(int j = 0; j < strs.size() && strs[i].size() <= strs[j].size(); j++){   //åˆ¤æ–­iæ˜¯å¦ä¸ºjçš„å­ä¸²
                if(i != j && isSubStr(strs[i], strs[j])){   //è‹¥iæ˜¯jçš„å­ä¸² åˆ™iä¸æ˜¯ç‰¹æ®Šåºåˆ— è·³å‡ºå³å¯ 
                    isSub = true;
                    break;
                }
            }
            if(!isSub) return strs[i].size();       //iä¸æ˜¯ä»»ä½•ä¸²çš„å­ä¸² åˆ™ä¸ºç‰¹æ®Šåºåˆ— ç›´æ¥è¿”å›å³å¯ 
        }
        return -1;
    }
};
```

# 17 è®¡æ•°äºŒè¿›åˆ¶å­ä¸²ï¼ˆ696ï¼‰

[696. è®¡æ•°äºŒè¿›åˆ¶å­ä¸² - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/count-binary-substrings/)

## 17.1 æš´åŠ›è§£æ³•

è¶…æ—¶äº†

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚

```c++
class Solution {
public:
    int countBinarySubstrings(string s) {
        int res(0);

        if(s.size() == 1)   return 0;
        for(int i(0); i < s.size() - 1; ++i)
        {
            int sum(0);
            int flag(0);
            int size1(1), size2(0);
            for(int j(i + 1); j < s.size(); ++j)
            {
                if(s[j] == s[i] and flag == 0)  size1++;
                if(s[j] == s[i] and flag == 1)  break;
                if(s[j] != s[i])
                {
                    flag = 1;
                    size2++;
                }
                if(flag == 1 and size1 == size2)    res++;  
            }
        }

        return res;
    }
};
```

## 17.2 æŒ‰å­—ç¬¦åˆ†ç»„ã€ä¸€æ¬¡éå†

- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ã€‚

```c++
class Solution {
public:
    int countBinarySubstrings(string s) {
        int ptr = 0, n = s.size(), last = 0, ans = 0;
        while (ptr < n) {
            char c = s[ptr];
            int count = 0;
            while (ptr < n && s[ptr] == c) {
                ++ptr;				// æ­¤å¤„å®ç°äº†ptrçš„ä¸€æ¬¡éå†
                ++count;
            }
            ans += min(count, last);	// æ­¤å¤„è½¬æ¢äº†é—®é¢˜, å°†è®¡æ•°ä¸åŒ¹é…é—®é¢˜, è½¬æ¢ä¸ºäº†æœ‰å¤šå°‘ä¸ª1æˆ–0çš„æœ€å°å€¼
            last = count;
        }
        return ans;
    }
};

// ä¼˜åŒ–ç®—æ³•
class Solution {
public:
    int countBinarySubstrings(string s) {
        int i = 0, pre = 0, cur = 1, ans = 0;
        for (int i = 0; i < s.size() - 1; ++i) {
            if(s[i] == s[i + 1]) ++cur;
            else
            {
                pre = cur;
                cur = 1;
            }
            if(pre >= cur)  ++ans;
        }
        return ans;
    }
};
```

# 18 ä¸¤æ•°ç›¸åŠ ï¼ˆ2ï¼‰

[2. ä¸¤æ•°ç›¸åŠ  - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/add-two-numbers/)

## 18.1 æ¨¡æ‹Ÿé¢˜

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *dummy = new ListNode(0); // è¾…åŠ©èŠ‚ç‚¹
        ListNode *pre = dummy;
        int carry = 0;
        while (l1 != nullptr || l2 != nullptr) {
            int n1 = l1 != nullptr ? l1->val : 0;
            int n2 = l2 != nullptr ? l2->val : 0;
            int sum = n1 + n2 + carry;
            pre->next = new ListNode(sum % 10);
            carry = sum / 10;
            
            pre = pre->next;
            if (l1 != nullptr) l1 = l1->next;
            if (l2 != nullptr) l2 = l2->next;
        }
        if (carry > 0) pre->next = new ListNode(carry);
        
        return dummy->next;
    }
};
```

# 19 ç§»é™¤å…ƒç´ ï¼ˆ27ï¼‰

## 19.1 åŒæŒ‡é’ˆä¼˜åŒ–

```c++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;

        for(int i = 0; i < nums.size(); i++)
            if(nums[i] != val)	nums[slow++] = nums[i];

        return slow;
    }
};
```

# 20 åˆ é™¤å­—ç¬¦ä½¿é¢‘ç‡ç›¸åŒ

[2423. åˆ é™¤å­—ç¬¦ä½¿é¢‘ç‡ç›¸åŒ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/remove-letter-to-equalize-frequency/)

## 20.1 æ’åº+åˆ†ç±»è®¨è®º

```c++
class Solution {
public:
  bool equalFrequency(string word) {
    std::vector<int> freq(26, 0);
    for (char ch : word) {
      freq[ch - 'a']++;
    }
    freq.erase(std::remove(freq.begin(), freq.end(), 0),
               freq.end());
    std::sort(freq.begin(), freq.end());

    int n = freq.size();
    if (n == 1) {
      return true;
    }
    if (freq[0] == 1 && freq[1] == freq.back()) {
      return true;
    }
    if (freq[n - 1] == freq[n - 2] + 1) {
      if (n == 2 || freq[0] == freq[n - 2]) {
        return true;
      }
    }
    return false;
  }
};

```

# 21 åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹ï¼ˆ19ï¼‰

[19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

## 21.1 åŒæŒ‡é’ˆ

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0);  //å“‘èŠ‚ç‚¹
        if(!head)  return head;
        dummy->next = head;
        ListNode* p = dummy;
        ListNode* q = dummy;
        for(int i=0; i<n;i++)
        {
            q=q->next;
        }
        while(q->next)
        {
           p= p->next;
           q= q->next;
        }
        p->next = p->next->next;  //åˆ é™¤p->nextçš„èŠ‚ç‚¹
   
        ListNode* res = dummy->next;
        delete dummy;   //åˆ é™¤å“‘èŠ‚ç‚¹
        return res;

    }
};
```

# 22 å›æ–‡æ•°ï¼ˆ9ï¼‰

[9. å›æ–‡æ•° - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/palindrome-number/description/)

## 22.1 åè½¬ä¸€åŠæ•°å­—

```c++
class Solution {
public:
    bool isPalindrome(int x) {
        // ç‰¹æ®Šæƒ…å†µï¼š
        // å¦‚ä¸Šæ‰€è¿°ï¼Œå½“ x < 0 æ—¶ï¼Œx ä¸æ˜¯å›æ–‡æ•°ã€‚
        // åŒæ ·åœ°ï¼Œå¦‚æœæ•°å­—çš„æœ€åä¸€ä½æ˜¯ 0ï¼Œä¸ºäº†ä½¿è¯¥æ•°å­—ä¸ºå›æ–‡ï¼Œ
        // åˆ™å…¶ç¬¬ä¸€ä½æ•°å­—ä¹Ÿåº”è¯¥æ˜¯ 0
        // åªæœ‰ 0 æ»¡è¶³è¿™ä¸€å±æ€§
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }

        // å½“æ•°å­—é•¿åº¦ä¸ºå¥‡æ•°æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ revertedNumber/10 å»é™¤å¤„äºä¸­ä½çš„æ•°å­—ã€‚
        // ä¾‹å¦‚ï¼Œå½“è¾“å…¥ä¸º 12321 æ—¶ï¼Œåœ¨ while å¾ªç¯çš„æœ«å°¾æˆ‘ä»¬å¯ä»¥å¾—åˆ° x = 12ï¼ŒrevertedNumber = 123ï¼Œ
        // ç”±äºå¤„äºä¸­ä½çš„æ•°å­—ä¸å½±å“å›æ–‡ï¼ˆå®ƒæ€»æ˜¯ä¸è‡ªå·±ç›¸ç­‰ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç®€å•åœ°å°†å…¶å»é™¤ã€‚
        return x == revertedNumber || x == revertedNumber / 10;
    }
};
```

# 23 æœ‰æ•ˆæ—¶é—´çš„æ•°ç›®ï¼ˆ2437ï¼‰

[2437. æœ‰æ•ˆæ—¶é—´çš„æ•°ç›® - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/number-of-valid-clock-times/)

## 23.1 ä¹˜æ³•åŸç†

```c++
class Solution {
    int count(string t, int period) {
        int ans = 0;
        for (int i = 0; i < period; i++)
            if ((t[0] == '?' || i / 10 == t[0] - '0') &&
                (t[1] == '?' || i % 10 == t[1] - '0'))
                ans++;
        return ans;
    }
public:
    int countTime(string time) {
        return count(time.substr(0, 2), 24) * count(time.substr(3), 60);
    }
};
```

## 23.2 æšä¸¾

æšä¸¾å°±æ˜¯äº†ï¼Œåˆ«æƒ¯ç€

```c++
class Solution {
    public int countTime(String time) {
        int ans = 1;
        char a = time.charAt(0), b = time.charAt(1), c = time.charAt(3), d = time.charAt(4);
        if (d == '?') ans *= 10;
        if (c == '?') ans *= 6;
        if (a == '?' && b == '?') {
            ans *= 24;
        } else if (b == '?') {
            if (a == '2') ans *= 4;
            else ans *= 10;
        } else if (a == '?') {
            if (b <= '9' && b >= '4') ans *= 2;
            else ans *= 3;
        }
        return ans;
    }
}
```

# 24 æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„ä¸‹æ ‡ï¼ˆ28ï¼‰

[28. æ‰¾å‡ºå­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªåŒ¹é…é¡¹çš„ä¸‹æ ‡ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)

## 24.1 åº“å‡½æ•°

```c++
class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle.empty())
            return 0;
        int pos=haystack.find(needle);
        return pos;
    }
};
```

## 24.2 æš´åŠ›è§£æ³•

```c++
class Solution {
public:
    int strStr(string haystack, string needle) {
        char n_1 = needle[0];
        int i = 0;
        int j = 0;

        if(needle.size() > haystack.size()) return -1;
        for(i = 0; i < haystack.size(); i++)
        {
            if(haystack[i] == n_1)
            {
                for(j = i; j < haystack.size() && (j - i < needle.size()); j++)
                {
                    if(haystack[j] == needle[j - i])
                    {
                        continue;
                    }
                    break;
                }
                if(j - i == needle.size())    return i;
            }
        }

        return -1;
    }
};
```

## 24.3 KMP

```c++
class Solution {
public:
    vector<int> getnext(string str)
        {
            int len = str.size();
            vector<int> next;
            next.push_back(-1);//nextæ•°ç»„åˆå€¼ä¸º-1
            int j = 0, k = -1;
            while(j < len - 1)
            {
                if(k == -1 || str[j] == str[k])//str[j]åç¼€ str[k]å‰ç¼€
                {
                    j++;
                    k++;
                    next.push_back(k);
                }
                else
                {
                    k = next[k];
                }
            }
            return next;
        }
    int strStr(string haystack, string needle) {
        if(needle.empty())  return 0;

        int i = 0;      //æºä¸²
        int j = 0;      //å­ä¸²
        int len1 = haystack.size();
        int len2 = needle.size();
        vector<int> next;
        next = getnext(needle);
        while((i < len1) && (j < len2))
        {
            if((j == -1) || (haystack[i] == needle[j]))
            {
                i++;
                j++;
            }
            else
            {
                j = next[j];    //è·å–ä¸‹ä¸€æ¬¡åŒ¹é…çš„ä½ç½®
            }
        }
        if(j == len2)
            return i - j;
        
        return -1;
    }
};
```

# 25 æ‰“å®¶åŠ«èˆï¼ˆ198ï¼‰

[198. æ‰“å®¶åŠ«èˆ - åŠ›æ‰£ï¼ˆLeetcodeï¼‰](https://leetcode.cn/problems/house-robber/description/)

## 25.1 åŠ¨æ€è§„åˆ’

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) {
            return 0;
        }
        int size = nums.size();
        if (size == 1) {
            return nums[0];
        }
        vector<int> dp = vector<int>(size, 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < size; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[size - 1];
    }
};
```

